
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for generated/db1/runtime/library.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../prettify.css" />
    <link rel="stylesheet" href="../../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../../index.html">All files</a> / <a href="index.html">generated/db1/runtime</a> library.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">26.31% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>1184/4499</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">13.53% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>526/3886</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">20.42% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>272/1332</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">64% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>32/50</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a>
<a name='L12'></a><a href='#L12'>12</a>
<a name='L13'></a><a href='#L13'>13</a>
<a name='L14'></a><a href='#L14'>14</a>
<a name='L15'></a><a href='#L15'>15</a>
<a name='L16'></a><a href='#L16'>16</a>
<a name='L17'></a><a href='#L17'>17</a>
<a name='L18'></a><a href='#L18'>18</a>
<a name='L19'></a><a href='#L19'>19</a>
<a name='L20'></a><a href='#L20'>20</a>
<a name='L21'></a><a href='#L21'>21</a>
<a name='L22'></a><a href='#L22'>22</a>
<a name='L23'></a><a href='#L23'>23</a>
<a name='L24'></a><a href='#L24'>24</a>
<a name='L25'></a><a href='#L25'>25</a>
<a name='L26'></a><a href='#L26'>26</a>
<a name='L27'></a><a href='#L27'>27</a>
<a name='L28'></a><a href='#L28'>28</a>
<a name='L29'></a><a href='#L29'>29</a>
<a name='L30'></a><a href='#L30'>30</a>
<a name='L31'></a><a href='#L31'>31</a>
<a name='L32'></a><a href='#L32'>32</a>
<a name='L33'></a><a href='#L33'>33</a>
<a name='L34'></a><a href='#L34'>34</a>
<a name='L35'></a><a href='#L35'>35</a>
<a name='L36'></a><a href='#L36'>36</a>
<a name='L37'></a><a href='#L37'>37</a>
<a name='L38'></a><a href='#L38'>38</a>
<a name='L39'></a><a href='#L39'>39</a>
<a name='L40'></a><a href='#L40'>40</a>
<a name='L41'></a><a href='#L41'>41</a>
<a name='L42'></a><a href='#L42'>42</a>
<a name='L43'></a><a href='#L43'>43</a>
<a name='L44'></a><a href='#L44'>44</a>
<a name='L45'></a><a href='#L45'>45</a>
<a name='L46'></a><a href='#L46'>46</a>
<a name='L47'></a><a href='#L47'>47</a>
<a name='L48'></a><a href='#L48'>48</a>
<a name='L49'></a><a href='#L49'>49</a>
<a name='L50'></a><a href='#L50'>50</a>
<a name='L51'></a><a href='#L51'>51</a>
<a name='L52'></a><a href='#L52'>52</a>
<a name='L53'></a><a href='#L53'>53</a>
<a name='L54'></a><a href='#L54'>54</a>
<a name='L55'></a><a href='#L55'>55</a>
<a name='L56'></a><a href='#L56'>56</a>
<a name='L57'></a><a href='#L57'>57</a>
<a name='L58'></a><a href='#L58'>58</a>
<a name='L59'></a><a href='#L59'>59</a>
<a name='L60'></a><a href='#L60'>60</a>
<a name='L61'></a><a href='#L61'>61</a>
<a name='L62'></a><a href='#L62'>62</a>
<a name='L63'></a><a href='#L63'>63</a>
<a name='L64'></a><a href='#L64'>64</a>
<a name='L65'></a><a href='#L65'>65</a>
<a name='L66'></a><a href='#L66'>66</a>
<a name='L67'></a><a href='#L67'>67</a>
<a name='L68'></a><a href='#L68'>68</a>
<a name='L69'></a><a href='#L69'>69</a>
<a name='L70'></a><a href='#L70'>70</a>
<a name='L71'></a><a href='#L71'>71</a>
<a name='L72'></a><a href='#L72'>72</a>
<a name='L73'></a><a href='#L73'>73</a>
<a name='L74'></a><a href='#L74'>74</a>
<a name='L75'></a><a href='#L75'>75</a>
<a name='L76'></a><a href='#L76'>76</a>
<a name='L77'></a><a href='#L77'>77</a>
<a name='L78'></a><a href='#L78'>78</a>
<a name='L79'></a><a href='#L79'>79</a>
<a name='L80'></a><a href='#L80'>80</a>
<a name='L81'></a><a href='#L81'>81</a>
<a name='L82'></a><a href='#L82'>82</a>
<a name='L83'></a><a href='#L83'>83</a>
<a name='L84'></a><a href='#L84'>84</a>
<a name='L85'></a><a href='#L85'>85</a>
<a name='L86'></a><a href='#L86'>86</a>
<a name='L87'></a><a href='#L87'>87</a>
<a name='L88'></a><a href='#L88'>88</a>
<a name='L89'></a><a href='#L89'>89</a>
<a name='L90'></a><a href='#L90'>90</a>
<a name='L91'></a><a href='#L91'>91</a>
<a name='L92'></a><a href='#L92'>92</a>
<a name='L93'></a><a href='#L93'>93</a>
<a name='L94'></a><a href='#L94'>94</a>
<a name='L95'></a><a href='#L95'>95</a>
<a name='L96'></a><a href='#L96'>96</a>
<a name='L97'></a><a href='#L97'>97</a>
<a name='L98'></a><a href='#L98'>98</a>
<a name='L99'></a><a href='#L99'>99</a>
<a name='L100'></a><a href='#L100'>100</a>
<a name='L101'></a><a href='#L101'>101</a>
<a name='L102'></a><a href='#L102'>102</a>
<a name='L103'></a><a href='#L103'>103</a>
<a name='L104'></a><a href='#L104'>104</a>
<a name='L105'></a><a href='#L105'>105</a>
<a name='L106'></a><a href='#L106'>106</a>
<a name='L107'></a><a href='#L107'>107</a>
<a name='L108'></a><a href='#L108'>108</a>
<a name='L109'></a><a href='#L109'>109</a>
<a name='L110'></a><a href='#L110'>110</a>
<a name='L111'></a><a href='#L111'>111</a>
<a name='L112'></a><a href='#L112'>112</a>
<a name='L113'></a><a href='#L113'>113</a>
<a name='L114'></a><a href='#L114'>114</a>
<a name='L115'></a><a href='#L115'>115</a>
<a name='L116'></a><a href='#L116'>116</a>
<a name='L117'></a><a href='#L117'>117</a>
<a name='L118'></a><a href='#L118'>118</a>
<a name='L119'></a><a href='#L119'>119</a>
<a name='L120'></a><a href='#L120'>120</a>
<a name='L121'></a><a href='#L121'>121</a>
<a name='L122'></a><a href='#L122'>122</a>
<a name='L123'></a><a href='#L123'>123</a>
<a name='L124'></a><a href='#L124'>124</a>
<a name='L125'></a><a href='#L125'>125</a>
<a name='L126'></a><a href='#L126'>126</a>
<a name='L127'></a><a href='#L127'>127</a>
<a name='L128'></a><a href='#L128'>128</a>
<a name='L129'></a><a href='#L129'>129</a>
<a name='L130'></a><a href='#L130'>130</a>
<a name='L131'></a><a href='#L131'>131</a>
<a name='L132'></a><a href='#L132'>132</a>
<a name='L133'></a><a href='#L133'>133</a>
<a name='L134'></a><a href='#L134'>134</a>
<a name='L135'></a><a href='#L135'>135</a>
<a name='L136'></a><a href='#L136'>136</a>
<a name='L137'></a><a href='#L137'>137</a>
<a name='L138'></a><a href='#L138'>138</a>
<a name='L139'></a><a href='#L139'>139</a>
<a name='L140'></a><a href='#L140'>140</a>
<a name='L141'></a><a href='#L141'>141</a>
<a name='L142'></a><a href='#L142'>142</a>
<a name='L143'></a><a href='#L143'>143</a>
<a name='L144'></a><a href='#L144'>144</a></td><td class="line-coverage quiet"><span class="cline-any cline-yes">1758x</span>
<span class="cline-any cline-yes">14x</span>
<span class="cline-any cline-yes">93x</span>
<span class="cline-any cline-yes">16x</span>
<span class="cline-any cline-yes">15x</span>
<span class="cline-any cline-yes">5x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">14x</span>
<span class="cline-any cline-yes">2x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">14x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">584x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">2x</span>
<span class="cline-any cline-yes">2x</span>
<span class="cline-any cline-yes">2x</span>
<span class="cline-any cline-yes">6x</span>
<span class="cline-any cline-yes">63x</span>
<span class="cline-any cline-yes">2x</span>
<span class="cline-any cline-yes">9x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">5x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">5x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">2x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">5x</span>
<span class="cline-any cline-yes">30x</span>
<span class="cline-any cline-yes">5x</span>
<span class="cline-any cline-yes">5x</span>
<span class="cline-any cline-yes">5x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">41x</span>
<span class="cline-any cline-yes">4x</span>
<span class="cline-any cline-yes">4x</span>
<span class="cline-any cline-yes">4x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">4x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">5x</span>
<span class="cline-any cline-yes">2x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">"use strict";var ru=Object.create;var Fr=Object.defineProperty;var nu=Object.getOwnPropertyDescriptor;var iu=Object.getOwnPropertyNames;var ou=Object.getPrototypeOf,su=Object.prototype.hasOwnProperty;var Z=(e,t)=&gt;()=&gt;(t||e((t={exports:{}}).exports,t),t.exports),Bt=(e,t)=&gt;{for(var r in t)Fr(e,r,{get:t[r],enumerable:!0})},wo=(e,t,r,n)=&gt;{<span class="missing-if-branch" title="else path not taken" >E</span>if(t&amp;&amp;typeof t=="object"||typeof t=="function")for(let i of iu(t))!su.call(e,i)&amp;&amp;i!==r&amp;&amp;Fr(e,i,{get:()=&gt;t[i],enumerable:!(n=nu(t,i))||n.enumerable});return e};var D=(e,t,r)=&gt;(r=e!=null?ru(ou(e)):<span class="branch-1 cbranch-no" title="branch not covered" >{},</span>wo(t||!e||!e.__esModule?Fr(r,"default",{value:e,enumerable:!0}):r,e)),au=e=&gt;wo(Fr({},"__esModule",{value:!0}),e);var Qo=Z((yf,ti)=&gt;{"use strict";var v=ti.exports;ti.exports.default=v;var _="\x1B[",Ht="\x1B]",mt="\x07",Jr=";",Uo=process.env.TERM_PROGRAM==="Apple_Terminal";v.cursorTo=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >if(typeof e!="number")<span class="cstat-no" title="statement not covered" >throw new TypeError("The `x` argument is required");<span class="cstat-no" title="statement not covered" >r</span></span>eturn typeof t!="number"?_+(e+1)+"G":_+(t+1)+";"+(e+1)+"H"}</span>;v.cursorMove=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >if(typeof e!="number")<span class="cstat-no" title="statement not covered" >throw new TypeError("The `x` argument is required");l</span></span>et r=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>return e&lt;0?r+=_+-e+"D":e&gt;0&amp;&amp;(r+=_+e+"C"),t&lt;0?r+=_+-t+"A":t&gt;0&amp;&amp;(r+=_+t+"B"),r}</span>;v.cursorUp=<span class="fstat-no" title="function not covered" >(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>=&gt;<span class="cstat-no" title="statement not covered" >_+e+"A";</span>v.cursorDown=<span class="fstat-no" title="function not covered" >(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>=&gt;<span class="cstat-no" title="statement not covered" >_+e+"B";</span>v.cursorForward=<span class="fstat-no" title="function not covered" >(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>=&gt;<span class="cstat-no" title="statement not covered" >_+e+"C";</span>v.cursorBackward=<span class="fstat-no" title="function not covered" >(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>=&gt;<span class="cstat-no" title="statement not covered" >_+e+"D";</span>v.cursorLeft=_+"G";v.cursorSavePosition=Uo?<span class="branch-0 cbranch-no" title="branch not covered" >"\x1B7":</span>_+"s";v.cursorRestorePosition=Uo?<span class="branch-0 cbranch-no" title="branch not covered" >"\x1B8":</span>_+"u";v.cursorGetPosition=_+"6n";v.cursorNextLine=_+"E";v.cursorPrevLine=_+"F";v.cursorHide=_+"?25l";v.cursorShow=_+"?25h";v.eraseLines=<span class="fstat-no" title="function not covered" >e=</span>&gt;{let t=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>for(let r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;e;r++)<span class="cstat-no" title="statement not covered" >t+=v.eraseLine+(r&lt;e-1?v.cursorUp():"");<span class="cstat-no" title="statement not covered" >r</span></span>eturn e&amp;&amp;(t+=v.cursorLeft),t}</span>;v.eraseEndLine=_+"K";v.eraseStartLine=_+"1K";v.eraseLine=_+"2K";v.eraseDown=_+"J";v.eraseUp=_+"1J";v.eraseScreen=_+"2J";v.scrollUp=_+"S";v.scrollDown=_+"T";v.clearScreen="\x1Bc";v.clearTerminal=process.platform==="win32"?`${v.eraseScreen}${_}0f`:<span class="branch-1 cbranch-no" title="branch not covered" >`${v.eraseScreen}${_}3J${_}H`;</span>v.beep=mt;v.link=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >[Ht,"8",Jr,Jr,t,mt,e,Ht,"8",Jr,Jr,mt].join("");</span>v.image=<span class="fstat-no" title="function not covered" >(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{let r=<span class="cstat-no" title="statement not covered" >`${Ht}1337;File=inline=1`;<span class="cstat-no" title="statement not covered" ></span>return t.width&amp;&amp;(r+=`;width=${t.width}`),t.height&amp;&amp;(r+=`;height=${t.height}`),t.preserveAspectRatio===!1&amp;&amp;(r+=";preserveAspectRatio=0"),r+":"+e.toString("base64")+mt}</span>;v.iTerm={setCwd:<span class="fstat-no" title="function not covered" >(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >process.cwd())</span>=&gt;<span class="cstat-no" title="statement not covered" >`${Ht}50;CurrentDir=${e}${mt}`,</span>annotation:<span class="fstat-no" title="function not covered" >(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{let r=<span class="cstat-no" title="statement not covered" >`${Ht}1337;`,</span>n=<span class="cstat-no" title="statement not covered" >typeof t.x&lt;"u",</span>i=<span class="cstat-no" title="statement not covered" >typeof t.y&lt;"u";<span class="cstat-no" title="statement not covered" ></span>if((n||i)&amp;&amp;!(n&amp;&amp;i&amp;&amp;typeof t.length&lt;"u"))<span class="cstat-no" title="statement not covered" >throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");<span class="cstat-no" title="statement not covered" >r</span></span>eturn e=e.replace(/\|/g,""),r+=t.isHidden?"AddHiddenAnnotation=":"AddAnnotation=",t.length&gt;0?r+=(n?[e,t.length,t.x,t.y]:[t.length,e]).join("|"):r+=e,r+mt}</span>}});var ri=Z((Ef,Go)=&gt;{"use strict";Go.exports=(e,t=process.argv)=&gt;{let r=e.startsWith("-")?<span class="branch-0 cbranch-no" title="branch not covered" >"":</span>e.length===1?<span class="branch-0 cbranch-no" title="branch not covered" >"-":</span>"--",n=t.indexOf(r+e),i=t.indexOf("--");return n!==-1&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >i===-1|</span>|<span class="branch-2 cbranch-no" title="branch not covered" >n&lt;i)</span>}});var Wo=Z((bf,Ho)=&gt;{"use strict";var Ju=require("os"),Jo=require("tty"),fe=ri(),{env:J}=process,Je;fe("no-color")||fe("no-colors")||fe("color=false")||fe("color=never")?<span class="branch-0 cbranch-no" title="branch not covered" >Je=0:</span>(fe("color")||fe("colors")||fe("color=true")||fe("color=always"))&amp;&amp;(<span class="branch-4 cbranch-no" title="branch not covered" >Je=1)</span>;"FORCE_COLOR"in J&amp;&amp;(J.FORCE_COLOR==="true"?<span class="branch-0 cbranch-no" title="branch not covered" >Je=1:</span>J.FORCE_COLOR==="false"?<span class="branch-0 cbranch-no" title="branch not covered" >Je=0:</span>Je=J.FORCE_COLOR.length===0?<span class="branch-0 cbranch-no" title="branch not covered" >1:</span>Math.min(parseInt(J.FORCE_COLOR,10),3));function ni(e){return e===0?<span class="branch-0 cbranch-no" title="branch not covered" >!1:</span>{level:e,hasBasic:!0,has256:e&gt;=2,has16m:e&gt;=3}}function ii(e,t){<span class="missing-if-branch" title="if path not taken" >I</span>if(Je===0)<span class="cstat-no" title="statement not covered" >return 0;<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(fe("color=16m")||fe("color=full")||fe("color=truecolor"))<span class="cstat-no" title="statement not covered" >return 3;<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(fe("color=256"))<span class="cstat-no" title="statement not covered" >return 2;<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(e&amp;&amp;!t&amp;&amp;Je===void 0)<span class="cstat-no" title="statement not covered" >return 0;l</span>et r=Je||<span class="branch-1 cbranch-no" title="branch not covered" >0;<span class="missing-if-branch" title="if path not taken" >I</span></span>if(J.TERM==="dumb")<span class="cstat-no" title="statement not covered" >return r;<span class="missing-if-branch" title="else path not taken" >E</span>i</span>f(process.platform==="win32"){let n=Ju.release().split(".");return Number(n[0])&gt;=10&amp;&amp;Number(n[2])&gt;=10586?Number(n[2])&gt;=14931?3:<span class="branch-1 cbranch-no" title="branch not covered" >2:<span class="branch-1 cbranch-no" title="branch not covered" ></span>1}<span class="cstat-no" title="statement not covered" ></span>if("CI"in J)<span class="cstat-no" title="statement not covered" >return["TRAVIS","CIRCLECI","APPVEYOR","GITLAB_CI","GITHUB_ACTIONS","BUILDKITE"].some(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >n in J)</span>||J.CI_NAME==="codeship"?1:r;<span class="cstat-no" title="statement not covered" >i</span></span>f("TEAMCITY_VERSION"in J)<span class="cstat-no" title="statement not covered" >return/^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(J.TEAMCITY_VERSION)?1:0;<span class="cstat-no" title="statement not covered" >i</span></span>f(J.COLORTERM==="truecolor")<span class="cstat-no" title="statement not covered" >return 3;<span class="cstat-no" title="statement not covered" >i</span></span>f("TERM_PROGRAM"in J){let n=<span class="cstat-no" title="statement not covered" >parseInt((J.TERM_PROGRAM_VERSION||"").split(".")[0],10);<span class="cstat-no" title="statement not covered" ></span>switch(J.TERM_PROGRAM){case"iTerm.app":<span class="cstat-no" title="statement not covered" >return n&gt;=3?3:2;c</span>ase"Apple_Terminal":<span class="cstat-no" title="statement not covered" >return 2}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn/-256(color)?$/i.test(J.TERM)?2:/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(J.TERM)||"COLORTERM"in J?1:r}</span>function Hu(e){let t=ii(e,e&amp;&amp;e.isTTY);return ni(t)}Ho.exports={supportsColor:Hu,stdout:ni(ii(!0,Jo.isatty(1))),stderr:ni(ii(!0,Jo.isatty(2)))}});var zo=Z((wf,Yo)=&gt;{"use strict";var Wu=Wo(),ft=ri();function <span class="fstat-no" title="function not covered" >Ko(</span>e){<span class="cstat-no" title="statement not covered" >if(/^\d{3,4}$/.test(e)){let r=<span class="cstat-no" title="statement not covered" >/(\d{1,2})(\d{2})/.exec(e);<span class="cstat-no" title="statement not covered" ></span>return{major:0,minor:parseInt(r[1],10),patch:parseInt(r[2],10)}}</span>l</span>et t=<span class="cstat-no" title="statement not covered" >(e||"").split(".").map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >parseInt(r,10))</span>;<span class="cstat-no" title="statement not covered" ></span>return{major:t[0],minor:t[1],patch:t[2]}}</span>function oi(e){let{env:t}=process;<span class="missing-if-branch" title="if path not taken" >I</span>if("FORCE_HYPERLINK"in t)<span class="cstat-no" title="statement not covered" >return!(t.FORCE_HYPERLINK.length&gt;0&amp;&amp;parseInt(t.FORCE_HYPERLINK,10)===0);<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(ft("no-hyperlink")||ft("no-hyperlinks")||ft("hyperlink=false")||ft("hyperlink=never"))<span class="cstat-no" title="statement not covered" >return!1;<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(ft("hyperlink=true")||ft("hyperlink=always")||"NETLIFY"in t)<span class="cstat-no" title="statement not covered" >return!0;<span class="missing-if-branch" title="else path not taken" >E</span>i</span>f(!Wu.supportsColor(e)||e&amp;&amp;!e.isTTY||<span class="branch-3 cbranch-no" title="branch not covered" >process.platform==="win32"|</span>|<span class="branch-4 cbranch-no" title="branch not covered" >"CI"in t|</span>|<span class="branch-5 cbranch-no" title="branch not covered" >"TEAMCITY_VERSION"in t)</span>return!1;<span class="cstat-no" title="statement not covered" >if("TERM_PROGRAM"in t){let r=<span class="cstat-no" title="statement not covered" >Ko(t.TERM_PROGRAM_VERSION);<span class="cstat-no" title="statement not covered" ></span>switch(t.TERM_PROGRAM){case"iTerm.app":<span class="cstat-no" title="statement not covered" >return r.major===3?r.minor&gt;=1:r.major&gt;3;c</span>ase"WezTerm":<span class="cstat-no" title="statement not covered" >return r.major&gt;=20200620;c</span>ase"vscode":<span class="cstat-no" title="statement not covered" >return r.major&gt;1||r.major===1&amp;&amp;r.minor&gt;=72}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f("VTE_VERSION"in t){<span class="cstat-no" title="statement not covered" >if(t.VTE_VERSION==="0.50.0")<span class="cstat-no" title="statement not covered" >return!1;l</span></span>et r=<span class="cstat-no" title="statement not covered" >Ko(t.VTE_VERSION);<span class="cstat-no" title="statement not covered" ></span>return r.major&gt;0||r.minor&gt;=50}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!1}</span>Yo.exports={supportsHyperlink:oi,stdout:oi(process.stdout),stderr:oi(process.stderr)}});var Xo=Z((xf,Wt)=&gt;{"use strict";var Ku=Qo(),si=zo(),Zo=<span class="fstat-no" title="function not covered" >(e</span>,t,{target:r=<span class="branch-0 cbranch-no" title="branch not covered" >"stdout",</span>...n}=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;<span class="cstat-no" title="statement not covered" >si[r]?Ku.link(e,t):n.fallback===!1?e:typeof n.fallback=="function"?n.fallback(e,t):`${e} (\u200B${t}\u200B)`;</span>Wt.exports=<span class="fstat-no" title="function not covered" >(e</span>,t,r=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;<span class="cstat-no" title="statement not covered" >Zo(e,t,r);</span>Wt.exports.stderr=<span class="fstat-no" title="function not covered" >(e</span>,t,r=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;<span class="cstat-no" title="statement not covered" >Zo(e,t,{target:"stderr",...r});</span>Wt.exports.isSupported=si.stdout;Wt.exports.stderr.isSupported=si.stderr});var li=Z((kf,Yu)=&gt;{Yu.exports={name:"@prisma/engines-version",version:"6.2.0-14.4123509d24aa4dede1e864b46351bf2790323b69",main:"index.js",types:"index.d.ts",license:"Apache-2.0",author:"Tim Suchanek &lt;suchanek@prisma.io&gt;",prisma:{enginesVersion:"4123509d24aa4dede1e864b46351bf2790323b69"},repository:{type:"git",url:"https://github.com/prisma/engines-wrapper.git",directory:"packages/engines-version"},devDependencies:{"@types/node":"18.19.68",typescript:"4.9.5"},files:["index.js","index.d.ts"],scripts:{build:"tsc -d"}}});var ui=Z(Hr=&gt;{"use strict";Object.defineProperty(Hr,"__esModule",{value:!0});Hr.enginesVersion=void 0;Hr.enginesVersion=li().prisma.enginesVersion});var ns=Z((Yf,Xu)=&gt;{Xu.exports={name:"dotenv",version:"16.4.7",description:"Loads environment variables from .env file",main:"lib/main.js",types:"lib/main.d.ts",exports:{".":{types:"./lib/main.d.ts",require:"./lib/main.js",default:"./lib/main.js"},"./config":"./config.js","./config.js":"./config.js","./lib/env-options":"./lib/env-options.js","./lib/env-options.js":"./lib/env-options.js","./lib/cli-options":"./lib/cli-options.js","./lib/cli-options.js":"./lib/cli-options.js","./package.json":"./package.json"},scripts:{"dts-check":"tsc --project tests/types/tsconfig.json",lint:"standard",pretest:"npm run lint &amp;&amp; npm run dts-check",test:"tap run --allow-empty-coverage --disable-coverage --timeout=60000","test:coverage":"tap run --show-full-coverage --timeout=60000 --coverage-report=lcov",prerelease:"npm test",release:"standard-version"},repository:{type:"git",url:"git://github.com/motdotla/dotenv.git"},funding:"https://dotenvx.com",keywords:["dotenv","env",".env","environment","variables","config","settings"],readmeFilename:"README.md",license:"BSD-2-Clause",devDependencies:{"@types/node":"^18.11.3",decache:"^4.6.2",sinon:"^14.0.1",standard:"^17.0.0","standard-version":"^9.5.0",tap:"^19.2.0",typescript:"^4.8.4"},engines:{node:"&gt;=12"},browser:{fs:!1}}});var as=Z((zf,Le)=&gt;{"use strict";var mi=require("fs"),fi=require("path"),ec=require("os"),tc=require("crypto"),rc=ns(),gi=rc.version,nc=/(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;function ic(e){let t={},r=e.toString();r=r.replace(/\r\n?/mg,`
`);let n;for(;(n=nc.exec(r))!=null;){let i=n[1],o=n[2]||<span class="branch-1 cbranch-no" title="branch not covered" >"";</span>o=o.trim();let s=o[0];o=o.replace(/^(['"`])([\s\S]*)\1$/mg,"$2"),s==='"'&amp;&amp;(o=o.replace(/\\n/g,`
`),o=o.replace(/\\r/g,"\r")),t[i]=o}return t}function <span class="fstat-no" title="function not covered" >oc(</span>e){let t=<span class="cstat-no" title="statement not covered" >ss(e),</span>r=<span class="cstat-no" title="statement not covered" >Q.configDotenv({path:t});<span class="cstat-no" title="statement not covered" ></span>if(!r.parsed){let s=<span class="cstat-no" title="statement not covered" >new Error(`MISSING_DATA: Cannot parse ${t} for an unknown reason`);<span class="cstat-no" title="statement not covered" ></span>throw s.code="MISSING_DATA",s}</span>l</span>et n=<span class="cstat-no" title="statement not covered" >os(e).split(","),</span>i=<span class="cstat-no" title="statement not covered" >n.length,</span>o;<span class="cstat-no" title="statement not covered" >for(let s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;i;s++)<span class="cstat-no" title="statement not covered" >try{let a=<span class="cstat-no" title="statement not covered" >n[s].trim(),</span>l=<span class="cstat-no" title="statement not covered" >lc(r,a);<span class="cstat-no" title="statement not covered" ></span>o=Q.decrypt(l.ciphertext,l.key);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>catch(a){<span class="cstat-no" title="statement not covered" >if(s+1&gt;=i)<span class="cstat-no" title="statement not covered" >throw a}<span class="cstat-no" title="statement not covered" ></span></span>r</span></span>eturn Q.parse(o)}</span>function <span class="fstat-no" title="function not covered" >sc(</span>e){<span class="cstat-no" title="statement not covered" >console.log(`[dotenv@${gi}][INFO] ${e}`)}</span>function <span class="fstat-no" title="function not covered" >ac(</span>e){<span class="cstat-no" title="statement not covered" >console.log(`[dotenv@${gi}][WARN] ${e}`)}</span>function <span class="fstat-no" title="function not covered" >Wr(</span>e){<span class="cstat-no" title="statement not covered" >console.log(`[dotenv@${gi}][DEBUG] ${e}`)}</span>function os(e){return e&amp;&amp;e.DOTENV_KEY&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >e.DOTENV_KEY.length&gt;0?<span class="branch-0 cbranch-no" title="branch not covered" ></span>e.DOTENV_KEY:</span>process.env.DOTENV_KEY&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >process.env.DOTENV_KEY.length&gt;0?<span class="branch-0 cbranch-no" title="branch not covered" ></span>process.env.DOTENV_KEY:</span>""}function <span class="fstat-no" title="function not covered" >lc(</span>e,t){let r;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >r=new URL(t)}</span>catch(a){<span class="cstat-no" title="statement not covered" >if(a.code==="ERR_INVALID_URL"){let l=<span class="cstat-no" title="statement not covered" >new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");<span class="cstat-no" title="statement not covered" ></span>throw l.code="INVALID_DOTENV_KEY",l}<span class="cstat-no" title="statement not covered" ></span>t</span>hrow a}</span>l</span>et n=<span class="cstat-no" title="statement not covered" >r.password;<span class="cstat-no" title="statement not covered" ></span>if(!n){let a=<span class="cstat-no" title="statement not covered" >new Error("INVALID_DOTENV_KEY: Missing key part");<span class="cstat-no" title="statement not covered" ></span>throw a.code="INVALID_DOTENV_KEY",a}</span>l</span>et i=<span class="cstat-no" title="statement not covered" >r.searchParams.get("environment");<span class="cstat-no" title="statement not covered" ></span>if(!i){let a=<span class="cstat-no" title="statement not covered" >new Error("INVALID_DOTENV_KEY: Missing environment part");<span class="cstat-no" title="statement not covered" ></span>throw a.code="INVALID_DOTENV_KEY",a}</span>l</span>et o=<span class="cstat-no" title="statement not covered" >`DOTENV_VAULT_${i.toUpperCase()}`,</span>s=<span class="cstat-no" title="statement not covered" >e.parsed[o];<span class="cstat-no" title="statement not covered" ></span>if(!s){let a=<span class="cstat-no" title="statement not covered" >new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${o} in your .env.vault file.`);<span class="cstat-no" title="statement not covered" ></span>throw a.code="NOT_FOUND_DOTENV_ENVIRONMENT",a}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{ciphertext:s,key:n}}</span>function <span class="fstat-no" title="function not covered" >ss(</span>e){let t=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(e&amp;&amp;e.path&amp;&amp;e.path.length&gt;0)<span class="cstat-no" title="statement not covered" >if(Array.isArray(e.path))<span class="cstat-no" title="statement not covered" >for(let r of e.path)<span class="cstat-no" title="statement not covered" >mi.existsSync(r)&amp;&amp;(t=r.endsWith(".vault")?r:`${r}.vault`);e</span></span>lse <span class="cstat-no" title="statement not covered" >t=e.path.endsWith(".vault")?e.path:`${e.path}.vault`;e</span></span>lse <span class="cstat-no" title="statement not covered" >t=fi.resolve(process.cwd(),".env.vault");<span class="cstat-no" title="statement not covered" >r</span></span>eturn mi.existsSync(t)?t:null}</span>function is(e){return e[0]==="~"?<span class="branch-0 cbranch-no" title="branch not covered" >fi.join(ec.homedir(),e.slice(1)):</span>e}function <span class="fstat-no" title="function not covered" >uc(</span>e){<span class="cstat-no" title="statement not covered" >sc("Loading env from encrypted .env.vault");l</span>et t=<span class="cstat-no" title="statement not covered" >Q._parseVault(e),</span>r=<span class="cstat-no" title="statement not covered" >process.env;<span class="cstat-no" title="statement not covered" ></span>return e&amp;&amp;e.processEnv!=null&amp;&amp;(r=e.processEnv),Q.populate(r,t,e),{parsed:t}}</span>function cc(e){let t=fi.resolve(process.cwd(),".env"),r="utf8",n=!!(e&amp;&amp;e.debug);e&amp;&amp;e.encoding?<span class="branch-0 cbranch-no" title="branch not covered" >r=e.encoding:</span>n&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >Wr("No encoding is specified. UTF-8 is used by default");</span>let i=[t];<span class="missing-if-branch" title="else path not taken" >E</span>if(e&amp;&amp;e.path)if(!Array.isArray(e.path))i=[is(e.path)];else<span class="missing-if-branch" title="else path not taken" >E</span>{<span class="cstat-no" title="statement not covered" >i=[];<span class="cstat-no" title="statement not covered" >f</span>or(let l of e.path)<span class="cstat-no" title="statement not covered" >i.push(is(l))}</span></span>let o,s={};for(let l of i)try{let u=Q.parse(mi.readFileSync(l,{encoding:r}));Q.populate(s,u,e)}catch(u){<span class="cstat-no" title="statement not covered" >n&amp;&amp;Wr(`Failed to load ${l} ${u.message}`),o=u}</span>let a=process.env;return e&amp;&amp;e.processEnv!=null&amp;&amp;(<span class="branch-2 cbranch-no" title="branch not covered" >a=e.processEnv)</span>,Q.populate(a,s,e),o?<span class="branch-0 cbranch-no" title="branch not covered" >{parsed:s,error:o}:</span>{parsed:s}}function pc(e){<span class="missing-if-branch" title="else path not taken" >E</span>if(os(e).length===0)return Q.configDotenv(e);let t=<span class="cstat-no" title="statement not covered" >ss(e);<span class="cstat-no" title="statement not covered" ></span>return t?Q._configVault(e):(ac(`You set DOTENV_KEY but you are missing a .env.vault file at ${t}. Did you forget to build it?`),Q.configDotenv(e))}</span>function <span class="fstat-no" title="function not covered" >dc(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >Buffer.from(t.slice(-64),"hex"),</span>n=<span class="cstat-no" title="statement not covered" >Buffer.from(e,"base64"),</span>i=<span class="cstat-no" title="statement not covered" >n.subarray(0,12),</span>o=<span class="cstat-no" title="statement not covered" >n.subarray(-16);<span class="cstat-no" title="statement not covered" ></span>n=n.subarray(12,-16);<span class="cstat-no" title="statement not covered" >t</span>ry{let s=<span class="cstat-no" title="statement not covered" >tc.createDecipheriv("aes-256-gcm",r,i);<span class="cstat-no" title="statement not covered" ></span>return s.setAuthTag(o),`${s.update(n)}${s.final()}`}</span>catch(s){let a=<span class="cstat-no" title="statement not covered" >s instanceof RangeError,</span>l=<span class="cstat-no" title="statement not covered" >s.message==="Invalid key length",</span>u=<span class="cstat-no" title="statement not covered" >s.message==="Unsupported state or unable to authenticate data";<span class="cstat-no" title="statement not covered" ></span>if(a||l){let c=<span class="cstat-no" title="statement not covered" >new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");<span class="cstat-no" title="statement not covered" ></span>throw c.code="INVALID_DOTENV_KEY",c}</span>else <span class="cstat-no" title="statement not covered" >if(u){let c=<span class="cstat-no" title="statement not covered" >new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");<span class="cstat-no" title="statement not covered" ></span>throw c.code="DECRYPTION_FAILED",c}</span>else <span class="cstat-no" title="statement not covered" >throw s}</span></span></span>}</span>function mc(e,t,r=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{let n=!!(r&amp;&amp;r.debug),i=!!(r&amp;&amp;r.override);<span class="missing-if-branch" title="if path not taken" >I</span>if(typeof t!="object"){let o=<span class="cstat-no" title="statement not covered" >new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");<span class="cstat-no" title="statement not covered" ></span>throw o.code="OBJECT_REQUIRED",o}</span>for(let o of Object.keys(t))Object.prototype.hasOwnProperty.call(e,o)?(i===!0&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >e[o]=t[o])</span>,n&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >Wr(i===!0?`"${o}" is already defined and WAS overwritten`:`"${o}" is already defined and was NOT overwritten`))</span>:e[o]=t[o]}var Q={configDotenv:cc,_configVault:uc,_parseVault:oc,config:pc,decrypt:dc,parse:ic,populate:mc};Le.exports.configDotenv=Q.configDotenv;Le.exports._configVault=Q._configVault;Le.exports._parseVault=Q._parseVault;Le.exports.config=Q.config;Le.exports.decrypt=Q.decrypt;Le.exports.parse=Q.parse;Le.exports.populate=Q.populate;Le.exports=Q});var ms=Z((ig,ds)=&gt;{"use strict";ds.exports=<span class="fstat-no" title="function not covered" >e=</span>&gt;{let t=<span class="cstat-no" title="statement not covered" >e.match(/^[ \t]*(?=\S)/gm);<span class="cstat-no" title="statement not covered" ></span>return t?t.reduce(<span class="fstat-no" title="function not covered" >(r</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >Math.min(r,n.length),</span>1/0):0}</span>});var gs=Z((og,fs)=&gt;{"use strict";var yc=ms();fs.exports=<span class="fstat-no" title="function not covered" >e=</span>&gt;{let t=<span class="cstat-no" title="statement not covered" >yc(e);<span class="cstat-no" title="statement not covered" ></span>if(t===0)<span class="cstat-no" title="statement not covered" >return e;l</span></span>et r=<span class="cstat-no" title="statement not covered" >new RegExp(`^[ \\t]{${t}}`,"gm");<span class="cstat-no" title="statement not covered" ></span>return e.replace(r,"")}</span>});var bi=Z((pg,hs)=&gt;{"use strict";hs.exports=<span class="fstat-no" title="function not covered" >(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>r)=&gt;{<span class="cstat-no" title="statement not covered" >if(r={indent:" ",includeEmptyLines:!1,...r},typeof e!="string")<span class="cstat-no" title="statement not covered" >throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e}\``);<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof t!="number")<span class="cstat-no" title="statement not covered" >throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof t}\``);<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof r.indent!="string")<span class="cstat-no" title="statement not covered" >throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof r.indent}\``);<span class="cstat-no" title="statement not covered" >i</span></span>f(t===0)<span class="cstat-no" title="statement not covered" >return e;l</span></span>et n=<span class="cstat-no" title="statement not covered" >r.includeEmptyLines?/^/gm:/^(?!\s*$)/gm;<span class="cstat-no" title="statement not covered" ></span>return e.replace(n,r.indent.repeat(t))}</span>});var ws=Z((fg,bs)=&gt;{"use strict";bs.exports=<span class="fstat-no" title="function not covered" >({</span>onlyFirst:e=<span class="branch-0 cbranch-no" title="branch not covered" >!1}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{let t=<span class="cstat-no" title="statement not covered" >["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&amp;.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&amp;.:=?%@~_]*)*)?\\u0007)","(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=&gt;&lt;~]))"].join("|");<span class="cstat-no" title="statement not covered" ></span>return new RegExp(t,e?void 0:"g")}</span>});var Pi=Z((gg,xs)=&gt;{"use strict";var Rc=ws();xs.exports=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >typeof e=="string"?e.replace(Rc(),""):e}</span>);var vs=Z((Eg,zr)=&gt;{"use strict";zr.exports=<span class="fstat-no" title="function not covered" >(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{let t;<span class="cstat-no" title="statement not covered" >if(e.repoUrl)<span class="cstat-no" title="statement not covered" >t=e.repoUrl;e</span>lse <span class="cstat-no" title="statement not covered" >if(e.user&amp;&amp;e.repo)<span class="cstat-no" title="statement not covered" >t=`https://github.com/${e.user}/${e.repo}`;e</span>lse <span class="cstat-no" title="statement not covered" >throw new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");l</span></span></span>et r=<span class="cstat-no" title="statement not covered" >new URL(`${t}/issues/new`),</span>n=<span class="cstat-no" title="statement not covered" >["body","title","labels","template","milestone","assignee","projects"];<span class="cstat-no" title="statement not covered" ></span>for(let i of n){let o=<span class="cstat-no" title="statement not covered" >e[i];<span class="cstat-no" title="statement not covered" ></span>if(o!==void 0){<span class="cstat-no" title="statement not covered" >if(i==="labels"||i==="projects"){<span class="cstat-no" title="statement not covered" >if(!Array.isArray(o))<span class="cstat-no" title="statement not covered" >throw new TypeError(`The \`${i}\` option should be an array`);<span class="cstat-no" title="statement not covered" >o</span></span>=o.join(",")}<span class="cstat-no" title="statement not covered" ></span>r</span>.searchParams.set(i,o)}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r.toString()}</span>;zr.exports.default=zr.exports});var _i=Z((Sh,Qs)=&gt;{"use strict";Qs.exports=function(){function <span class="fstat-no" title="function not covered" >e(</span>t,r,n,i,o){<span class="cstat-no" title="statement not covered" >return t&lt;r||n&lt;r?t&gt;n?n+1:t+1:i===o?r:r+1}</span>return <span class="fstat-no" title="function not covered" >fu</span>nction(t,r){<span class="cstat-no" title="statement not covered" >if(t===r)<span class="cstat-no" title="statement not covered" >return 0;<span class="cstat-no" title="statement not covered" >i</span></span>f(t.length&gt;r.length){var n=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>t=r,r=n}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var i=<span class="cstat-no" title="statement not covered" >t.length,</span>o=<span class="cstat-no" title="statement not covered" >r.length;</span>i&gt;0&amp;&amp;t.charCodeAt(i-1)===r.charCodeAt(o-1);)<span class="cstat-no" title="statement not covered" >i--,o--;<span class="cstat-no" title="statement not covered" >f</span></span>or(var s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;i&amp;&amp;t.charCodeAt(s)===r.charCodeAt(s);)<span class="cstat-no" title="statement not covered" >s++;<span class="cstat-no" title="statement not covered" >i</span></span>f(i-=s,o-=s,i===0||o&lt;3)<span class="cstat-no" title="statement not covered" >return o;v</span></span>ar a=<span class="cstat-no" title="statement not covered" >0,</span>l,u,c,p,d,f,g,h,O,P,C,R,k=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(l=0;l&lt;i;l++)<span class="cstat-no" title="statement not covered" >k.push(l+1),k.push(t.charCodeAt(s+l));<span class="cstat-no" title="statement not covered" >f</span></span>or(var A=<span class="cstat-no" title="statement not covered" >k.length-1;</span>a&lt;o-3;)<span class="cstat-no" title="statement not covered" >for(O=r.charCodeAt(s+(u=a)),P=r.charCodeAt(s+(c=a+1)),C=r.charCodeAt(s+(p=a+2)),R=r.charCodeAt(s+(d=a+3)),f=a+=4,l=0;l&lt;A;l+=2)<span class="cstat-no" title="statement not covered" >g=k[l],h=k[l+1],u=e(g,u,c,O,h),c=e(u,c,p,P,h),p=e(c,p,d,C,h),f=e(p,d,f,R,h),k[l]=f,d=p,p=c,c=u,u=g;<span class="cstat-no" title="statement not covered" >f</span></span></span>or(;a&lt;o;)<span class="cstat-no" title="statement not covered" >for(O=r.charCodeAt(s+(u=a)),f=++a,l=0;l&lt;A;l+=2)<span class="cstat-no" title="statement not covered" >g=k[l],k[l]=f=e(g,u,f,O,k[l+1]),u=g;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn f}</span>}()});var Bm={};Bt(Bm,{Debug:()=&gt;Jn,Decimal:()=&gt;ve,Extensions:()=&gt;Bn,MetricsClient:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Ot,</span>PrismaClientInitializationError:()=&gt;T,PrismaClientKnownRequestError:()=&gt;ee,PrismaClientRustPanicError:()=&gt;ce,PrismaClientUnknownRequestError:()=&gt;B,PrismaClientValidationError:()=&gt;te,Public:()=&gt;Un,Sql:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >ae,</span>defineDmmfProperty:()=&gt;ga,deserializeJsonResponse:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >bt,</span>deserializeRawResult:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >qn,</span>dmmfToRuntimeDataModel:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >fa,</span>empty:()=&gt;ba,getPrismaClient:()=&gt;Xl,getRuntime:()=&gt;In,join:()=&gt;Ea,makeStrictEnum:()=&gt;eu,makeTypedQueryFactory:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >ha,</span>objectEnumValues:()=&gt;yn,raw:()=&gt;Gi,serializeJsonQuery:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Pn,</span>skip:()=&gt;vn,sqltag:()=&gt;Ji,warnEnvConflicts:()=&gt;tu,warnOnce:()=&gt;tr});module.exports=au(Bm);var Bn={};Bt(Bn,{defineExtension:()=&gt;xo,getExtensionContext:()=&gt;vo});function <span class="fstat-no" title="function not covered" >xo(</span>e){<span class="cstat-no" title="statement not covered" >return typeof e=="function"?e:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.$extends(e)}</span></span>function <span class="fstat-no" title="function not covered" >vo(</span>e){<span class="cstat-no" title="statement not covered" >return e}</span>var Un={};Bt(Un,{validator:()=&gt;Po});function <span class="fstat-no" title="function not covered" >Po(</span>...e){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t}</span></span>var Mr={};Bt(Mr,{$:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Ao,</span>bgBlack:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >yu,</span>bgBlue:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >xu,</span>bgCyan:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Pu,</span>bgGreen:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >bu,</span>bgMagenta:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >vu,</span>bgRed:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Eu,</span>bgWhite:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Tu,</span>bgYellow:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >wu,</span>black:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >mu,</span>blue:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >rt,</span>bold:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >W,</span>cyan:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >_e,</span>dim:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >ke,</span>gray:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Ut,</span>green:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Ve,</span>grey:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >hu,</span>hidden:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >pu,</span>inverse:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >cu,</span>italic:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >uu,</span>magenta:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >fu,</span>red:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >de,</span>reset:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >lu,</span>strikethrough:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >du,</span>underline:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >X,</span>white:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >gu,</span>yellow:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >De}</span>);var Qn,To,Ro,Co,So=!0;typeof process&lt;"u"&amp;&amp;({FORCE_COLOR:Qn,NODE_DISABLE_COLORS:To,NO_COLOR:Ro,TERM:Co}=process.env||<span class="branch-1 cbranch-no" title="branch not covered" >{},</span>So=process.stdout&amp;&amp;process.stdout.isTTY);var Ao={enabled:!To&amp;&amp;Ro==null&amp;&amp;Co!=="dumb"&amp;&amp;(Qn!=null&amp;&amp;Qn!=="0"||<span class="branch-5 cbranch-no" title="branch not covered" >So)</span>};function $(e,t){let r=new RegExp(`\\x1b\\[${t}m`,"g"),n=`\x1B[${e}m`,i=`\x1B[${t}m`;return function(o){return!Ao.enabled||o==null?<span class="branch-0 cbranch-no" title="branch not covered" >o:</span>n+(~(""+o).indexOf(i)?<span class="branch-0 cbranch-no" title="branch not covered" >o.replace(r,i+n):</span>o)+i}}var lu=$(0,0),W=$(1,22),ke=$(2,22),uu=$(3,23),X=$(4,24),cu=$(7,27),pu=$(8,28),du=$(9,29),mu=$(30,39),de=$(31,39),Ve=$(32,39),De=$(33,39),rt=$(34,39),fu=$(35,39),_e=$(36,39),gu=$(37,39),Ut=$(90,39),hu=$(90,39),yu=$(40,49),Eu=$(41,49),bu=$(42,49),wu=$(43,49),xu=$(44,49),vu=$(45,49),Pu=$(46,49),Tu=$(47,49);var Ru=100,Io=["green","yellow","blue","magenta","cyan","red"],Qt=[],Oo=Date.now(),Cu=0,Gn=typeof process&lt;"u"?process.env:<span class="branch-1 cbranch-no" title="branch not covered" >{};</span>globalThis.DEBUG??=Gn.DEBUG??"";globalThis.DEBUG_COLORS??=Gn.DEBUG_COLORS?Gn.DEBUG_COLORS==="true":!0;var Gt={<span class="fstat-no" title="function not covered" >en</span>able(e){<span class="cstat-no" title="statement not covered" >typeof e=="string"&amp;&amp;(globalThis.DEBUG=e)}</span>,<span class="fstat-no" title="function not covered" >di</span>sable(){let e=<span class="cstat-no" title="statement not covered" >globalThis.DEBUG;<span class="cstat-no" title="statement not covered" ></span>return globalThis.DEBUG="",e}</span>,enabled(e){let t=globalThis.DEBUG.split(",").map(i=&gt;i.replace(/[.+?^${}()|[\]\\]/g,"\\$&amp;")),r=t.some(i=&gt;i===""||<span class="branch-1 cbranch-no" title="branch not covered" >i[0]==="-"?</span>!1:<span class="branch-1 cbranch-no" title="branch not covered" >e.match(RegExp(i.split("*").join(".*")+"$")))</span>,n=t.some(i=&gt;i===""||<span class="branch-1 cbranch-no" title="branch not covered" >i[0]!=="-"?</span>!1:<span class="branch-1 cbranch-no" title="branch not covered" >e.match(RegExp(i.slice(1).split("*").join(".*")+"$")))</span>;return r&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >!n}</span>,log:<span class="fstat-no" title="function not covered" >(.</span>..e)=&gt;{let[t,r,...n]=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>(console.warn??console.log)(`${t} ${r}`,...n)}</span>,formatters:{}};function Su(e){let t={color:Io[Cu++%Io.length],enabled:Gt.enabled(e),namespace:e,log:Gt.log,extend:<span class="fstat-no" title="function not covered" >()</span>=&gt;{}},r=(...n)=&gt;{let{enabled:i,namespace:o,color:s,log:a}=t;<span class="missing-if-branch" title="if path not taken" >I</span>if(n.length!==0&amp;&amp;Qt.push([o,...n]),Qt.length&gt;Ru&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >Qt.shift(),</span>Gt.enabled(o)||i){let l=<span class="cstat-no" title="statement not covered" >n.map(<span class="fstat-no" title="function not covered" >c=</span>&gt;<span class="cstat-no" title="statement not covered" >typeof c=="string"?c:Au(c))</span>,</span>u=<span class="cstat-no" title="statement not covered" >`+${Date.now()-Oo}ms`;<span class="cstat-no" title="statement not covered" ></span>Oo=Date.now(),globalThis.DEBUG_COLORS?a(Mr[s](W(o)),...l,Mr[s](u)):a(o,...l,u)}</span>};return new Proxy(r,{get:<span class="fstat-no" title="function not covered" >(n</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >t[i],</span>set:<span class="fstat-no" title="function not covered" >(n</span>,i,o)=&gt;<span class="cstat-no" title="statement not covered" >t[i]=o}</span>)}var Jn=new Proxy(Su,{get:(e,t)=&gt;Gt[t],set:<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;<span class="cstat-no" title="statement not covered" >Gt[t]=r}</span>);function <span class="fstat-no" title="function not covered" >Au(</span>e,t=<span class="branch-0 cbranch-no" title="branch not covered" >2)</span>{let r=<span class="cstat-no" title="statement not covered" >new Set;<span class="cstat-no" title="statement not covered" ></span>return JSON.stringify(e,<span class="fstat-no" title="function not covered" >(n</span>,i)=&gt;{<span class="cstat-no" title="statement not covered" >if(typeof i=="object"&amp;&amp;i!==null){<span class="cstat-no" title="statement not covered" >if(r.has(i))<span class="cstat-no" title="statement not covered" >return"[Circular *]";<span class="cstat-no" title="statement not covered" >r</span></span>.add(i)}</span>else <span class="cstat-no" title="statement not covered" >if(typeof i=="bigint")<span class="cstat-no" title="statement not covered" >return i.toString();<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn i}</span>,t)}</span>function <span class="fstat-no" title="function not covered" >ko(</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >7500)</span>{let t=<span class="cstat-no" title="statement not covered" >Qt.map(<span class="fstat-no" title="function not covered" >([</span>r,...n])=&gt;<span class="cstat-no" title="statement not covered" >`${r} ${n.map(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >typeof i=="string"?i:JSON.stringify(i))</span>.join(" ")}`)</span>.join(`</span>
`);<span class="cstat-no" title="statement not covered" >return t.length&lt;e?t:t.slice(-e)}</span>function Do(){Qt.length=0}var F=Jn;var _o=D(require("fs"));function Hn(){let e=process.env.PRISMA_QUERY_ENGINE_LIBRARY;<span class="missing-if-branch" title="if path not taken" >I</span>if(!(e&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >_o.default.existsSync(e))</span>&amp;&amp;process.arch==="ia32")<span class="cstat-no" title="statement not covered" >throw new Error('The default query engine type (Node-API, "library") is currently not supported for 32bit Node. Please set `engineType = "binary"` in the "generator" block of your "schema.prisma" file (or use the environment variables "PRISMA_CLIENT_ENGINE_TYPE=binary" and/or "PRISMA_CLI_QUERY_ENGINE_TYPE=binary".)')}</span>var Wn=["darwin","darwin-arm64","debian-openssl-1.0.x","debian-openssl-1.1.x","debian-openssl-3.0.x","rhel-openssl-1.0.x","rhel-openssl-1.1.x","rhel-openssl-3.0.x","linux-arm64-openssl-1.1.x","linux-arm64-openssl-1.0.x","linux-arm64-openssl-3.0.x","linux-arm-openssl-1.1.x","linux-arm-openssl-1.0.x","linux-arm-openssl-3.0.x","linux-musl","linux-musl-openssl-3.0.x","linux-musl-arm64-openssl-1.1.x","linux-musl-arm64-openssl-3.0.x","linux-nixos","linux-static-x64","linux-static-arm64","windows","freebsd11","freebsd12","freebsd13","freebsd14","freebsd15","openbsd","netbsd","arm"];var $r="libquery_engine";function qr(e,t){let r=t==="url";return e.includes("windows")?r?<span class="branch-0 cbranch-no" title="branch not covered" >"query_engine.dll.node":</span>`query_engine-${e}.dll.node`:<span class="branch-1 cbranch-no" title="branch not covered" >e.includes("darwin")?r?`${$r}.dylib.node`:`${$r}-${e}.dylib.node`:r?`${$r}.so.node`:`${$r}-${e}.so.node`}</span>var Mo=D(require("child_process")),Xn=D(require("fs/promises")),Qr=D(require("os"));var Ne=Symbol.for("@ts-pattern/matcher"),Iu=Symbol.for("@ts-pattern/isVariadic"),jr="@ts-pattern/anonymous-select-key",Kn=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >!!(e&amp;&amp;typeof e=="object"),</span>Vr=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e&amp;&amp;!!e[Ne],</span>we=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;{<span class="cstat-no" title="statement not covered" >if(Vr(e)){let n=<span class="cstat-no" title="statement not covered" >e[Ne](),</span>{matched:i,selections:o}=<span class="cstat-no" title="statement not covered" >n.match(t);<span class="cstat-no" title="statement not covered" ></span>return i&amp;&amp;o&amp;&amp;Object.keys(o).forEach(<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >r(s,o[s]))</span>,i}<span class="cstat-no" title="statement not covered" ></span>i</span>f(Kn(e)){<span class="cstat-no" title="statement not covered" >if(!Kn(t))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(Array.isArray(e)){<span class="cstat-no" title="statement not covered" >if(!Array.isArray(t))<span class="cstat-no" title="statement not covered" >return!1;l</span></span>et n=<span class="cstat-no" title="statement not covered" >[],</span>i=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let s of e.keys()){let a=<span class="cstat-no" title="statement not covered" >e[s];<span class="cstat-no" title="statement not covered" ></span>Vr(a)&amp;&amp;a[Iu]?o.push(a):o.length?i.push(a):n.push(a)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(o.length){<span class="cstat-no" title="statement not covered" >if(o.length&gt;1)<span class="cstat-no" title="statement not covered" >throw new Error("Pattern error: Using `...P.array(...)` several times in a single pattern is not allowed.");<span class="cstat-no" title="statement not covered" >i</span></span>f(t.length&lt;n.length+i.length)<span class="cstat-no" title="statement not covered" >return!1;l</span></span>et s=<span class="cstat-no" title="statement not covered" >t.slice(0,n.length),</span>a=<span class="cstat-no" title="statement not covered" >i.length===0?[]:t.slice(-i.length),</span>l=<span class="cstat-no" title="statement not covered" >t.slice(n.length,i.length===0?1/0:-i.length);<span class="cstat-no" title="statement not covered" ></span>return n.every(<span class="fstat-no" title="function not covered" >(u</span>,c)=&gt;<span class="cstat-no" title="statement not covered" >we(u,s[c],r))</span>&amp;&amp;i.every(<span class="fstat-no" title="function not covered" >(u</span>,c)=&gt;<span class="cstat-no" title="statement not covered" >we(u,a[c],r))</span>&amp;&amp;(o.length===0||we(o[0],l,r))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e.length===t.length&amp;&amp;e.every(<span class="fstat-no" title="function not covered" >(s</span>,a)=&gt;<span class="cstat-no" title="statement not covered" >we(s,t[a],r))</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn Reflect.ownKeys(e).every(<span class="fstat-no" title="function not covered" >n=</span>&gt;{let i=<span class="cstat-no" title="statement not covered" >e[n];<span class="cstat-no" title="statement not covered" ></span>return(n in t||Vr(o=i)&amp;&amp;o[Ne]().matcherType==="optional")&amp;&amp;we(i,t[n],r);v</span>ar o})}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn Object.is(t,e)}</span>,Ge=<span class="fstat-no" title="function not covered" >e=</span>&gt;{var t,r,n;<span class="cstat-no" title="statement not covered" >return Kn(e)?Vr(e)?(t=(r=(n=e[Ne]()).getSelectionKeys)==null?void 0:r.call(n))!=null?t:[]:Array.isArray(e)?Jt(e,Ge):Jt(Object.values(e),Ge):[]}</span>,Jt=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >e.reduce(<span class="fstat-no" title="function not covered" >(r</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >r.concat(t(n)),</span>[]);</span>function me(e){return Object.assign(e,{optional:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Ou(e),</span>and:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >j(e,t),</span>or:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >ku(e,t),</span>select:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t===void 0?No(e):No(t,e)}</span>)}function <span class="fstat-no" title="function not covered" >Ou(</span>e){<span class="cstat-no" title="statement not covered" >return me({[Ne]:<span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >{match:<span class="fstat-no" title="function not covered" >t=</span>&gt;{let r=<span class="cstat-no" title="statement not covered" >{},</span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(i</span>,o)=&gt;{<span class="cstat-no" title="statement not covered" >r[i]=o}</span>;<span class="cstat-no" title="statement not covered" ></span>return t===void 0?(Ge(e).forEach(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >n(i,void 0))</span>,{matched:!0,selections:r}):{matched:we(e,t,n),selections:r}}</span>,getSelectionKeys:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Ge(e),</span>matcherType:"optional"})</span>})}</span>function <span class="fstat-no" title="function not covered" >j(</span>...e){<span class="cstat-no" title="statement not covered" >return me({[Ne]:<span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >{match:<span class="fstat-no" title="function not covered" >t=</span>&gt;{let r=<span class="cstat-no" title="statement not covered" >{},</span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(i</span>,o)=&gt;{<span class="cstat-no" title="statement not covered" >r[i]=o}</span>;<span class="cstat-no" title="statement not covered" ></span>return{matched:e.every(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >we(i,t,n))</span>,selections:r}}</span>,getSelectionKeys:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Jt(e,Ge),</span>matcherType:"and"})</span>})}</span>function <span class="fstat-no" title="function not covered" >ku(</span>...e){<span class="cstat-no" title="statement not covered" >return me({[Ne]:<span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >{match:<span class="fstat-no" title="function not covered" >t=</span>&gt;{let r=<span class="cstat-no" title="statement not covered" >{},</span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(i</span>,o)=&gt;{<span class="cstat-no" title="statement not covered" >r[i]=o}</span>;<span class="cstat-no" title="statement not covered" ></span>return Jt(e,Ge).forEach(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >n(i,void 0))</span>,{matched:e.some(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >we(i,t,n))</span>,selections:r}}</span>,getSelectionKeys:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Jt(e,Ge),</span>matcherType:"or"})</span>})}</span>function I(e){return{[Ne]:<span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >{match:<span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >{matched:!!e(t)})</span>})</span>}}function <span class="fstat-no" title="function not covered" >No(</span>...e){let t=<span class="cstat-no" title="statement not covered" >typeof e[0]=="string"?e[0]:void 0,</span>r=<span class="cstat-no" title="statement not covered" >e.length===2?e[1]:typeof e[0]=="string"?void 0:e[0];<span class="cstat-no" title="statement not covered" ></span>return me({[Ne]:<span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >{match:<span class="fstat-no" title="function not covered" >n=</span>&gt;{let i=<span class="cstat-no" title="statement not covered" >{[t??jr]:n};<span class="cstat-no" title="statement not covered" ></span>return{matched:r===void 0||we(r,n,<span class="fstat-no" title="function not covered" >(o</span>,s)=&gt;{<span class="cstat-no" title="statement not covered" >i[o]=s}</span>),selections:i}}</span>,getSelectionKeys:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >[t??jr].concat(r===void 0?[]:Ge(r))}</span>)</span>})}</span>function <span class="fstat-no" title="function not covered" >Ee(</span>e){<span class="cstat-no" title="statement not covered" >return typeof e=="number"}</span>function <span class="fstat-no" title="function not covered" >je(</span>e){<span class="cstat-no" title="statement not covered" >return typeof e=="string"}</span>function <span class="fstat-no" title="function not covered" >Be(</span>e){<span class="cstat-no" title="statement not covered" >return typeof e=="bigint"}</span>var tf=me(I(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return!0}</span>));var Ue=e=&gt;Object.assign(me(e),{startsWith:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >return Ue(j(e,(r=t,I(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >je(n)&amp;&amp;n.startsWith(r))</span>)));v</span>ar r},endsWith:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >return Ue(j(e,(r=t,I(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >je(n)&amp;&amp;n.endsWith(r))</span>)));v</span>ar r},minLength:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Ue(j(e,(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >I(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >je(n)&amp;&amp;n.length&gt;=r)</span>)</span>(t))),</span>length:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Ue(j(e,(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >I(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >je(n)&amp;&amp;n.length===r)</span>)</span>(t))),</span>maxLength:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Ue(j(e,(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >I(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >je(n)&amp;&amp;n.length&lt;=r)</span>)</span>(t))),</span>includes:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >return Ue(j(e,(r=t,I(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >je(n)&amp;&amp;n.includes(r))</span>)));v</span>ar r},regex:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >return Ue(j(e,(r=t,I(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >je(n)&amp;&amp;!!n.match(r))</span>)));v</span>ar r}}),rf=Ue(I(je)),be=e=&gt;Object.assign(me(e),{between:<span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >be(j(e,(<span class="fstat-no" title="function not covered" >(n</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >I(<span class="fstat-no" title="function not covered" >o=</span>&gt;<span class="cstat-no" title="statement not covered" >Ee(o)&amp;&amp;n&lt;=o&amp;&amp;i&gt;=o)</span>)</span>(t,r))),</span>lt:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >be(j(e,(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >I(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >Ee(n)&amp;&amp;n&lt;r)</span>)</span>(t))),</span>gt:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >be(j(e,(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >I(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >Ee(n)&amp;&amp;n&gt;r)</span>)</span>(t))),</span>lte:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >be(j(e,(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >I(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >Ee(n)&amp;&amp;n&lt;=r)</span>)</span>(t))),</span>gte:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >be(j(e,(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >I(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >Ee(n)&amp;&amp;n&gt;=r)</span>)</span>(t))),</span>int:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >be(j(e,I(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Ee(t)&amp;&amp;Number.isInteger(t))</span>)),</span>finite:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >be(j(e,I(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Ee(t)&amp;&amp;Number.isFinite(t))</span>)),</span>positive:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >be(j(e,I(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Ee(t)&amp;&amp;t&gt;0)</span>)),</span>negative:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >be(j(e,I(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Ee(t)&amp;&amp;t&lt;0)</span>))}</span>),nf=be(I(Ee)),Qe=e=&gt;Object.assign(me(e),{between:<span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >Qe(j(e,(<span class="fstat-no" title="function not covered" >(n</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >I(<span class="fstat-no" title="function not covered" >o=</span>&gt;<span class="cstat-no" title="statement not covered" >Be(o)&amp;&amp;n&lt;=o&amp;&amp;i&gt;=o)</span>)</span>(t,r))),</span>lt:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Qe(j(e,(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >I(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >Be(n)&amp;&amp;n&lt;r)</span>)</span>(t))),</span>gt:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Qe(j(e,(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >I(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >Be(n)&amp;&amp;n&gt;r)</span>)</span>(t))),</span>lte:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Qe(j(e,(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >I(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >Be(n)&amp;&amp;n&lt;=r)</span>)</span>(t))),</span>gte:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Qe(j(e,(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >I(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >Be(n)&amp;&amp;n&gt;=r)</span>)</span>(t))),</span>positive:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Qe(j(e,I(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Be(t)&amp;&amp;t&gt;0)</span>)),</span>negative:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Qe(j(e,I(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Be(t)&amp;&amp;t&lt;0)</span>))}</span>),of=Qe(I(Be)),sf=me(I(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return typeof e=="boolean"}</span>)),af=me(I(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return typeof e=="symbol"}</span>)),lf=me(I(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e==null}</span>)),uf=me(I(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e!=null}</span>));var Yn=class extends Error{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){let r;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >r=JSON.stringify(t)}</span>catch{<span class="cstat-no" title="statement not covered" >r=t}<span class="cstat-no" title="statement not covered" ></span>s</span>uper(`Pattern matching error: no pattern matches value ${r}`),this.input=void 0,this.input=t}</span>},zn={matched:!1,value:void 0};function <span class="fstat-no" title="function not covered" >dt(</span>e){<span class="cstat-no" title="statement not covered" >return new Zn(e,zn)}</span>var Zn=class e{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,r){<span class="cstat-no" title="statement not covered" >this.input=void 0,this.state=void 0,this.input=t,this.state=r}<span class="fstat-no" title="function not covered" ></span>wi</span>th(...t){<span class="cstat-no" title="statement not covered" >if(this.state.matched)<span class="cstat-no" title="statement not covered" >return this;l</span></span>et r=<span class="cstat-no" title="statement not covered" >t[t.length-1],</span>n=<span class="cstat-no" title="statement not covered" >[t[0]],</span>i;<span class="cstat-no" title="statement not covered" >t.length===3&amp;&amp;typeof t[1]=="function"?i=t[1]:t.length&gt;2&amp;&amp;n.push(...t.slice(1,t.length-1));l</span>et o=<span class="cstat-no" title="statement not covered" >!1,</span>s=<span class="cstat-no" title="statement not covered" >{},</span>a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(u</span>,c)=&gt;{<span class="cstat-no" title="statement not covered" >o=!0,s[u]=c}</span>,</span>l=<span class="cstat-no" title="statement not covered" >!n.some(<span class="fstat-no" title="function not covered" >u=</span>&gt;<span class="cstat-no" title="statement not covered" >we(u,this.input,a))</span>||i&amp;&amp;!i(this.input)?zn:{matched:!0,value:r(o?jr in s?s[jr]:s:this.input,this.input)};<span class="cstat-no" title="statement not covered" ></span>return new e(this.input,l)}<span class="fstat-no" title="function not covered" ></span>wh</span>en(t,r){<span class="cstat-no" title="statement not covered" >if(this.state.matched)<span class="cstat-no" title="statement not covered" >return this;l</span></span>et n=<span class="cstat-no" title="statement not covered" >!!t(this.input);<span class="cstat-no" title="statement not covered" ></span>return new e(this.input,n?{matched:!0,value:r(this.input,this.input)}:zn)}<span class="fstat-no" title="function not covered" ></span>ot</span>herwise(t){<span class="cstat-no" title="statement not covered" >return this.state.matched?this.state.value:t(this.input)}<span class="fstat-no" title="function not covered" ></span>ex</span>haustive(){<span class="cstat-no" title="statement not covered" >if(this.state.matched)<span class="cstat-no" title="statement not covered" >return this.state.value;<span class="cstat-no" title="statement not covered" >t</span></span>hrow new Yn(this.input)}<span class="fstat-no" title="function not covered" ></span>ru</span>n(){<span class="cstat-no" title="statement not covered" >return this.exhaustive()}<span class="fstat-no" title="function not covered" ></span>re</span>turnType(){<span class="cstat-no" title="statement not covered" >return this}</span>};var $o=require("util");var Du={warn:De("prisma:warn")},_u={warn:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >!process.env.PRISMA_DISABLE_WARNINGS}</span>;function <span class="fstat-no" title="function not covered" >Br(</span>e,...t){<span class="cstat-no" title="statement not covered" >_u.warn()&amp;&amp;console.warn(`${Du.warn} ${e}`,...t)}</span>var Nu=(0,$o.promisify)(Mo.default.exec),ne=F("prisma:get-platform"),Lu=["1.0.x","1.1.x","3.0.x"];async function qo(){let e=Qr.default.platform(),t=process.arch;<span class="missing-if-branch" title="if path not taken" >I</span>if(e==="freebsd"){let s=<span class="cstat-no" title="statement not covered" >await Gr("freebsd-version");<span class="cstat-no" title="statement not covered" ></span>if(s&amp;&amp;s.trim().length&gt;0){let l=<span class="cstat-no" title="statement not covered" >/^(\d+)\.?/.exec(s);<span class="cstat-no" title="statement not covered" ></span>if(l)<span class="cstat-no" title="statement not covered" >return{platform:"freebsd",targetDistro:`freebsd${l[1]}`,arch:t}}</span></span>}<span class="missing-if-branch" title="else path not taken" >E</span></span>if(e!=="linux")return{platform:e,arch:t};let r=<span class="cstat-no" title="statement not covered" >await Mu(),</span>n=<span class="cstat-no" title="statement not covered" >await Gu(),</span>i=<span class="cstat-no" title="statement not covered" >qu({arch:t,archFromUname:n,familyDistro:r.familyDistro}),</span>{libssl:o}=<span class="cstat-no" title="statement not covered" >await Vu(i);<span class="cstat-no" title="statement not covered" ></span>return{platform:"linux",libssl:o,arch:t,archFromUname:n,...r}}</span>function <span class="fstat-no" title="function not covered" >Fu(</span>e){let t=<span class="cstat-no" title="statement not covered" >/^ID="?([^"\n]*)"?$/im,</span>r=<span class="cstat-no" title="statement not covered" >/^ID_LIKE="?([^"\n]*)"?$/im,</span>n=<span class="cstat-no" title="statement not covered" >t.exec(e),</span>i=<span class="cstat-no" title="statement not covered" >n&amp;&amp;n[1]&amp;&amp;n[1].toLowerCase()||"",</span>o=<span class="cstat-no" title="statement not covered" >r.exec(e),</span>s=<span class="cstat-no" title="statement not covered" >o&amp;&amp;o[1]&amp;&amp;o[1].toLowerCase()||"",</span>a=<span class="cstat-no" title="statement not covered" >dt({id:i,idLike:s}).with({id:"alpine"},<span class="fstat-no" title="function not covered" >({</span>id:l})=&gt;(<span class="cstat-no" title="statement not covered" >{targetDistro:"musl",familyDistro:l,originalDistro:l})</span>).with({id:"raspbian"},<span class="fstat-no" title="function not covered" >({</span>id:l})=&gt;(<span class="cstat-no" title="statement not covered" >{targetDistro:"arm",familyDistro:"debian",originalDistro:l})</span>).with({id:"nixos"},<span class="fstat-no" title="function not covered" >({</span>id:l})=&gt;(<span class="cstat-no" title="statement not covered" >{targetDistro:"nixos",originalDistro:l,familyDistro:"nixos"})</span>).with({id:"debian"},{id:"ubuntu"},<span class="fstat-no" title="function not covered" >({</span>id:l})=&gt;(<span class="cstat-no" title="statement not covered" >{targetDistro:"debian",familyDistro:"debian",originalDistro:l})</span>).with({id:"rhel"},{id:"centos"},{id:"fedora"},<span class="fstat-no" title="function not covered" >({</span>id:l})=&gt;(<span class="cstat-no" title="statement not covered" >{targetDistro:"rhel",familyDistro:"rhel",originalDistro:l})</span>).when(<span class="fstat-no" title="function not covered" >({</span>idLike:l})=&gt;<span class="cstat-no" title="statement not covered" >l.includes("debian")||l.includes("ubuntu"),<span class="fstat-no" title="function not covered" ></span>({</span>id:l})=&gt;(<span class="cstat-no" title="statement not covered" >{targetDistro:"debian",familyDistro:"debian",originalDistro:l})</span>).when(<span class="fstat-no" title="function not covered" >({</span>idLike:l})=&gt;<span class="cstat-no" title="statement not covered" >i==="arch"||l.includes("arch"),<span class="fstat-no" title="function not covered" ></span>({</span>id:l})=&gt;(<span class="cstat-no" title="statement not covered" >{targetDistro:"debian",familyDistro:"arch",originalDistro:l})</span>).when(<span class="fstat-no" title="function not covered" >({</span>idLike:l})=&gt;<span class="cstat-no" title="statement not covered" >l.includes("centos")||l.includes("fedora")||l.includes("rhel")||l.includes("suse"),<span class="fstat-no" title="function not covered" ></span>({</span>id:l})=&gt;(<span class="cstat-no" title="statement not covered" >{targetDistro:"rhel",familyDistro:"rhel",originalDistro:l})</span>).otherwise(<span class="fstat-no" title="function not covered" >({</span>id:l})=&gt;(<span class="cstat-no" title="statement not covered" >{targetDistro:void 0,familyDistro:void 0,originalDistro:l})</span>);<span class="cstat-no" title="statement not covered" ></span>return ne(`Found distro info:</span>
${JSON.stringify(a,null,2)}`),a}async function <span class="fstat-no" title="function not covered" >Mu(</span>){let e=<span class="cstat-no" title="statement not covered" >"/etc/os-release";<span class="cstat-no" title="statement not covered" ></span>try{let t=<span class="cstat-no" title="statement not covered" >await Xn.default.readFile(e,{encoding:"utf-8"});<span class="cstat-no" title="statement not covered" ></span>return Fu(t)}</span>catch{<span class="cstat-no" title="statement not covered" >return{targetDistro:void 0,familyDistro:void 0,originalDistro:void 0}}</span>}</span>function <span class="fstat-no" title="function not covered" >$u(</span>e){let t=<span class="cstat-no" title="statement not covered" >/^OpenSSL\s(\d+\.\d+)\.\d+/.exec(e);<span class="cstat-no" title="statement not covered" ></span>if(t){let r=<span class="cstat-no" title="statement not covered" >`${t[1]}.x`;<span class="cstat-no" title="statement not covered" ></span>return Vo(r)}</span>}</span>function <span class="fstat-no" title="function not covered" >Lo(</span>e){let t=<span class="cstat-no" title="statement not covered" >/libssl\.so\.(\d)(\.\d)?/.exec(e);<span class="cstat-no" title="statement not covered" ></span>if(t){let r=<span class="cstat-no" title="statement not covered" >`${t[1]}${t[2]??".0"}.x`;<span class="cstat-no" title="statement not covered" ></span>return Vo(r)}</span>}</span>function <span class="fstat-no" title="function not covered" >Vo(</span>e){let t=<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(Bo(e))<span class="cstat-no" title="statement not covered" >return e;l</span></span>et r=<span class="cstat-no" title="statement not covered" >e.split(".");<span class="cstat-no" title="statement not covered" ></span>return r[1]="0",r.join(".")}</span>)();<span class="cstat-no" title="statement not covered" ></span>if(Lu.includes(t))<span class="cstat-no" title="statement not covered" >return t}</span></span>function <span class="fstat-no" title="function not covered" >qu(</span>e){<span class="cstat-no" title="statement not covered" >return dt(e).with({familyDistro:"musl"},<span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >ne('Trying platform-specific paths for "alpine"'),["/lib","/usr/lib"])</span>).with({familyDistro:"debian"},<span class="fstat-no" title="function not covered" >({</span>archFromUname:t})=&gt;(<span class="cstat-no" title="statement not covered" >ne('Trying platform-specific paths for "debian" (and "ubuntu")'),[`/usr/lib/${t}-linux-gnu`,`/lib/${t}-linux-gnu`])</span>).with({familyDistro:"rhel"},<span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >ne('Trying platform-specific paths for "rhel"'),["/lib64","/usr/lib64"])</span>).otherwise(<span class="fstat-no" title="function not covered" >({</span>familyDistro:t,arch:r,archFromUname:n})=&gt;(<span class="cstat-no" title="statement not covered" >ne(`Don't know any platform-specific paths for "${t}" on ${r} (${n})`),[])</span>)}</span>async function <span class="fstat-no" title="function not covered" >Vu(</span>e){let t=<span class="cstat-no" title="statement not covered" >'grep -v "libssl.so.0"',</span>r=<span class="cstat-no" title="statement not covered" >await Fo(e);<span class="cstat-no" title="statement not covered" ></span>if(r){<span class="cstat-no" title="statement not covered" >ne(`Found libssl.so file using platform-specific paths: ${r}`);l</span>et o=<span class="cstat-no" title="statement not covered" >Lo(r);<span class="cstat-no" title="statement not covered" ></span>if(ne(`The parsed libssl version is: ${o}`),o)<span class="cstat-no" title="statement not covered" >return{libssl:o,strategy:"libssl-specific-path"}}<span class="cstat-no" title="statement not covered" ></span></span>n</span>e('Falling back to "ldconfig" and other generic paths');l</span>et n=<span class="cstat-no" title="statement not covered" >await Gr(`ldconfig -p | sed "s/.*=&gt;s*//" | sed "s|.*/||" | grep libssl | sort | ${t}`);<span class="cstat-no" title="statement not covered" ></span>if(n||(n=await Fo(["/lib64","/usr/lib64","/lib","/usr/lib"])),n){<span class="cstat-no" title="statement not covered" >ne(`Found libssl.so file using "ldconfig" or other generic paths: ${n}`);l</span>et o=<span class="cstat-no" title="statement not covered" >Lo(n);<span class="cstat-no" title="statement not covered" ></span>if(ne(`The parsed libssl version is: ${o}`),o)<span class="cstat-no" title="statement not covered" >return{libssl:o,strategy:"ldconfig"}}</span></span>l</span>et i=<span class="cstat-no" title="statement not covered" >await Gr("openssl version -v");<span class="cstat-no" title="statement not covered" ></span>if(i){<span class="cstat-no" title="statement not covered" >ne(`Found openssl binary with version: ${i}`);l</span>et o=<span class="cstat-no" title="statement not covered" >$u(i);<span class="cstat-no" title="statement not covered" ></span>if(ne(`The parsed openssl version is: ${o}`),o)<span class="cstat-no" title="statement not covered" >return{libssl:o,strategy:"openssl-binary"}}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn ne("Couldn't find any version of libssl or OpenSSL in the system"),{}}</span>async function <span class="fstat-no" title="function not covered" >Fo(</span>e){<span class="cstat-no" title="statement not covered" >for(let t of e){let r=<span class="cstat-no" title="statement not covered" >await ju(t);<span class="cstat-no" title="statement not covered" ></span>if(r)<span class="cstat-no" title="statement not covered" >return r}</span></span>}</span>async function <span class="fstat-no" title="function not covered" >ju(</span>e){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return(await Xn.default.readdir(e)).find(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >r.startsWith("libssl.so.")&amp;&amp;!r.startsWith("libssl.so.0"))</span>}</span>catch(t){<span class="cstat-no" title="statement not covered" >if(t.code==="ENOENT")<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>hrow t}</span>}</span>async function nt(){let{binaryTarget:e}=await jo();return e}function Bu(e){return e.binaryTarget!==void 0}async function ei(){let{memoized:e,...t}=await jo();return t}var Ur={};async function jo(){if(Bu(Ur))return Promise.resolve({...Ur,memoized:!0});let e=await qo(),t=Uu(e);return Ur={...e,binaryTarget:t},{...Ur,memoized:!1}}function Uu(e){let{platform:t,arch:r,archFromUname:n,libssl:i,targetDistro:o,familyDistro:s,originalDistro:a}=e;t==="linux"&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >!["x64","arm64"].includes(r)&amp;</span>&amp;<span class="branch-2 cbranch-no" title="branch not covered" >Br(`Prisma only officially supports Linux on amd64 (x86_64) and arm64 (aarch64) system architectures (detected "${r}" instead). If you are using your own custom Prisma engines, you can ignore this warning, as long as you've compiled the engines for your system architecture "${n}".`);</span>let l="1.1.x";<span class="missing-if-branch" title="if path not taken" >I</span>if(t==="linux"&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >i===void 0)</span>{let c=<span class="cstat-no" title="statement not covered" >dt({familyDistro:s}).with({familyDistro:"debian"},<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >"Please manually install OpenSSL via `apt-get update -y &amp;&amp; apt-get install -y openssl` and try installing Prisma again. If you're running Prisma on Docker, add this command to your Dockerfile, or switch to an image that already has OpenSSL installed.")</span>.otherwise(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >"Please manually install OpenSSL and try installing Prisma again.")</span>;<span class="cstat-no" title="statement not covered" ></span>Br(`Prisma failed to detect the libssl/openssl version to use, and may not work as expected. Defaulting to "openssl-${l}".</span>
${c}`)}let u="debian";<span class="missing-if-branch" title="if path not taken" >I</span>if(t==="linux"&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >o===void 0&amp;</span>&amp;<span class="branch-2 cbranch-no" title="branch not covered" >ne(`Distro is "${a}". Falling back to Prisma engines built for "${u}".`),</span>t==="darwin"&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >r==="arm64")<span class="cstat-no" title="statement not covered" ></span>return"darwin-arm64";<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(t==="darwin")<span class="cstat-no" title="statement not covered" >return"darwin";<span class="missing-if-branch" title="else path not taken" >E</span>i</span>f(t==="win32")return"windows";<span class="cstat-no" title="statement not covered" >if(t==="freebsd")<span class="cstat-no" title="statement not covered" >return o;<span class="cstat-no" title="statement not covered" >i</span></span>f(t==="openbsd")<span class="cstat-no" title="statement not covered" >return"openbsd";<span class="cstat-no" title="statement not covered" >i</span></span>f(t==="netbsd")<span class="cstat-no" title="statement not covered" >return"netbsd";<span class="cstat-no" title="statement not covered" >i</span></span>f(t==="linux"&amp;&amp;o==="nixos")<span class="cstat-no" title="statement not covered" >return"linux-nixos";<span class="cstat-no" title="statement not covered" >i</span></span>f(t==="linux"&amp;&amp;r==="arm64")<span class="cstat-no" title="statement not covered" >return`${o==="musl"?"linux-musl-arm64":"linux-arm64"}-openssl-${i||l}`;<span class="cstat-no" title="statement not covered" >i</span></span>f(t==="linux"&amp;&amp;r==="arm")<span class="cstat-no" title="statement not covered" >return`linux-arm-openssl-${i||l}`;<span class="cstat-no" title="statement not covered" >i</span></span>f(t==="linux"&amp;&amp;o==="musl"){let c=<span class="cstat-no" title="statement not covered" >"linux-musl";<span class="cstat-no" title="statement not covered" ></span>return!i||Bo(i)?c:`${c}-openssl-${i}`}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t==="linux"&amp;&amp;o&amp;&amp;i?`${o}-openssl-${i}`:(t!=="linux"&amp;&amp;Br(`Prisma detected unknown OS "${t}" and may not work as expected. Defaulting to "linux".`),i?`${u}-openssl-${i}`:o?`${o}-openssl-${l}`:`${u}-openssl-${l}`)}</span>async function <span class="fstat-no" title="function not covered" >Qu(</span>e){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return await e()}</span>catch{<span class="cstat-no" title="statement not covered" >return}</span>}</span>function <span class="fstat-no" title="function not covered" >Gr(</span>e){<span class="cstat-no" title="statement not covered" >return Qu(<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{let t=<span class="cstat-no" title="statement not covered" >await Nu(e);<span class="cstat-no" title="statement not covered" ></span>return ne(`Command "${e}" successfully returned "${t.stdout}"`),t.stdout}</span>)}</span>async function <span class="fstat-no" title="function not covered" >Gu(</span>){<span class="cstat-no" title="statement not covered" >return typeof Qr.default.machine=="function"?Qr.default.machine():(await Gr("uname -m"))?.trim()}</span>function <span class="fstat-no" title="function not covered" >Bo(</span>e){<span class="cstat-no" title="statement not covered" >return e.startsWith("1.")}</span>var es=D(Xo());function <span class="fstat-no" title="function not covered" >ai(</span>e){<span class="cstat-no" title="statement not covered" >return(0,es.default)(e,e,{fallback:X})}</span>var zu=D(ui());var q=D(require("path")),Zu=D(ui()),jf=F("prisma:engines");function <span class="fstat-no" title="function not covered" >ts(</span>){<span class="cstat-no" title="statement not covered" >return q.default.join(__dirname,"../")}</span>var Bf="libquery-engine";q.default.join(__dirname,"../query-engine-darwin");q.default.join(__dirname,"../query-engine-darwin-arm64");q.default.join(__dirname,"../query-engine-debian-openssl-1.0.x");q.default.join(__dirname,"../query-engine-debian-openssl-1.1.x");q.default.join(__dirname,"../query-engine-debian-openssl-3.0.x");q.default.join(__dirname,"../query-engine-linux-static-x64");q.default.join(__dirname,"../query-engine-linux-static-arm64");q.default.join(__dirname,"../query-engine-rhel-openssl-1.0.x");q.default.join(__dirname,"../query-engine-rhel-openssl-1.1.x");q.default.join(__dirname,"../query-engine-rhel-openssl-3.0.x");q.default.join(__dirname,"../libquery_engine-darwin.dylib.node");q.default.join(__dirname,"../libquery_engine-darwin-arm64.dylib.node");q.default.join(__dirname,"../libquery_engine-debian-openssl-1.0.x.so.node");q.default.join(__dirname,"../libquery_engine-debian-openssl-1.1.x.so.node");q.default.join(__dirname,"../libquery_engine-debian-openssl-3.0.x.so.node");q.default.join(__dirname,"../libquery_engine-linux-arm64-openssl-1.0.x.so.node");q.default.join(__dirname,"../libquery_engine-linux-arm64-openssl-1.1.x.so.node");q.default.join(__dirname,"../libquery_engine-linux-arm64-openssl-3.0.x.so.node");q.default.join(__dirname,"../libquery_engine-linux-musl.so.node");q.default.join(__dirname,"../libquery_engine-linux-musl-openssl-3.0.x.so.node");q.default.join(__dirname,"../libquery_engine-rhel-openssl-1.0.x.so.node");q.default.join(__dirname,"../libquery_engine-rhel-openssl-1.1.x.so.node");q.default.join(__dirname,"../libquery_engine-rhel-openssl-3.0.x.so.node");q.default.join(__dirname,"../query_engine-windows.dll.node");var ci=D(require("fs")),rs=F("chmodPlusX");function <span class="fstat-no" title="function not covered" >pi(</span>e){<span class="cstat-no" title="statement not covered" >if(process.platform==="win32")<span class="cstat-no" title="statement not covered" >return;l</span></span>et t=<span class="cstat-no" title="statement not covered" >ci.default.statSync(e),</span>r=<span class="cstat-no" title="statement not covered" >t.mode|64|8|1;<span class="cstat-no" title="statement not covered" ></span>if(t.mode===r){<span class="cstat-no" title="statement not covered" >rs(`Execution permissions of ${e} are fine`);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>l</span>et n=<span class="cstat-no" title="statement not covered" >r.toString(8).slice(-3);<span class="cstat-no" title="statement not covered" ></span>rs(`Have to call chmodPlusX on ${e}`),ci.default.chmodSync(e,n)}</span>function <span class="fstat-no" title="function not covered" >di(</span>e){let t=<span class="cstat-no" title="statement not covered" >e.e,</span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >a=</span>&gt;<span class="cstat-no" title="statement not covered" >`Prisma cannot find the required \`${a}\` system library in your system`,</span></span>n=<span class="cstat-no" title="statement not covered" >t.message.includes("cannot open shared object file"),</span>i=<span class="cstat-no" title="statement not covered" >`Please refer to the documentation about Prisma's system requirements: ${ai("https://pris.ly/d/system-requirements")}`,</span>o=<span class="cstat-no" title="statement not covered" >`Unable to require(\`${ke(e.id)}\`).`,</span>s=<span class="cstat-no" title="statement not covered" >dt({message:t.message,code:t.code}).with({code:"ENOENT"},<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >"File does not exist.")</span>.when(<span class="fstat-no" title="function not covered" >({</span>message:a})=&gt;<span class="cstat-no" title="statement not covered" >n&amp;&amp;a.includes("libz"),<span class="fstat-no" title="function not covered" ></span>()</span>=&gt;<span class="cstat-no" title="statement not covered" >`${r("libz")}. Please install it and try again.`)</span>.when(<span class="fstat-no" title="function not covered" >({</span>message:a})=&gt;<span class="cstat-no" title="statement not covered" >n&amp;&amp;a.includes("libgcc_s"),<span class="fstat-no" title="function not covered" ></span>()</span>=&gt;<span class="cstat-no" title="statement not covered" >`${r("libgcc_s")}. Please install it and try again.`)</span>.when(<span class="fstat-no" title="function not covered" >({</span>message:a})=&gt;<span class="cstat-no" title="statement not covered" >n&amp;&amp;a.includes("libssl"),<span class="fstat-no" title="function not covered" ></span>()</span>=&gt;{let a=<span class="cstat-no" title="statement not covered" >e.platformInfo.libssl?`openssl-${e.platformInfo.libssl}`:"openssl";<span class="cstat-no" title="statement not covered" ></span>return`${r("libssl")}. Please install ${a} and try again.`}</span>).when(<span class="fstat-no" title="function not covered" >({</span>message:a})=&gt;<span class="cstat-no" title="statement not covered" >a.includes("GLIBC"),<span class="fstat-no" title="function not covered" ></span>()</span>=&gt;<span class="cstat-no" title="statement not covered" >`Prisma has detected an incompatible version of the \`glibc\` C standard library installed in your system. This probably means your system may be too old to run Prisma. ${i}`)</span>.when(<span class="fstat-no" title="function not covered" >({</span>message:a})=&gt;<span class="cstat-no" title="statement not covered" >e.platformInfo.platform==="linux"&amp;&amp;a.includes("symbol not found"),<span class="fstat-no" title="function not covered" ></span>()</span>=&gt;<span class="cstat-no" title="statement not covered" >`The Prisma engines are not compatible with your system ${e.platformInfo.originalDistro} on (${e.platformInfo.archFromUname}) which uses the \`${e.platformInfo.binaryTarget}\` binaryTarget by default. ${i}`)</span>.otherwise(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >`The Prisma engines do not seem to be compatible with your system. ${i}`)</span>;<span class="cstat-no" title="statement not covered" ></span>return`${o}</span>
${s}
&nbsp;
Details: ${t.message}`}var yi=D(as()),Kr=D(require("fs"));var gt=D(require("path"));function ls(e){let t=e.ignoreProcessEnv?<span class="branch-0 cbranch-no" title="branch not covered" >{}:</span>process.env,r=n=&gt;n.match(/(.?\${(?:[a-zA-Z0-9_]+)?})/g)?.reduce(<span class="fstat-no" title="function not covered" >fu</span>nction(o,s){let a=<span class="cstat-no" title="statement not covered" >/(.?)\${([a-zA-Z0-9_]+)?}/g.exec(s);<span class="cstat-no" title="statement not covered" ></span>if(!a)<span class="cstat-no" title="statement not covered" >return o;l</span></span>et l=<span class="cstat-no" title="statement not covered" >a[1],</span>u,c;<span class="cstat-no" title="statement not covered" >if(l==="\\")<span class="cstat-no" title="statement not covered" >c=a[0],u=c.replace("\\$","$");e</span>lse{let p=<span class="cstat-no" title="statement not covered" >a[2];<span class="cstat-no" title="statement not covered" ></span>c=a[0].substring(l.length),u=Object.hasOwnProperty.call(t,p)?t[p]:e.parsed[p]||"",u=r(u)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn o.replace(c,u)}</span>,n)??n;for(let n in e.parsed){let i=Object.hasOwnProperty.call(t,n)?t[n]:<span class="branch-1 cbranch-no" title="branch not covered" >e.parsed[n];</span>e.parsed[n]=r(i)}for(let n in e.parsed)t[n]=e.parsed[n];return e}var hi=F("prisma:tryLoadEnv");function Kt({rootEnvPath:e,schemaEnvPath:t},r=<span class="branch-0 cbranch-no" title="branch not covered" >{conflictCheck:"none"})</span>{let n=us(e);r.conflictCheck!=="none"&amp;&amp;fc(n,t,r.conflictCheck);let i=null;return cs(n?.path,t)||(i=us(t)),!n&amp;&amp;!i&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >hi("No Environment variables loaded"),</span>i?.dotenvResult.error?<span class="branch-0 cbranch-no" title="branch not covered" >console.error(de(W("Schema Env Error: "))+i.dotenvResult.error):</span>{message:[n?.message,i?.message].filter(Boolean).join(`
`),parsed:{...n?.dotenvResult?.parsed,...i?.dotenvResult?.parsed}}}function fc(e,t,r){let n=e?.dotenvResult.parsed,i=!cs(e?.path,t);<span class="missing-if-branch" title="if path not taken" >I</span>if(n&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >t&amp;</span>&amp;<span class="branch-2 cbranch-no" title="branch not covered" >i&amp;</span>&amp;<span class="branch-3 cbranch-no" title="branch not covered" >Kr.default.existsSync(t))</span>{let o=<span class="cstat-no" title="statement not covered" >yi.default.parse(Kr.default.readFileSync(t)),</span>s=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let a in o)<span class="cstat-no" title="statement not covered" >n[a]===o[a]&amp;&amp;s.push(a);<span class="cstat-no" title="statement not covered" >i</span></span>f(s.length&gt;0){let a=<span class="cstat-no" title="statement not covered" >gt.default.relative(process.cwd(),e.path),</span>l=<span class="cstat-no" title="statement not covered" >gt.default.relative(process.cwd(),t);<span class="cstat-no" title="statement not covered" ></span>if(r==="error"){let u=<span class="cstat-no" title="statement not covered" >`There is a conflict between env var${s.length&gt;1?"s":""} in ${X(a)} and ${X(l)}</span></span></span>
Conflicting env vars:
${s.map(<span class="fstat-no" title="function not covered" >c=</span>&gt;<span class="cstat-no" title="statement not covered" >`  ${W(c)}`)</span>.join(`
`)}
&nbsp;
We suggest to move the contents of ${X(l)} to ${X(a)} to consolidate your env vars.
`;<span class="cstat-no" title="statement not covered" >throw new Error(u)}</span>else <span class="cstat-no" title="statement not covered" >if(r==="warn"){let u=<span class="cstat-no" title="statement not covered" >`Conflict for env var${s.length&gt;1?"s":""} ${s.map(<span class="fstat-no" title="function not covered" >c=</span>&gt;<span class="cstat-no" title="statement not covered" >W(c))</span>.join(", ")} in ${X(a)} and ${X(l)}</span></span>
Env vars from ${X(l)} overwrite the ones from ${X(a)}
      `;<span class="cstat-no" title="statement not covered" >console.warn(`${De("warn(prisma)")} ${u}`)}</span>}}}function us(e){if(gc(e)){hi(`Environment variables loaded from ${e}`);let t=yi.default.config({path:e,debug:process.env.DOTENV_CONFIG_DEBUG?<span class="branch-0 cbranch-no" title="branch not covered" >!0:</span>void 0});return{dotenvResult:ls(t),message:ke(`Environment variables loaded from ${gt.default.relative(process.cwd(),e)}`),path:e}}else hi(`Environment variables not found at ${e}`);return null}function cs(e,t){return e&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >t&amp;</span>&amp;<span class="branch-2 cbranch-no" title="branch not covered" >gt.default.resolve(e)===gt.default.resolve(t)}</span>function gc(e){return!!(e&amp;&amp;Kr.default.existsSync(e))}var ps="library";function Yt(e){let t=hc();return t||(e?.config.engineType==="library"?"library":<span class="branch-1 cbranch-no" title="branch not covered" >e?.config.engineType==="binary"?"binary":ps)</span>}function hc(){let e=process.env.PRISMA_CLIENT_ENGINE_TYPE;return e==="library"?<span class="branch-0 cbranch-no" title="branch not covered" >"library":</span>e==="binary"?<span class="branch-0 cbranch-no" title="branch not covered" >"binary":</span>void 0}var zt;(t=&gt;{let e;(A=&gt;(A.findUnique="findUnique",A.findUniqueOrThrow="findUniqueOrThrow",A.findFirst="findFirst",A.findFirstOrThrow="findFirstOrThrow",A.findMany="findMany",A.create="create",A.createMany="createMany",A.createManyAndReturn="createManyAndReturn",A.update="update",A.updateMany="updateMany",A.updateManyAndReturn="updateManyAndReturn",A.upsert="upsert",A.delete="delete",A.deleteMany="deleteMany",A.groupBy="groupBy",A.count="count",A.aggregate="aggregate",A.findRaw="findRaw",A.aggregateRaw="aggregateRaw"))(e=t.ModelAction||={})})(zt||={});var Zt=D(require("path"));function <span class="fstat-no" title="function not covered" >Ei(</span>e){<span class="cstat-no" title="statement not covered" >return Zt.default.sep===Zt.default.posix.sep?e:e.split(Zt.default.sep).join(Zt.default.posix.sep)}</span>var ys=D(bi());function <span class="fstat-no" title="function not covered" >xi(</span>e){<span class="cstat-no" title="statement not covered" >return String(new wi(e))}</span>var wi=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.config=t}<span class="fstat-no" title="function not covered" ></span>to</span>String(){let{config:t}=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >t.provider.fromEnvVar?`env("${t.provider.fromEnvVar}")`:t.provider.value,</span>n=<span class="cstat-no" title="statement not covered" >JSON.parse(JSON.stringify({provider:r,binaryTargets:Ec(t.binaryTargets)}));<span class="cstat-no" title="statement not covered" ></span>return`generator ${t.name} {</span>
${(0,ys.default)(bc(n),2)}
}`}};function <span class="fstat-no" title="function not covered" >Ec(</span>e){let t;<span class="cstat-no" title="statement not covered" >if(e.length&gt;0){let r=<span class="cstat-no" title="statement not covered" >e.find(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >n.fromEnvVar!==null)</span>;<span class="cstat-no" title="statement not covered" ></span>r?t=`env("${r.fromEnvVar}")`:t=e.map(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >n.native?"native":n.value)</span>}</span>else <span class="cstat-no" title="statement not covered" >t=void 0;<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>function <span class="fstat-no" title="function not covered" >bc(</span>e){let t=<span class="cstat-no" title="statement not covered" >Object.keys(e).reduce(<span class="fstat-no" title="function not covered" >(r</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >Math.max(r,n.length),</span>0);<span class="cstat-no" title="statement not covered" ></span>return Object.entries(e).map(<span class="fstat-no" title="function not covered" >([</span>r,n])=&gt;<span class="cstat-no" title="statement not covered" >`${r.padEnd(t)} = ${wc(n)}`)</span>.join(`</span>
`)}function <span class="fstat-no" title="function not covered" >wc(</span>e){<span class="cstat-no" title="statement not covered" >return JSON.parse(JSON.stringify(e,<span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >Array.isArray(r)?`[${r.map(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >JSON.stringify(n))</span>.join(", ")}]`:JSON.stringify(r))</span>)}</span>var er={};Bt(er,{error:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Pc,</span>info:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >vc,</span>log:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >xc,</span>query:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Tc,</span>should:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Es,</span>tags:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Xt,</span>warn:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >vi}</span>);var Xt={error:de("prisma:error"),warn:De("prisma:warn"),info:_e("prisma:info"),query:rt("prisma:query")},Es={warn:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >!process.env.PRISMA_DISABLE_WARNINGS}</span>;function <span class="fstat-no" title="function not covered" >xc(</span>...e){<span class="cstat-no" title="statement not covered" >console.log(...e)}</span>function <span class="fstat-no" title="function not covered" >vi(</span>e,...t){<span class="cstat-no" title="statement not covered" >Es.warn()&amp;&amp;console.warn(`${Xt.warn} ${e}`,...t)}</span>function <span class="fstat-no" title="function not covered" >vc(</span>e,...t){<span class="cstat-no" title="statement not covered" >console.info(`${Xt.info} ${e}`,...t)}</span>function <span class="fstat-no" title="function not covered" >Pc(</span>e,...t){<span class="cstat-no" title="statement not covered" >console.error(`${Xt.error} ${e}`,...t)}</span>function <span class="fstat-no" title="function not covered" >Tc(</span>e,...t){<span class="cstat-no" title="statement not covered" >console.log(`${Xt.query} ${e}`,...t)}</span>function <span class="fstat-no" title="function not covered" >Yr(</span>e,t){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >throw new Error(`${t}. This should never happen. If you see this error, please, open an issue at https://pris.ly/prisma-prisma-bug-report`)}</span></span>function <span class="fstat-no" title="function not covered" >Fe(</span>e,t){<span class="cstat-no" title="statement not covered" >throw new Error(t)}</span>function <span class="fstat-no" title="function not covered" >Ti(</span>e,t){<span class="cstat-no" title="statement not covered" >return Object.prototype.hasOwnProperty.call(e,t)}</span>var Ri=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >e.reduce(<span class="fstat-no" title="function not covered" >(r</span>,n)=&gt;(<span class="cstat-no" title="statement not covered" >r[t(n)]=n,r)</span>,{});</span>function ht(e,t){let r={};for(let n of Object.keys(e))r[n]=t(e[n],n);return r}function <span class="fstat-no" title="function not covered" >Ci(</span>e,t){<span class="cstat-no" title="statement not covered" >if(e.length===0)<span class="cstat-no" title="statement not covered" >return;l</span></span>et r=<span class="cstat-no" title="statement not covered" >e[0];<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >1;</span>n&lt;e.length;n++)<span class="cstat-no" title="statement not covered" >t(r,e[n])&lt;0&amp;&amp;(r=e[n]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>function w(e,t){Object.defineProperty(e,"name",{value:t,configurable:!0})}var Ps=new Set,tr=<span class="fstat-no" title="function not covered" >(e</span>,t,...r)=&gt;{<span class="cstat-no" title="statement not covered" >Ps.has(e)||(Ps.add(e),vi(t,...r))}</span>;var T=class e extends Error{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,r,n){<span class="cstat-no" title="statement not covered" >super(t),this.name="PrismaClientInitializationError",this.clientVersion=r,this.errorCode=n,Error.captureStackTrace(e)}<span class="fstat-no" title="function not covered" ></span>ge</span>t[Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClientInitializationError"}</span>};w(T,"PrismaClientInitializationError");var ee=class extends Error{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,{code:r,clientVersion:n,meta:i,batchRequestIdx:o}){<span class="cstat-no" title="statement not covered" >super(t),this.name="PrismaClientKnownRequestError",this.code=r,this.clientVersion=n,this.meta=i,Object.defineProperty(this,"batchRequestIdx",{value:o,enumerable:!1,writable:!0})}<span class="fstat-no" title="function not covered" ></span>ge</span>t[Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClientKnownRequestError"}</span>};w(ee,"PrismaClientKnownRequestError");var ce=class extends Error{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,r){<span class="cstat-no" title="statement not covered" >super(t),this.name="PrismaClientRustPanicError",this.clientVersion=r}<span class="fstat-no" title="function not covered" ></span>ge</span>t[Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClientRustPanicError"}</span>};w(ce,"PrismaClientRustPanicError");var B=class extends Error{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,{clientVersion:r,batchRequestIdx:n}){<span class="cstat-no" title="statement not covered" >super(t),this.name="PrismaClientUnknownRequestError",this.clientVersion=r,Object.defineProperty(this,"batchRequestIdx",{value:n,writable:!0,enumerable:!1})}<span class="fstat-no" title="function not covered" ></span>ge</span>t[Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClientUnknownRequestError"}</span>};w(B,"PrismaClientUnknownRequestError");var te=class extends Error{<span class="fstat-no" title="function not covered" >co</span>nstructor(r,{clientVersion:n}){<span class="cstat-no" title="statement not covered" >super(r);<span class="cstat-no" title="statement not covered" >t</span>his.name="PrismaClientValidationError";<span class="cstat-no" title="statement not covered" >t</span>his.clientVersion=n}<span class="fstat-no" title="function not covered" ></span>ge</span>t[Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClientValidationError"}</span>};w(te,"PrismaClientValidationError");var yt=9e15,Ye=1e9,Si="0123456789abcdef",en="2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058",tn="3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789",Ai={precision:20,rounding:4,modulo:1,toExpNeg:-7,toExpPos:21,minE:-yt,maxE:yt,crypto:!1},Ss,Me,b=!0,nn="[DecimalError] ",Ke=nn+"Invalid argument: ",As=nn+"Precision limit exceeded",Is=nn+"crypto unavailable",Os="[object Decimal]",re=Math.floor,G=Math.pow,Cc=/^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,Sc=/^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,Ac=/^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,ks=/^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,he=1e7,E=7,Ic=9007199254740991,Oc=en.length-1,Ii=tn.length-1,m={toStringTag:Os};m.absoluteValue=m.abs=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >new this.constructor(this);<span class="cstat-no" title="statement not covered" ></span>return e.s&lt;0&amp;&amp;(e.s=1),y(e)}</span>;m.ceil=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return y(new this.constructor(this),this.e+1,2)}</span>;m.clampedTo=m.clamp=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r,n=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >n.constructor;<span class="cstat-no" title="statement not covered" ></span>if(e=new i(e),t=new i(t),!e.s||!t.s)<span class="cstat-no" title="statement not covered" >return new i(NaN);<span class="cstat-no" title="statement not covered" >i</span></span>f(e.gt(t))<span class="cstat-no" title="statement not covered" >throw Error(Ke+t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r=n.cmp(e),r&lt;0?e:n.cmp(t)&gt;0?t:new i(n)}</span>;m.comparedTo=m.cmp=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t,r,n,i,o=<span class="cstat-no" title="statement not covered" >this,</span>s=<span class="cstat-no" title="statement not covered" >o.d,</span>a=<span class="cstat-no" title="statement not covered" >(e=new o.constructor(e)).d,</span>l=<span class="cstat-no" title="statement not covered" >o.s,</span>u=<span class="cstat-no" title="statement not covered" >e.s;<span class="cstat-no" title="statement not covered" ></span>if(!s||!a)<span class="cstat-no" title="statement not covered" >return!l||!u?NaN:l!==u?l:s===a?0:!s^l&lt;0?1:-1;<span class="cstat-no" title="statement not covered" >i</span></span>f(!s[0]||!a[0])<span class="cstat-no" title="statement not covered" >return s[0]?l:a[0]?-u:0;<span class="cstat-no" title="statement not covered" >i</span></span>f(l!==u)<span class="cstat-no" title="statement not covered" >return l;<span class="cstat-no" title="statement not covered" >i</span></span>f(o.e!==e.e)<span class="cstat-no" title="statement not covered" >return o.e&gt;e.e^l&lt;0?1:-1;<span class="cstat-no" title="statement not covered" >f</span></span>or(n=s.length,i=a.length,t=0,r=n&lt;i?n:i;t&lt;r;++t)<span class="cstat-no" title="statement not covered" >if(s[t]!==a[t])<span class="cstat-no" title="statement not covered" >return s[t]&gt;a[t]^l&lt;0?1:-1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn n===i?0:n&gt;i^l&lt;0?1:-1}</span>;m.cosine=m.cos=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e,t,r=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >r.constructor;<span class="cstat-no" title="statement not covered" ></span>return r.d?r.d[0]?(e=n.precision,t=n.rounding,n.precision=e+Math.max(r.e,r.sd())+E,n.rounding=1,r=kc(n,Fs(n,r)),n.precision=e,n.rounding=t,y(Me==2||Me==3?r.neg():r,e,t,!0)):new n(1):new n(NaN)}</span>;m.cubeRoot=m.cbrt=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e,t,r,n,i,o,s,a,l,u,c=<span class="cstat-no" title="statement not covered" >this,</span>p=<span class="cstat-no" title="statement not covered" >c.constructor;<span class="cstat-no" title="statement not covered" ></span>if(!c.isFinite()||c.isZero())<span class="cstat-no" title="statement not covered" >return new p(c);<span class="cstat-no" title="statement not covered" >f</span></span>or(b=!1,o=c.s*G(c.s*c,1/3),!o||Math.abs(o)==1/0?(r=K(c.d),e=c.e,(o=(e-r.length+1)%3)&amp;&amp;(r+=o==1||o==-2?"0":"00"),o=G(r,1/3),e=re((e+1)/3)-(e%3==(e&lt;0?-1:2)),o==1/0?r="5e"+e:(r=o.toExponential(),r=r.slice(0,r.indexOf("e")+1)+e),n=new p(r),n.s=c.s):n=new p(o.toString()),s=(e=p.precision)+3;;)<span class="cstat-no" title="statement not covered" >if(a=n,l=a.times(a).times(a),u=l.plus(c),n=M(u.plus(c).times(a),u.plus(l),s+2,1),K(a.d).slice(0,s)===(r=K(n.d)).slice(0,s))<span class="cstat-no" title="statement not covered" >if(r=r.slice(s-3,s+1),r=="9999"||!i&amp;&amp;r=="4999"){<span class="cstat-no" title="statement not covered" >if(!i&amp;&amp;(y(a,e+1,0),a.times(a).times(a).eq(c))){<span class="cstat-no" title="statement not covered" >n=a;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>s</span>+=4,i=1}</span>else{<span class="cstat-no" title="statement not covered" >(!+r||!+r.slice(1)&amp;&amp;r.charAt(0)=="5")&amp;&amp;(y(n,e+1,1),t=!n.times(n).times(n).eq(c));<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>eturn b=!0,y(n,e,p.rounding,t)}</span>;m.decimalPlaces=m.dp=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e,t=<span class="cstat-no" title="statement not covered" >this.d,</span>r=<span class="cstat-no" title="statement not covered" >NaN;<span class="cstat-no" title="statement not covered" ></span>if(t){<span class="cstat-no" title="statement not covered" >if(e=t.length-1,r=(e-re(this.e/E))*E,e=t[e],e)<span class="cstat-no" title="statement not covered" >for(;e%10==0;e/=10)<span class="cstat-no" title="statement not covered" >r--;<span class="cstat-no" title="statement not covered" >r</span></span></span>&lt;0&amp;&amp;(r=0)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>;m.dividedBy=m.div=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return M(this,new this.constructor(e))}</span>;m.dividedToIntegerBy=m.divToInt=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >t.constructor;<span class="cstat-no" title="statement not covered" ></span>return y(M(t,new r(e),0,1,1),r.precision,r.rounding)}</span>;m.equals=m.eq=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return this.cmp(e)===0}</span>;m.floor=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return y(new this.constructor(this),this.e+1,3)}</span>;m.greaterThan=m.gt=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return this.cmp(e)&gt;0}</span>;m.greaterThanOrEqualTo=m.gte=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >this.cmp(e);<span class="cstat-no" title="statement not covered" ></span>return t==1||t===0}</span>;m.hyperbolicCosine=m.cosh=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e,t,r,n,i,o=<span class="cstat-no" title="statement not covered" >this,</span>s=<span class="cstat-no" title="statement not covered" >o.constructor,</span>a=<span class="cstat-no" title="statement not covered" >new s(1);<span class="cstat-no" title="statement not covered" ></span>if(!o.isFinite())<span class="cstat-no" title="statement not covered" >return new s(o.s?1/0:NaN);<span class="cstat-no" title="statement not covered" >i</span></span>f(o.isZero())<span class="cstat-no" title="statement not covered" >return a;<span class="cstat-no" title="statement not covered" >r</span></span>=s.precision,n=s.rounding,s.precision=r+Math.max(o.e,o.sd())+4,s.rounding=1,i=o.d.length,i&lt;32?(e=Math.ceil(i/3),t=(1/sn(4,e)).toString()):(e=16,t="2.3283064365386962890625e-10"),o=Et(s,1,o.times(t),new s(1),!0);<span class="cstat-no" title="statement not covered" >f</span>or(var l,u=<span class="cstat-no" title="statement not covered" >e,</span>c=<span class="cstat-no" title="statement not covered" >new s(8);</span>u--;)<span class="cstat-no" title="statement not covered" >l=o.times(o),o=a.minus(l.times(c.minus(l.times(c))));<span class="cstat-no" title="statement not covered" >r</span></span>eturn y(o,s.precision=r,s.rounding=n,!0)}</span>;m.hyperbolicSine=m.sinh=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e,t,r,n,i=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >i.constructor;<span class="cstat-no" title="statement not covered" ></span>if(!i.isFinite()||i.isZero())<span class="cstat-no" title="statement not covered" >return new o(i);<span class="cstat-no" title="statement not covered" >i</span></span>f(t=o.precision,r=o.rounding,o.precision=t+Math.max(i.e,i.sd())+4,o.rounding=1,n=i.d.length,n&lt;3)<span class="cstat-no" title="statement not covered" >i=Et(o,2,i,i,!0);e</span>lse{<span class="cstat-no" title="statement not covered" >e=1.4*Math.sqrt(n),e=e&gt;16?16:e|0,i=i.times(1/sn(5,e)),i=Et(o,2,i,i,!0);<span class="cstat-no" title="statement not covered" >f</span>or(var s,a=<span class="cstat-no" title="statement not covered" >new o(5),</span>l=<span class="cstat-no" title="statement not covered" >new o(16),</span>u=<span class="cstat-no" title="statement not covered" >new o(20);</span>e--;)<span class="cstat-no" title="statement not covered" >s=i.times(i),i=i.times(a.plus(s.times(l.times(s).plus(u))))}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn o.precision=t,o.rounding=r,y(i,t,r,!0)}</span>;m.hyperbolicTangent=m.tanh=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e,t,r=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >r.constructor;<span class="cstat-no" title="statement not covered" ></span>return r.isFinite()?r.isZero()?new n(r):(e=n.precision,t=n.rounding,n.precision=e+7,n.rounding=1,M(r.sinh(),r.cosh(),n.precision=e,n.rounding=t)):new n(r.s)}</span>;m.inverseCosine=m.acos=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e,t=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >t.constructor,</span>n=<span class="cstat-no" title="statement not covered" >t.abs().cmp(1),</span>i=<span class="cstat-no" title="statement not covered" >r.precision,</span>o=<span class="cstat-no" title="statement not covered" >r.rounding;<span class="cstat-no" title="statement not covered" ></span>return n!==-1?n===0?t.isNeg()?ge(r,i,o):new r(0):new r(NaN):t.isZero()?ge(r,i+4,o).times(.5):(r.precision=i+6,r.rounding=1,t=t.asin(),e=ge(r,i+4,o).times(.5),r.precision=i,r.rounding=o,e.minus(t))}</span>;m.inverseHyperbolicCosine=m.acosh=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e,t,r=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >r.constructor;<span class="cstat-no" title="statement not covered" ></span>return r.lte(1)?new n(r.eq(1)?0:NaN):r.isFinite()?(e=n.precision,t=n.rounding,n.precision=e+Math.max(Math.abs(r.e),r.sd())+4,n.rounding=1,b=!1,r=r.times(r).minus(1).sqrt().plus(r),b=!0,n.precision=e,n.rounding=t,r.ln()):new n(r)}</span>;m.inverseHyperbolicSine=m.asinh=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e,t,r=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >r.constructor;<span class="cstat-no" title="statement not covered" ></span>return!r.isFinite()||r.isZero()?new n(r):(e=n.precision,t=n.rounding,n.precision=e+2*Math.max(Math.abs(r.e),r.sd())+6,n.rounding=1,b=!1,r=r.times(r).plus(1).sqrt().plus(r),b=!0,n.precision=e,n.rounding=t,r.ln())}</span>;m.inverseHyperbolicTangent=m.atanh=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e,t,r,n,i=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >i.constructor;<span class="cstat-no" title="statement not covered" ></span>return i.isFinite()?i.e&gt;=0?new o(i.abs().eq(1)?i.s/0:i.isZero()?i:NaN):(e=o.precision,t=o.rounding,n=i.sd(),Math.max(n,e)&lt;2*-i.e-1?y(new o(i),e,t,!0):(o.precision=r=n-i.e,i=M(i.plus(1),new o(1).minus(i),r+e,1),o.precision=e+4,o.rounding=1,i=i.ln(),o.precision=e,o.rounding=t,i.times(.5))):new o(NaN)}</span>;m.inverseSine=m.asin=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e,t,r,n,i=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >i.constructor;<span class="cstat-no" title="statement not covered" ></span>return i.isZero()?new o(i):(t=i.abs().cmp(1),r=o.precision,n=o.rounding,t!==-1?t===0?(e=ge(o,r+4,n).times(.5),e.s=i.s,e):new o(NaN):(o.precision=r+6,o.rounding=1,i=i.div(new o(1).minus(i.times(i)).sqrt().plus(1)).atan(),o.precision=r,o.rounding=n,i.times(2)))}</span>;m.inverseTangent=m.atan=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e,t,r,n,i,o,s,a,l,u=<span class="cstat-no" title="statement not covered" >this,</span>c=<span class="cstat-no" title="statement not covered" >u.constructor,</span>p=<span class="cstat-no" title="statement not covered" >c.precision,</span>d=<span class="cstat-no" title="statement not covered" >c.rounding;<span class="cstat-no" title="statement not covered" ></span>if(u.isFinite()){<span class="cstat-no" title="statement not covered" >if(u.isZero())<span class="cstat-no" title="statement not covered" >return new c(u);<span class="cstat-no" title="statement not covered" >i</span></span>f(u.abs().eq(1)&amp;&amp;p+4&lt;=Ii)<span class="cstat-no" title="statement not covered" >return s=ge(c,p+4,d).times(.25),s.s=u.s,s}</span></span>else{<span class="cstat-no" title="statement not covered" >if(!u.s)<span class="cstat-no" title="statement not covered" >return new c(NaN);<span class="cstat-no" title="statement not covered" >i</span></span>f(p+4&lt;=Ii)<span class="cstat-no" title="statement not covered" >return s=ge(c,p+4,d).times(.5),s.s=u.s,s}<span class="cstat-no" title="statement not covered" ></span></span>f</span>or(c.precision=a=p+10,c.rounding=1,r=Math.min(28,a/E+2|0),e=r;e;--e)<span class="cstat-no" title="statement not covered" >u=u.div(u.times(u).plus(1).sqrt().plus(1));<span class="cstat-no" title="statement not covered" >f</span></span>or(b=!1,t=Math.ceil(a/E),n=1,l=u.times(u),s=new c(u),i=u;e!==-1;)<span class="cstat-no" title="statement not covered" >if(i=i.times(l),o=s.minus(i.div(n+=2)),i=i.times(l),s=o.plus(i.div(n+=2)),s.d[t]!==void 0)<span class="cstat-no" title="statement not covered" >for(e=t;s.d[e]===o.d[e]&amp;&amp;e--;);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn r&amp;&amp;(s=s.times(2&lt;&lt;r-1)),b=!0,y(s,c.precision=p,c.rounding=d,!0)}</span>;m.isFinite=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return!!this.d}</span>;m.isInteger=m.isInt=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return!!this.d&amp;&amp;re(this.e/E)&gt;this.d.length-2}</span>;m.isNaN=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return!this.s}</span>;m.isNegative=m.isNeg=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.s&lt;0}</span>;m.isPositive=m.isPos=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.s&gt;0}</span>;m.isZero=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return!!this.d&amp;&amp;this.d[0]===0}</span>;m.lessThan=m.lt=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return this.cmp(e)&lt;0}</span>;m.lessThanOrEqualTo=m.lte=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return this.cmp(e)&lt;1}</span>;m.logarithm=m.log=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t,r,n,i,o,s,a,l,u=<span class="cstat-no" title="statement not covered" >this,</span>c=<span class="cstat-no" title="statement not covered" >u.constructor,</span>p=<span class="cstat-no" title="statement not covered" >c.precision,</span>d=<span class="cstat-no" title="statement not covered" >c.rounding,</span>f=<span class="cstat-no" title="statement not covered" >5;<span class="cstat-no" title="statement not covered" ></span>if(e==null)<span class="cstat-no" title="statement not covered" >e=new c(10),t=!0;e</span>lse{<span class="cstat-no" title="statement not covered" >if(e=new c(e),r=e.d,e.s&lt;0||!r||!r[0]||e.eq(1))<span class="cstat-no" title="statement not covered" >return new c(NaN);<span class="cstat-no" title="statement not covered" >t</span></span>=e.eq(10)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(r=u.d,u.s&lt;0||!r||!r[0]||u.eq(1))<span class="cstat-no" title="statement not covered" >return new c(r&amp;&amp;!r[0]?-1/0:u.s!=1?NaN:r?0:1/0);<span class="cstat-no" title="statement not covered" >i</span></span>f(t)<span class="cstat-no" title="statement not covered" >if(r.length&gt;1)<span class="cstat-no" title="statement not covered" >o=!0;e</span>lse{<span class="cstat-no" title="statement not covered" >for(i=r[0];i%10===0;)<span class="cstat-no" title="statement not covered" >i/=10;<span class="cstat-no" title="statement not covered" >o</span></span>=i!==1}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(b=!1,a=p+f,s=We(u,a),n=t?rn(c,a+10):We(e,a),l=M(s,n,a,1),rr(l.d,i=p,d))<span class="cstat-no" title="statement not covered" >do <span class="cstat-no" title="statement not covered" >if(a+=10,s=We(u,a),n=t?rn(c,a+10):We(e,a),l=M(s,n,a,1),!o){<span class="cstat-no" title="statement not covered" >+K(l.d).slice(i+1,i+15)+1==1e14&amp;&amp;(l=y(l,p+1,0));<span class="cstat-no" title="statement not covered" >b</span>reak}</span>w</span>hile(rr(l.d,i+=10,d));<span class="cstat-no" title="statement not covered" >r</span></span>eturn b=!0,y(l,p,d)}</span>;m.minus=m.sub=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t,r,n,i,o,s,a,l,u,c,p,d,f=<span class="cstat-no" title="statement not covered" >this,</span>g=<span class="cstat-no" title="statement not covered" >f.constructor;<span class="cstat-no" title="statement not covered" ></span>if(e=new g(e),!f.d||!e.d)<span class="cstat-no" title="statement not covered" >return!f.s||!e.s?e=new g(NaN):f.d?e.s=-e.s:e=new g(e.d||f.s!==e.s?f:NaN),e;<span class="cstat-no" title="statement not covered" >i</span></span>f(f.s!=e.s)<span class="cstat-no" title="statement not covered" >return e.s=-e.s,f.plus(e);<span class="cstat-no" title="statement not covered" >i</span></span>f(u=f.d,d=e.d,a=g.precision,l=g.rounding,!u[0]||!d[0]){<span class="cstat-no" title="statement not covered" >if(d[0])<span class="cstat-no" title="statement not covered" >e.s=-e.s;e</span>lse <span class="cstat-no" title="statement not covered" >if(u[0])<span class="cstat-no" title="statement not covered" >e=new g(f);e</span>lse <span class="cstat-no" title="statement not covered" >return new g(l===3?-0:0);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn b?y(e,a,l):e}<span class="cstat-no" title="statement not covered" ></span>i</span>f(r=re(e.e/E),c=re(f.e/E),u=u.slice(),o=c-r,o){<span class="cstat-no" title="statement not covered" >for(p=o&lt;0,p?(t=u,o=-o,s=d.length):(t=d,r=c,s=u.length),n=Math.max(Math.ceil(a/E),s)+2,o&gt;n&amp;&amp;(o=n,t.length=1),t.reverse(),n=o;n--;)<span class="cstat-no" title="statement not covered" >t.push(0);<span class="cstat-no" title="statement not covered" >t</span></span>.reverse()}</span>else{<span class="cstat-no" title="statement not covered" >for(n=u.length,s=d.length,p=n&lt;s,p&amp;&amp;(s=n),n=0;n&lt;s;n++)<span class="cstat-no" title="statement not covered" >if(u[n]!=d[n]){<span class="cstat-no" title="statement not covered" >p=u[n]&lt;d[n];<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>o</span></span>=0}<span class="cstat-no" title="statement not covered" ></span>f</span>or(p&amp;&amp;(t=u,u=d,d=t,e.s=-e.s),s=u.length,n=d.length-s;n&gt;0;--n)<span class="cstat-no" title="statement not covered" >u[s++]=0;<span class="cstat-no" title="statement not covered" >f</span></span>or(n=d.length;n&gt;o;){<span class="cstat-no" title="statement not covered" >if(u[--n]&lt;d[n]){<span class="cstat-no" title="statement not covered" >for(i=n;i&amp;&amp;u[--i]===0;)<span class="cstat-no" title="statement not covered" >u[i]=he-1;<span class="cstat-no" title="statement not covered" >-</span></span>-u[i],u[n]+=he}<span class="cstat-no" title="statement not covered" ></span>u</span>[n]-=d[n]}<span class="cstat-no" title="statement not covered" ></span>f</span>or(;u[--s]===0;)<span class="cstat-no" title="statement not covered" >u.pop();<span class="cstat-no" title="statement not covered" >f</span></span>or(;u[0]===0;u.shift())<span class="cstat-no" title="statement not covered" >--r;<span class="cstat-no" title="statement not covered" >r</span></span>eturn u[0]?(e.d=u,e.e=on(u,r),b?y(e,a,l):e):new g(l===3?-0:0)}</span>;m.modulo=m.mod=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t,r=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >r.constructor;<span class="cstat-no" title="statement not covered" ></span>return e=new n(e),!r.d||!e.s||e.d&amp;&amp;!e.d[0]?new n(NaN):!e.d||r.d&amp;&amp;!r.d[0]?y(new n(r),n.precision,n.rounding):(b=!1,n.modulo==9?(t=M(r,e.abs(),0,3,1),t.s*=e.s):t=M(r,e,0,n.modulo,1),t=t.times(e),b=!0,r.minus(t))}</span>;m.naturalExponential=m.exp=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return Oi(this)}</span>;m.naturalLogarithm=m.ln=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return We(this)}</span>;m.negated=m.neg=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >new this.constructor(this);<span class="cstat-no" title="statement not covered" ></span>return e.s=-e.s,y(e)}</span>;m.plus=m.add=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t,r,n,i,o,s,a,l,u,c,p=<span class="cstat-no" title="statement not covered" >this,</span>d=<span class="cstat-no" title="statement not covered" >p.constructor;<span class="cstat-no" title="statement not covered" ></span>if(e=new d(e),!p.d||!e.d)<span class="cstat-no" title="statement not covered" >return!p.s||!e.s?e=new d(NaN):p.d||(e=new d(e.d||p.s===e.s?p:NaN)),e;<span class="cstat-no" title="statement not covered" >i</span></span>f(p.s!=e.s)<span class="cstat-no" title="statement not covered" >return e.s=-e.s,p.minus(e);<span class="cstat-no" title="statement not covered" >i</span></span>f(u=p.d,c=e.d,a=d.precision,l=d.rounding,!u[0]||!c[0])<span class="cstat-no" title="statement not covered" >return c[0]||(e=new d(p)),b?y(e,a,l):e;<span class="cstat-no" title="statement not covered" >i</span></span>f(o=re(p.e/E),n=re(e.e/E),u=u.slice(),i=o-n,i){<span class="cstat-no" title="statement not covered" >for(i&lt;0?(r=u,i=-i,s=c.length):(r=c,n=o,s=u.length),o=Math.ceil(a/E),s=o&gt;s?o+1:s+1,i&gt;s&amp;&amp;(i=s,r.length=1),r.reverse();i--;)<span class="cstat-no" title="statement not covered" >r.push(0);<span class="cstat-no" title="statement not covered" >r</span></span>.reverse()}<span class="cstat-no" title="statement not covered" ></span>f</span>or(s=u.length,i=c.length,s-i&lt;0&amp;&amp;(i=s,r=c,c=u,u=r),t=0;i;)<span class="cstat-no" title="statement not covered" >t=(u[--i]=u[i]+c[i]+t)/he|0,u[i]%=he;<span class="cstat-no" title="statement not covered" >f</span></span>or(t&amp;&amp;(u.unshift(t),++n),s=u.length;u[--s]==0;)<span class="cstat-no" title="statement not covered" >u.pop();<span class="cstat-no" title="statement not covered" >r</span></span>eturn e.d=u,e.e=on(u,n),b?y(e,a,l):e}</span>;m.precision=m.sd=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t,r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(e!==void 0&amp;&amp;e!==!!e&amp;&amp;e!==1&amp;&amp;e!==0)<span class="cstat-no" title="statement not covered" >throw Error(Ke+e);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r.d?(t=Ds(r.d),e&amp;&amp;r.e+1&gt;t&amp;&amp;(t=r.e+1)):t=NaN,t}</span>;m.round=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this,</span>t=<span class="cstat-no" title="statement not covered" >e.constructor;<span class="cstat-no" title="statement not covered" ></span>return y(new t(e),e.e+1,t.rounding)}</span>;m.sine=m.sin=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e,t,r=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >r.constructor;<span class="cstat-no" title="statement not covered" ></span>return r.isFinite()?r.isZero()?new n(r):(e=n.precision,t=n.rounding,n.precision=e+Math.max(r.e,r.sd())+E,n.rounding=1,r=_c(n,Fs(n,r)),n.precision=e,n.rounding=t,y(Me&gt;2?r.neg():r,e,t,!0)):new n(NaN)}</span>;m.squareRoot=m.sqrt=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e,t,r,n,i,o,s=<span class="cstat-no" title="statement not covered" >this,</span>a=<span class="cstat-no" title="statement not covered" >s.d,</span>l=<span class="cstat-no" title="statement not covered" >s.e,</span>u=<span class="cstat-no" title="statement not covered" >s.s,</span>c=<span class="cstat-no" title="statement not covered" >s.constructor;<span class="cstat-no" title="statement not covered" ></span>if(u!==1||!a||!a[0])<span class="cstat-no" title="statement not covered" >return new c(!u||u&lt;0&amp;&amp;(!a||a[0])?NaN:a?s:1/0);<span class="cstat-no" title="statement not covered" >f</span></span>or(b=!1,u=Math.sqrt(+s),u==0||u==1/0?(t=K(a),(t.length+l)%2==0&amp;&amp;(t+="0"),u=Math.sqrt(t),l=re((l+1)/2)-(l&lt;0||l%2),u==1/0?t="5e"+l:(t=u.toExponential(),t=t.slice(0,t.indexOf("e")+1)+l),n=new c(t)):n=new c(u.toString()),r=(l=c.precision)+3;;)<span class="cstat-no" title="statement not covered" >if(o=n,n=o.plus(M(s,o,r+2,1)).times(.5),K(o.d).slice(0,r)===(t=K(n.d)).slice(0,r))<span class="cstat-no" title="statement not covered" >if(t=t.slice(r-3,r+1),t=="9999"||!i&amp;&amp;t=="4999"){<span class="cstat-no" title="statement not covered" >if(!i&amp;&amp;(y(o,l+1,0),o.times(o).eq(s))){<span class="cstat-no" title="statement not covered" >n=o;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span>+=4,i=1}</span>else{<span class="cstat-no" title="statement not covered" >(!+t||!+t.slice(1)&amp;&amp;t.charAt(0)=="5")&amp;&amp;(y(n,l+1,1),e=!n.times(n).eq(s));<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>eturn b=!0,y(n,l,c.rounding,e)}</span>;m.tangent=m.tan=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e,t,r=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >r.constructor;<span class="cstat-no" title="statement not covered" ></span>return r.isFinite()?r.isZero()?new n(r):(e=n.precision,t=n.rounding,n.precision=e+10,n.rounding=1,r=r.sin(),r.s=1,r=M(r,new n(1).minus(r.times(r)).sqrt(),e+10,0),n.precision=e,n.rounding=t,y(Me==2||Me==4?r.neg():r,e,t,!0)):new n(NaN)}</span>;m.times=m.mul=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t,r,n,i,o,s,a,l,u,c=<span class="cstat-no" title="statement not covered" >this,</span>p=<span class="cstat-no" title="statement not covered" >c.constructor,</span>d=<span class="cstat-no" title="statement not covered" >c.d,</span>f=<span class="cstat-no" title="statement not covered" >(e=new p(e)).d;<span class="cstat-no" title="statement not covered" ></span>if(e.s*=c.s,!d||!d[0]||!f||!f[0])<span class="cstat-no" title="statement not covered" >return new p(!e.s||d&amp;&amp;!d[0]&amp;&amp;!f||f&amp;&amp;!f[0]&amp;&amp;!d?NaN:!d||!f?e.s/0:e.s*0);<span class="cstat-no" title="statement not covered" >f</span></span>or(r=re(c.e/E)+re(e.e/E),l=d.length,u=f.length,l&lt;u&amp;&amp;(o=d,d=f,f=o,s=l,l=u,u=s),o=[],s=l+u,n=s;n--;)<span class="cstat-no" title="statement not covered" >o.push(0);<span class="cstat-no" title="statement not covered" >f</span></span>or(n=u;--n&gt;=0;){<span class="cstat-no" title="statement not covered" >for(t=0,i=l+n;i&gt;n;)<span class="cstat-no" title="statement not covered" >a=o[i]+f[n]*d[i-n-1]+t,o[i--]=a%he|0,t=a/he|0;<span class="cstat-no" title="statement not covered" >o</span></span>[i]=(o[i]+t)%he|0}<span class="cstat-no" title="statement not covered" ></span>f</span>or(;!o[--s];)<span class="cstat-no" title="statement not covered" >o.pop();<span class="cstat-no" title="statement not covered" >r</span></span>eturn t?++r:o.shift(),e.d=o,e.e=on(o,r),b?y(e,p.precision,p.rounding):e}</span>;m.toBinary=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return Di(this,2,e,t)}</span>;m.toDecimalPlaces=m.toDP=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >r.constructor;<span class="cstat-no" title="statement not covered" ></span>return r=new n(r),e===void 0?r:(se(e,0,Ye),t===void 0?t=n.rounding:se(t,0,8),y(r,e+r.e+1,t))}</span>;m.toExponential=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r,n=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >n.constructor;<span class="cstat-no" title="statement not covered" ></span>return e===void 0?r=xe(n,!0):(se(e,0,Ye),t===void 0?t=i.rounding:se(t,0,8),n=y(new i(n),e+1,t),r=xe(n,!0,e+1)),n.isNeg()&amp;&amp;!n.isZero()?"-"+r:r}</span>;m.toFixed=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r,n,i=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >i.constructor;<span class="cstat-no" title="statement not covered" ></span>return e===void 0?r=xe(i):(se(e,0,Ye),t===void 0?t=o.rounding:se(t,0,8),n=y(new o(i),e+i.e+1,t),r=xe(n,!1,e+n.e+1)),i.isNeg()&amp;&amp;!i.isZero()?"-"+r:r}</span>;m.toFraction=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t,r,n,i,o,s,a,l,u,c,p,d,f=<span class="cstat-no" title="statement not covered" >this,</span>g=<span class="cstat-no" title="statement not covered" >f.d,</span>h=<span class="cstat-no" title="statement not covered" >f.constructor;<span class="cstat-no" title="statement not covered" ></span>if(!g)<span class="cstat-no" title="statement not covered" >return new h(f);<span class="cstat-no" title="statement not covered" >i</span></span>f(u=r=new h(1),n=l=new h(0),t=new h(n),o=t.e=Ds(g)-f.e-1,s=o%E,t.d[0]=G(10,s&lt;0?E+s:s),e==null)<span class="cstat-no" title="statement not covered" >e=o&gt;0?t:u;e</span>lse{<span class="cstat-no" title="statement not covered" >if(a=new h(e),!a.isInt()||a.lt(u))<span class="cstat-no" title="statement not covered" >throw Error(Ke+a);<span class="cstat-no" title="statement not covered" >e</span></span>=a.gt(t)?o&gt;0?t:u:a}<span class="cstat-no" title="statement not covered" ></span>f</span>or(b=!1,a=new h(K(g)),c=h.precision,h.precision=o=g.length*E*2;p=M(a,t,0,1,1),i=r.plus(p.times(n)),i.cmp(e)!=1;)<span class="cstat-no" title="statement not covered" >r=n,n=i,i=u,u=l.plus(p.times(i)),l=i,i=t,t=a.minus(p.times(i)),a=i;<span class="cstat-no" title="statement not covered" >r</span></span>eturn i=M(e.minus(r),n,0,1,1),l=l.plus(i.times(u)),r=r.plus(i.times(n)),l.s=u.s=f.s,d=M(u,n,o,1).minus(f).abs().cmp(M(l,r,o,1).minus(f).abs())&lt;1?[u,n]:[l,r],h.precision=c,b=!0,d}</span>;m.toHexadecimal=m.toHex=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return Di(this,16,e,t)}</span>;m.toNearest=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >r.constructor;<span class="cstat-no" title="statement not covered" ></span>if(r=new n(r),e==null){<span class="cstat-no" title="statement not covered" >if(!r.d)<span class="cstat-no" title="statement not covered" >return r;<span class="cstat-no" title="statement not covered" >e</span></span>=new n(1),t=n.rounding}</span>else{<span class="cstat-no" title="statement not covered" >if(e=new n(e),t===void 0?t=n.rounding:se(t,0,8),!r.d)<span class="cstat-no" title="statement not covered" >return e.s?r:e;<span class="cstat-no" title="statement not covered" >i</span></span>f(!e.d)<span class="cstat-no" title="statement not covered" >return e.s&amp;&amp;(e.s=r.s),e}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn e.d[0]?(b=!1,r=M(r,e,0,t,1).times(e),b=!0,y(r)):(e.s=r.s,r=e),r}</span>;m.toNumber=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return+this}</span>;m.toOctal=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return Di(this,8,e,t)}</span>;m.toPower=m.pow=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t,r,n,i,o,s,a=<span class="cstat-no" title="statement not covered" >this,</span>l=<span class="cstat-no" title="statement not covered" >a.constructor,</span>u=<span class="cstat-no" title="statement not covered" >+(e=new l(e));<span class="cstat-no" title="statement not covered" ></span>if(!a.d||!e.d||!a.d[0]||!e.d[0])<span class="cstat-no" title="statement not covered" >return new l(G(+a,u));<span class="cstat-no" title="statement not covered" >i</span></span>f(a=new l(a),a.eq(1))<span class="cstat-no" title="statement not covered" >return a;<span class="cstat-no" title="statement not covered" >i</span></span>f(n=l.precision,o=l.rounding,e.eq(1))<span class="cstat-no" title="statement not covered" >return y(a,n,o);<span class="cstat-no" title="statement not covered" >i</span></span>f(t=re(e.e/E),t&gt;=e.d.length-1&amp;&amp;(r=u&lt;0?-u:u)&lt;=Ic)<span class="cstat-no" title="statement not covered" >return i=_s(l,a,r,n),e.s&lt;0?new l(1).div(i):y(i,n,o);<span class="cstat-no" title="statement not covered" >i</span></span>f(s=a.s,s&lt;0){<span class="cstat-no" title="statement not covered" >if(t&lt;e.d.length-1)<span class="cstat-no" title="statement not covered" >return new l(NaN);<span class="cstat-no" title="statement not covered" >i</span></span>f(e.d[t]&amp;1||(s=1),a.e==0&amp;&amp;a.d[0]==1&amp;&amp;a.d.length==1)<span class="cstat-no" title="statement not covered" >return a.s=s,a}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn r=G(+a,u),t=r==0||!isFinite(r)?re(u*(Math.log("0."+K(a.d))/Math.LN10+a.e+1)):new l(r+"").e,t&gt;l.maxE+1||t&lt;l.minE-1?new l(t&gt;0?s/0:0):(b=!1,l.rounding=a.s=1,r=Math.min(12,(t+"").length),i=Oi(e.times(We(a,n+r)),n),i.d&amp;&amp;(i=y(i,n+5,1),rr(i.d,n,o)&amp;&amp;(t=n+10,i=y(Oi(e.times(We(a,t+r)),t),t+5,1),+K(i.d).slice(n+1,n+15)+1==1e14&amp;&amp;(i=y(i,n+1,0)))),i.s=s,b=!0,l.rounding=o,y(i,n,o))}</span>;m.toPrecision=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r,n=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >n.constructor;<span class="cstat-no" title="statement not covered" ></span>return e===void 0?r=xe(n,n.e&lt;=i.toExpNeg||n.e&gt;=i.toExpPos):(se(e,1,Ye),t===void 0?t=i.rounding:se(t,0,8),n=y(new i(n),e,t),r=xe(n,e&lt;=n.e||n.e&lt;=i.toExpNeg,e)),n.isNeg()&amp;&amp;!n.isZero()?"-"+r:r}</span>;m.toSignificantDigits=m.toSD=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >r.constructor;<span class="cstat-no" title="statement not covered" ></span>return e===void 0?(e=n.precision,t=n.rounding):(se(e,1,Ye),t===void 0?t=n.rounding:se(t,0,8)),y(new n(r),e,t)}</span>;m.toString=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this,</span>t=<span class="cstat-no" title="statement not covered" >e.constructor,</span>r=<span class="cstat-no" title="statement not covered" >xe(e,e.e&lt;=t.toExpNeg||e.e&gt;=t.toExpPos);<span class="cstat-no" title="statement not covered" ></span>return e.isNeg()&amp;&amp;!e.isZero()?"-"+r:r}</span>;m.truncated=m.trunc=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return y(new this.constructor(this),this.e+1,1)}</span>;m.valueOf=m.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this,</span>t=<span class="cstat-no" title="statement not covered" >e.constructor,</span>r=<span class="cstat-no" title="statement not covered" >xe(e,e.e&lt;=t.toExpNeg||e.e&gt;=t.toExpPos);<span class="cstat-no" title="statement not covered" ></span>return e.isNeg()?"-"+r:r}</span>;function <span class="fstat-no" title="function not covered" >K(</span>e){var t,r,n,i=<span class="cstat-no" title="statement not covered" >e.length-1,</span>o=<span class="cstat-no" title="statement not covered" >"",</span>s=<span class="cstat-no" title="statement not covered" >e[0];<span class="cstat-no" title="statement not covered" ></span>if(i&gt;0){<span class="cstat-no" title="statement not covered" >for(o+=s,t=1;t&lt;i;t++)<span class="cstat-no" title="statement not covered" >n=e[t]+"",r=E-n.length,r&amp;&amp;(o+=He(r)),o+=n;<span class="cstat-no" title="statement not covered" >s</span></span>=e[t],n=s+"",r=E-n.length,r&amp;&amp;(o+=He(r))}</span>else <span class="cstat-no" title="statement not covered" >if(s===0)<span class="cstat-no" title="statement not covered" >return"0";<span class="cstat-no" title="statement not covered" >f</span></span></span>or(;s%10===0;)<span class="cstat-no" title="statement not covered" >s/=10;<span class="cstat-no" title="statement not covered" >r</span></span>eturn o+s}</span>function <span class="fstat-no" title="function not covered" >se(</span>e,t,r){<span class="cstat-no" title="statement not covered" >if(e!==~~e||e&lt;t||e&gt;r)<span class="cstat-no" title="statement not covered" >throw Error(Ke+e)}</span></span>function <span class="fstat-no" title="function not covered" >rr(</span>e,t,r,n){var i,o,s,a;<span class="cstat-no" title="statement not covered" >for(o=e[0];o&gt;=10;o/=10)<span class="cstat-no" title="statement not covered" >--t;<span class="cstat-no" title="statement not covered" >r</span></span>eturn--t&lt;0?(t+=E,i=0):(i=Math.ceil((t+1)/E),t%=E),o=G(10,E-t),a=e[i]%o|0,n==null?t&lt;3?(t==0?a=a/100|0:t==1&amp;&amp;(a=a/10|0),s=r&lt;4&amp;&amp;a==99999||r&gt;3&amp;&amp;a==49999||a==5e4||a==0):s=(r&lt;4&amp;&amp;a+1==o||r&gt;3&amp;&amp;a+1==o/2)&amp;&amp;(e[i+1]/o/100|0)==G(10,t-2)-1||(a==o/2||a==0)&amp;&amp;(e[i+1]/o/100|0)==0:t&lt;4?(t==0?a=a/1e3|0:t==1?a=a/100|0:t==2&amp;&amp;(a=a/10|0),s=(n||r&lt;4)&amp;&amp;a==9999||!n&amp;&amp;r&gt;3&amp;&amp;a==4999):s=((n||r&lt;4)&amp;&amp;a+1==o||!n&amp;&amp;r&gt;3&amp;&amp;a+1==o/2)&amp;&amp;(e[i+1]/o/1e3|0)==G(10,t-3)-1,s}</span>function <span class="fstat-no" title="function not covered" >Xr(</span>e,t,r){<span class="cstat-no" title="statement not covered" >for(var n,i=<span class="cstat-no" title="statement not covered" >[0],</span>o,s=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" >e.length;</span>s&lt;a;){<span class="cstat-no" title="statement not covered" >for(o=i.length;o--;)<span class="cstat-no" title="statement not covered" >i[o]*=t;<span class="cstat-no" title="statement not covered" >f</span></span>or(i[0]+=Si.indexOf(e.charAt(s++)),n=0;n&lt;i.length;n++)<span class="cstat-no" title="statement not covered" >i[n]&gt;r-1&amp;&amp;(i[n+1]===void 0&amp;&amp;(i[n+1]=0),i[n+1]+=i[n]/r|0,i[n]%=r)}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn i.reverse()}</span>function <span class="fstat-no" title="function not covered" >kc(</span>e,t){var r,n,i;<span class="cstat-no" title="statement not covered" >if(t.isZero())<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >n</span></span>=t.d.length,n&lt;32?(r=Math.ceil(n/3),i=(1/sn(4,r)).toString()):(r=16,i="2.3283064365386962890625e-10"),e.precision+=r,t=Et(e,1,t.times(i),new e(1));<span class="cstat-no" title="statement not covered" >f</span>or(var o=<span class="cstat-no" title="statement not covered" >r;</span>o--;){var s=<span class="cstat-no" title="statement not covered" >t.times(t);<span class="cstat-no" title="statement not covered" ></span>t=s.times(s).minus(s).times(8).plus(1)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e.precision-=r,t}</span>var M=function(){function <span class="fstat-no" title="function not covered" >e(</span>n,i,o){var s,a=<span class="cstat-no" title="statement not covered" >0,</span>l=<span class="cstat-no" title="statement not covered" >n.length;<span class="cstat-no" title="statement not covered" ></span>for(n=n.slice();l--;)<span class="cstat-no" title="statement not covered" >s=n[l]*i+a,n[l]=s%o|0,a=s/o|0;<span class="cstat-no" title="statement not covered" >r</span></span>eturn a&amp;&amp;n.unshift(a),n}</span>function <span class="fstat-no" title="function not covered" >t(</span>n,i,o,s){var a,l;<span class="cstat-no" title="statement not covered" >if(o!=s)<span class="cstat-no" title="statement not covered" >l=o&gt;s?1:-1;e</span>lse <span class="cstat-no" title="statement not covered" >for(a=l=0;a&lt;o;a++)<span class="cstat-no" title="statement not covered" >if(n[a]!=i[a]){<span class="cstat-no" title="statement not covered" >l=n[a]&gt;i[a]?1:-1;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>eturn l}</span>function <span class="fstat-no" title="function not covered" >r(</span>n,i,o,s){<span class="cstat-no" title="statement not covered" >for(var a=<span class="cstat-no" title="statement not covered" >0;</span>o--;)<span class="cstat-no" title="statement not covered" >n[o]-=a,a=n[o]&lt;i[o]?1:0,n[o]=a*s+n[o]-i[o];<span class="cstat-no" title="statement not covered" >f</span></span>or(;!n[0]&amp;&amp;n.length&gt;1;)<span class="cstat-no" title="statement not covered" >n.shift()}</span></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(n,i,o,s,a,l){var u,c,p,d,f,g,h,O,P,C,R,k,A,ue,jt,U,oe,Oe,Y,pt,Lr=<span class="cstat-no" title="statement not covered" >n.constructor,</span>jn=<span class="cstat-no" title="statement not covered" >n.s==i.s?1:-1,</span>z=<span class="cstat-no" title="statement not covered" >n.d,</span>N=<span class="cstat-no" title="statement not covered" >i.d;<span class="cstat-no" title="statement not covered" ></span>if(!z||!z[0]||!N||!N[0])<span class="cstat-no" title="statement not covered" >return new Lr(!n.s||!i.s||(z?N&amp;&amp;z[0]==N[0]:!N)?NaN:z&amp;&amp;z[0]==0||!N?jn*0:jn/0);<span class="cstat-no" title="statement not covered" >f</span></span>or(l?(f=1,c=n.e-i.e):(l=he,f=E,c=re(n.e/f)-re(i.e/f)),Y=N.length,oe=z.length,P=new Lr(jn),C=P.d=[],p=0;N[p]==(z[p]||0);p++);<span class="cstat-no" title="statement not covered" >i</span>f(N[p]&gt;(z[p]||0)&amp;&amp;c--,o==null?(ue=o=Lr.precision,s=Lr.rounding):a?ue=o+(n.e-i.e)+1:ue=o,ue&lt;0)<span class="cstat-no" title="statement not covered" >C.push(1),g=!0;e</span>lse{<span class="cstat-no" title="statement not covered" >if(ue=ue/f+2|0,p=0,Y==1){<span class="cstat-no" title="statement not covered" >for(d=0,N=N[0],ue++;(p&lt;oe||d)&amp;&amp;ue--;p++)<span class="cstat-no" title="statement not covered" >jt=d*l+(z[p]||0),C[p]=jt/N|0,d=jt%N|0;<span class="cstat-no" title="statement not covered" >g</span></span>=d||p&lt;oe}</span>else{<span class="cstat-no" title="statement not covered" >for(d=l/(N[0]+1)|0,d&gt;1&amp;&amp;(N=e(N,d,l),z=e(z,d,l),Y=N.length,oe=z.length),U=Y,R=z.slice(0,Y),k=R.length;k&lt;Y;)<span class="cstat-no" title="statement not covered" >R[k++]=0;<span class="cstat-no" title="statement not covered" >p</span></span>t=N.slice(),pt.unshift(0),Oe=N[0],N[1]&gt;=l/2&amp;&amp;++Oe;<span class="cstat-no" title="statement not covered" >d</span>o <span class="cstat-no" title="statement not covered" >d=0,u=t(N,R,Y,k),u&lt;0?(A=R[0],Y!=k&amp;&amp;(A=A*l+(R[1]||0)),d=A/Oe|0,d&gt;1?(d&gt;=l&amp;&amp;(d=l-1),h=e(N,d,l),O=h.length,k=R.length,u=t(h,R,O,k),u==1&amp;&amp;(d--,r(h,Y&lt;O?pt:N,O,l))):(d==0&amp;&amp;(u=d=1),h=N.slice()),O=h.length,O&lt;k&amp;&amp;h.unshift(0),r(R,h,k,l),u==-1&amp;&amp;(k=R.length,u=t(N,R,Y,k),u&lt;1&amp;&amp;(d++,r(R,Y&lt;k?pt:N,k,l))),k=R.length):u===0&amp;&amp;(d++,R=[0]),C[p++]=d,u&amp;&amp;R[0]?R[k++]=z[U]||0:(R=[z[U]],k=1);w</span>hile((U++&lt;oe||R[0]!==void 0)&amp;&amp;ue--);<span class="cstat-no" title="statement not covered" >g</span>=R[0]!==void 0}<span class="cstat-no" title="statement not covered" ></span>C</span>[0]||C.shift()}<span class="cstat-no" title="statement not covered" ></span>i</span>f(f==1)<span class="cstat-no" title="statement not covered" >P.e=c,Ss=g;e</span>lse{<span class="cstat-no" title="statement not covered" >for(p=1,d=C[0];d&gt;=10;d/=10)<span class="cstat-no" title="statement not covered" >p++;<span class="cstat-no" title="statement not covered" >P</span></span>.e=p+c*f-1,y(P,a?o+P.e+1:o,s,g)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn P}</span>}();function <span class="fstat-no" title="function not covered" >y(</span>e,t,r,n){var i,o,s,a,l,u,c,p,d,f=<span class="cstat-no" title="statement not covered" >e.constructor;<span class="cstat-no" title="statement not covered" ></span>e:<span class="cstat-no" title="statement not covered" >if(t!=null){<span class="cstat-no" title="statement not covered" >if(p=e.d,!p)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >f</span></span>or(i=1,a=p[0];a&gt;=10;a/=10)<span class="cstat-no" title="statement not covered" >i++;<span class="cstat-no" title="statement not covered" >i</span></span>f(o=t-i,o&lt;0)<span class="cstat-no" title="statement not covered" >o+=E,s=t,c=p[d=0],l=c/G(10,i-s-1)%10|0;e</span>lse <span class="cstat-no" title="statement not covered" >if(d=Math.ceil((o+1)/E),a=p.length,d&gt;=a)<span class="cstat-no" title="statement not covered" >if(n){<span class="cstat-no" title="statement not covered" >for(;a++&lt;=d;)<span class="cstat-no" title="statement not covered" >p.push(0);<span class="cstat-no" title="statement not covered" >c</span></span>=l=0,i=1,o%=E,s=o-E+1}</span>else <span class="cstat-no" title="statement not covered" >break e;e</span></span>lse{<span class="cstat-no" title="statement not covered" >for(c=a=p[d],i=1;a&gt;=10;a/=10)<span class="cstat-no" title="statement not covered" >i++;<span class="cstat-no" title="statement not covered" >o</span></span>%=E,s=o-E+i,l=s&lt;0?0:c/G(10,i-s-1)%10|0}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(n=n||t&lt;0||p[d+1]!==void 0||(s&lt;0?c:c%G(10,i-s-1)),u=r&lt;4?(l||n)&amp;&amp;(r==0||r==(e.s&lt;0?3:2)):l&gt;5||l==5&amp;&amp;(r==4||n||r==6&amp;&amp;(o&gt;0?s&gt;0?c/G(10,i-s):0:p[d-1])%10&amp;1||r==(e.s&lt;0?8:7)),t&lt;1||!p[0])<span class="cstat-no" title="statement not covered" >return p.length=0,u?(t-=e.e+1,p[0]=G(10,(E-t%E)%E),e.e=-t||0):p[0]=e.e=0,e;<span class="cstat-no" title="statement not covered" >i</span></span>f(o==0?(p.length=d,a=1,d--):(p.length=d+1,a=G(10,E-o),p[d]=s&gt;0?(c/G(10,i-s)%G(10,s)|0)*a:0),u)<span class="cstat-no" title="statement not covered" >for(;;)<span class="cstat-no" title="statement not covered" >if(d==0){<span class="cstat-no" title="statement not covered" >for(o=1,s=p[0];s&gt;=10;s/=10)<span class="cstat-no" title="statement not covered" >o++;<span class="cstat-no" title="statement not covered" >f</span></span>or(s=p[0]+=a,a=1;s&gt;=10;s/=10)<span class="cstat-no" title="statement not covered" >a++;<span class="cstat-no" title="statement not covered" >o</span></span>!=a&amp;&amp;(e.e++,p[0]==he&amp;&amp;(p[0]=1));<span class="cstat-no" title="statement not covered" >b</span>reak}</span>else{<span class="cstat-no" title="statement not covered" >if(p[d]+=a,p[d]!=he)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >p</span></span>[d--]=0,a=1}<span class="cstat-no" title="statement not covered" ></span>f</span></span></span>or(o=p.length;p[--o]===0;)<span class="cstat-no" title="statement not covered" >p.pop()}<span class="cstat-no" title="statement not covered" ></span></span>r</span></span>eturn b&amp;&amp;(e.e&gt;f.maxE?(e.d=null,e.e=NaN):e.e&lt;f.minE&amp;&amp;(e.e=0,e.d=[0])),e}</span>function <span class="fstat-no" title="function not covered" >xe(</span>e,t,r){<span class="cstat-no" title="statement not covered" >if(!e.isFinite())<span class="cstat-no" title="statement not covered" >return Ls(e);v</span></span>ar n,i=<span class="cstat-no" title="statement not covered" >e.e,</span>o=<span class="cstat-no" title="statement not covered" >K(e.d),</span>s=<span class="cstat-no" title="statement not covered" >o.length;<span class="cstat-no" title="statement not covered" ></span>return t?(r&amp;&amp;(n=r-s)&gt;0?o=o.charAt(0)+"."+o.slice(1)+He(n):s&gt;1&amp;&amp;(o=o.charAt(0)+"."+o.slice(1)),o=o+(e.e&lt;0?"e":"e+")+e.e):i&lt;0?(o="0."+He(-i-1)+o,r&amp;&amp;(n=r-s)&gt;0&amp;&amp;(o+=He(n))):i&gt;=s?(o+=He(i+1-s),r&amp;&amp;(n=r-i-1)&gt;0&amp;&amp;(o=o+"."+He(n))):((n=i+1)&lt;s&amp;&amp;(o=o.slice(0,n)+"."+o.slice(n)),r&amp;&amp;(n=r-s)&gt;0&amp;&amp;(i+1===s&amp;&amp;(o+="."),o+=He(n))),o}</span>function <span class="fstat-no" title="function not covered" >on(</span>e,t){var r=<span class="cstat-no" title="statement not covered" >e[0];<span class="cstat-no" title="statement not covered" ></span>for(t*=E;r&gt;=10;r/=10)<span class="cstat-no" title="statement not covered" >t++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>function <span class="fstat-no" title="function not covered" >rn(</span>e,t,r){<span class="cstat-no" title="statement not covered" >if(t&gt;Oc)<span class="cstat-no" title="statement not covered" >throw b=!0,r&amp;&amp;(e.precision=r),Error(As);<span class="cstat-no" title="statement not covered" >r</span></span>eturn y(new e(en),t,1,!0)}</span>function <span class="fstat-no" title="function not covered" >ge(</span>e,t,r){<span class="cstat-no" title="statement not covered" >if(t&gt;Ii)<span class="cstat-no" title="statement not covered" >throw Error(As);<span class="cstat-no" title="statement not covered" >r</span></span>eturn y(new e(tn),t,r,!0)}</span>function <span class="fstat-no" title="function not covered" >Ds(</span>e){var t=<span class="cstat-no" title="statement not covered" >e.length-1,</span>r=<span class="cstat-no" title="statement not covered" >t*E+1;<span class="cstat-no" title="statement not covered" ></span>if(t=e[t],t){<span class="cstat-no" title="statement not covered" >for(;t%10==0;t/=10)<span class="cstat-no" title="statement not covered" >r--;<span class="cstat-no" title="statement not covered" >f</span></span>or(t=e[0];t&gt;=10;t/=10)<span class="cstat-no" title="statement not covered" >r++}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn r}</span>function <span class="fstat-no" title="function not covered" >He(</span>e){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >"";</span>e--;)<span class="cstat-no" title="statement not covered" >t+="0";<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>function <span class="fstat-no" title="function not covered" >_s(</span>e,t,r,n){var i,o=<span class="cstat-no" title="statement not covered" >new e(1),</span>s=<span class="cstat-no" title="statement not covered" >Math.ceil(n/E+4);<span class="cstat-no" title="statement not covered" ></span>for(b=!1;;){<span class="cstat-no" title="statement not covered" >if(r%2&amp;&amp;(o=o.times(t),Rs(o.d,s)&amp;&amp;(i=!0)),r=re(r/2),r===0){<span class="cstat-no" title="statement not covered" >r=o.d.length-1,i&amp;&amp;o.d[r]===0&amp;&amp;++o.d[r];<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>t</span>=t.times(t),Rs(t.d,s)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn b=!0,o}</span>function <span class="fstat-no" title="function not covered" >Ts(</span>e){<span class="cstat-no" title="statement not covered" >return e.d[e.d.length-1]&amp;1}</span>function <span class="fstat-no" title="function not covered" >Ns(</span>e,t,r){<span class="cstat-no" title="statement not covered" >for(var n,i=<span class="cstat-no" title="statement not covered" >new e(t[0]),</span>o=<span class="cstat-no" title="statement not covered" >0;</span>++o&lt;t.length;)<span class="cstat-no" title="statement not covered" >if(n=new e(t[o]),n.s)<span class="cstat-no" title="statement not covered" >i[r](n)&amp;&amp;(i=n);e</span>lse{<span class="cstat-no" title="statement not covered" >i=n;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn i}</span>function <span class="fstat-no" title="function not covered" >Oi(</span>e,t){var r,n,i,o,s,a,l,u=<span class="cstat-no" title="statement not covered" >0,</span>c=<span class="cstat-no" title="statement not covered" >0,</span>p=<span class="cstat-no" title="statement not covered" >0,</span>d=<span class="cstat-no" title="statement not covered" >e.constructor,</span>f=<span class="cstat-no" title="statement not covered" >d.rounding,</span>g=<span class="cstat-no" title="statement not covered" >d.precision;<span class="cstat-no" title="statement not covered" ></span>if(!e.d||!e.d[0]||e.e&gt;17)<span class="cstat-no" title="statement not covered" >return new d(e.d?e.d[0]?e.s&lt;0?0:1/0:1:e.s?e.s&lt;0?0:e:NaN);<span class="cstat-no" title="statement not covered" >f</span></span>or(t==null?(b=!1,l=g):l=t,a=new d(.03125);e.e&gt;-2;)<span class="cstat-no" title="statement not covered" >e=e.times(a),p+=5;<span class="cstat-no" title="statement not covered" >f</span></span>or(n=Math.log(G(2,p))/Math.LN10*2+5|0,l+=n,r=o=s=new d(1),d.precision=l;;){<span class="cstat-no" title="statement not covered" >if(o=y(o.times(e),l,1),r=r.times(++c),a=s.plus(M(o,r,l,1)),K(a.d).slice(0,l)===K(s.d).slice(0,l)){<span class="cstat-no" title="statement not covered" >for(i=p;i--;)<span class="cstat-no" title="statement not covered" >s=y(s.times(s),l,1);<span class="cstat-no" title="statement not covered" >i</span></span>f(t==null)<span class="cstat-no" title="statement not covered" >if(u&lt;3&amp;&amp;rr(s.d,l-n,f,u))<span class="cstat-no" title="statement not covered" >d.precision=l+=10,r=o=a=new d(1),c=0,u++;e</span>lse <span class="cstat-no" title="statement not covered" >return y(s,d.precision=g,f,b=!0);e</span></span>lse <span class="cstat-no" title="statement not covered" >return d.precision=g,s}<span class="cstat-no" title="statement not covered" ></span></span>s</span>=a}</span>}</span>function <span class="fstat-no" title="function not covered" >We(</span>e,t){var r,n,i,o,s,a,l,u,c,p,d,f=<span class="cstat-no" title="statement not covered" >1,</span>g=<span class="cstat-no" title="statement not covered" >10,</span>h=<span class="cstat-no" title="statement not covered" >e,</span>O=<span class="cstat-no" title="statement not covered" >h.d,</span>P=<span class="cstat-no" title="statement not covered" >h.constructor,</span>C=<span class="cstat-no" title="statement not covered" >P.rounding,</span>R=<span class="cstat-no" title="statement not covered" >P.precision;<span class="cstat-no" title="statement not covered" ></span>if(h.s&lt;0||!O||!O[0]||!h.e&amp;&amp;O[0]==1&amp;&amp;O.length==1)<span class="cstat-no" title="statement not covered" >return new P(O&amp;&amp;!O[0]?-1/0:h.s!=1?NaN:O?0:h);<span class="cstat-no" title="statement not covered" >i</span></span>f(t==null?(b=!1,c=R):c=t,P.precision=c+=g,r=K(O),n=r.charAt(0),Math.abs(o=h.e)&lt;15e14){<span class="cstat-no" title="statement not covered" >for(;n&lt;7&amp;&amp;n!=1||n==1&amp;&amp;r.charAt(1)&gt;3;)<span class="cstat-no" title="statement not covered" >h=h.times(e),r=K(h.d),n=r.charAt(0),f++;<span class="cstat-no" title="statement not covered" >o</span></span>=h.e,n&gt;1?(h=new P("0."+r),o++):h=new P(n+"."+r.slice(1))}</span>else <span class="cstat-no" title="statement not covered" >return u=rn(P,c+2,R).times(o+""),h=We(new P(n+"."+r.slice(1)),c-g).plus(u),P.precision=R,t==null?y(h,R,C,b=!0):h;<span class="cstat-no" title="statement not covered" >f</span></span>or(p=h,l=s=h=M(h.minus(1),h.plus(1),c,1),d=y(h.times(h),c,1),i=3;;){<span class="cstat-no" title="statement not covered" >if(s=y(s.times(d),c,1),u=l.plus(M(s,new P(i),c,1)),K(u.d).slice(0,c)===K(l.d).slice(0,c))<span class="cstat-no" title="statement not covered" >if(l=l.times(2),o!==0&amp;&amp;(l=l.plus(rn(P,c+2,R).times(o+""))),l=M(l,new P(f),c,1),t==null)<span class="cstat-no" title="statement not covered" >if(rr(l.d,c-g,C,a))<span class="cstat-no" title="statement not covered" >P.precision=c+=g,u=s=h=M(p.minus(1),p.plus(1),c,1),d=y(h.times(h),c,1),i=a=1;e</span>lse <span class="cstat-no" title="statement not covered" >return y(l,P.precision=R,C,b=!0);e</span></span>lse <span class="cstat-no" title="statement not covered" >return P.precision=R,l;<span class="cstat-no" title="statement not covered" >l</span></span></span>=u,i+=2}</span>}</span>function <span class="fstat-no" title="function not covered" >Ls(</span>e){<span class="cstat-no" title="statement not covered" >return String(e.s*e.s/0)}</span>function ki(e,t){var r,n,i;for((r=t.indexOf("."))&gt;-1&amp;&amp;(t=t.replace(".","")),(n=t.search(/e/i))&gt;0?(<span class="branch-0 cbranch-no" title="branch not covered" >r&lt;0&amp;&amp;(r=n),r+=+t.slice(n+1),t=t.substring(0,n))</span>:r&lt;0&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >r=t.length)</span>,n=0;t.charCodeAt(n)===48;n++);for(i=t.length;t.charCodeAt(i-1)===48;--i);if(t=t.slice(n,i),t){if(i-=n,e.e=r=r-n-1,e.d=[],n=(r+1)%E,r&lt;0&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >n+=E)</span>,n&lt;i){for(n&amp;&amp;e.d.push(+t.slice(0,n)),i-=E;n&lt;i;)e.d.push(+t.slice(n,n+=E));t=t.slice(n),n=E-t.length}else <span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="else path not taken" >E</span>n-=i;f</span>or(;n--;)t+="0";e.d.push(+t),b&amp;&amp;(e.e&gt;e.constructor.maxE?(<span class="branch-0 cbranch-no" title="branch not covered" >e.d=null,e.e=NaN)</span>:e.e&lt;e.constructor.minE&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >e.e=0,e.d=[0])</span>)}else <span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="else path not taken" >E</span>e.e=0,e.d=[0];r</span>eturn e}function <span class="fstat-no" title="function not covered" >Dc(</span>e,t){var r,n,i,o,s,a,l,u,c;<span class="cstat-no" title="statement not covered" >if(t.indexOf("_")&gt;-1){<span class="cstat-no" title="statement not covered" >if(t=t.replace(/(\d)_(?=\d)/g,"$1"),ks.test(t))<span class="cstat-no" title="statement not covered" >return ki(e,t)}</span></span>else <span class="cstat-no" title="statement not covered" >if(t==="Infinity"||t==="NaN")<span class="cstat-no" title="statement not covered" >return+t||(e.s=NaN),e.e=NaN,e.d=null,e;<span class="cstat-no" title="statement not covered" >i</span></span></span>f(Sc.test(t))<span class="cstat-no" title="statement not covered" >r=16,t=t.toLowerCase();e</span>lse <span class="cstat-no" title="statement not covered" >if(Cc.test(t))<span class="cstat-no" title="statement not covered" >r=2;e</span>lse <span class="cstat-no" title="statement not covered" >if(Ac.test(t))<span class="cstat-no" title="statement not covered" >r=8;e</span>lse <span class="cstat-no" title="statement not covered" >throw Error(Ke+t);<span class="cstat-no" title="statement not covered" >f</span></span></span></span>or(o=t.search(/p/i),o&gt;0?(l=+t.slice(o+1),t=t.substring(2,o)):t=t.slice(2),o=t.indexOf("."),s=o&gt;=0,n=e.constructor,s&amp;&amp;(t=t.replace(".",""),a=t.length,o=a-o,i=_s(n,new n(r),o,o*2)),u=Xr(t,r,he),c=u.length-1,o=c;u[o]===0;--o)<span class="cstat-no" title="statement not covered" >u.pop();<span class="cstat-no" title="statement not covered" >r</span></span>eturn o&lt;0?new n(e.s*0):(e.e=on(u,c),e.d=u,b=!1,s&amp;&amp;(e=M(e,i,a*4)),l&amp;&amp;(e=e.times(Math.abs(l)&lt;54?G(2,l):it.pow(2,l))),b=!0,e)}</span>function <span class="fstat-no" title="function not covered" >_c(</span>e,t){var r,n=<span class="cstat-no" title="statement not covered" >t.d.length;<span class="cstat-no" title="statement not covered" ></span>if(n&lt;3)<span class="cstat-no" title="statement not covered" >return t.isZero()?t:Et(e,2,t,t);<span class="cstat-no" title="statement not covered" >r</span></span>=1.4*Math.sqrt(n),r=r&gt;16?16:r|0,t=t.times(1/sn(5,r)),t=Et(e,2,t,t);<span class="cstat-no" title="statement not covered" >f</span>or(var i,o=<span class="cstat-no" title="statement not covered" >new e(5),</span>s=<span class="cstat-no" title="statement not covered" >new e(16),</span>a=<span class="cstat-no" title="statement not covered" >new e(20);</span>r--;)<span class="cstat-no" title="statement not covered" >i=t.times(t),t=t.times(o.plus(i.times(s.times(i).minus(a))));<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>function <span class="fstat-no" title="function not covered" >Et(</span>e,t,r,n,i){var o,s,a,l,u=<span class="cstat-no" title="statement not covered" >1,</span>c=<span class="cstat-no" title="statement not covered" >e.precision,</span>p=<span class="cstat-no" title="statement not covered" >Math.ceil(c/E);<span class="cstat-no" title="statement not covered" ></span>for(b=!1,l=r.times(r),a=new e(n);;){<span class="cstat-no" title="statement not covered" >if(s=M(a.times(l),new e(t++*t++),c,1),a=i?n.plus(s):n.minus(s),n=M(s.times(l),new e(t++*t++),c,1),s=a.plus(n),s.d[p]!==void 0){<span class="cstat-no" title="statement not covered" >for(o=p;s.d[o]===a.d[o]&amp;&amp;o--;);<span class="cstat-no" title="statement not covered" >i</span>f(o==-1)<span class="cstat-no" title="statement not covered" >break}<span class="cstat-no" title="statement not covered" ></span></span>o</span>=a,a=n,n=s,s=o,u++}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn b=!0,s.d.length=p+1,s}</span>function <span class="fstat-no" title="function not covered" >sn(</span>e,t){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >e;</span>--t;)<span class="cstat-no" title="statement not covered" >r*=e;<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>function <span class="fstat-no" title="function not covered" >Fs(</span>e,t){var r,n=<span class="cstat-no" title="statement not covered" >t.s&lt;0,</span>i=<span class="cstat-no" title="statement not covered" >ge(e,e.precision,1),</span>o=<span class="cstat-no" title="statement not covered" >i.times(.5);<span class="cstat-no" title="statement not covered" ></span>if(t=t.abs(),t.lte(o))<span class="cstat-no" title="statement not covered" >return Me=n?4:1,t;<span class="cstat-no" title="statement not covered" >i</span></span>f(r=t.divToInt(i),r.isZero())<span class="cstat-no" title="statement not covered" >Me=n?3:2;e</span>lse{<span class="cstat-no" title="statement not covered" >if(t=t.minus(r.times(i)),t.lte(o))<span class="cstat-no" title="statement not covered" >return Me=Ts(r)?n?2:3:n?4:1,t;<span class="cstat-no" title="statement not covered" >M</span></span>e=Ts(r)?n?1:4:n?3:2}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.minus(i).abs()}</span>function <span class="fstat-no" title="function not covered" >Di(</span>e,t,r,n){var i,o,s,a,l,u,c,p,d,f=<span class="cstat-no" title="statement not covered" >e.constructor,</span>g=<span class="cstat-no" title="statement not covered" >r!==void 0;<span class="cstat-no" title="statement not covered" ></span>if(g?(se(r,1,Ye),n===void 0?n=f.rounding:se(n,0,8)):(r=f.precision,n=f.rounding),!e.isFinite())<span class="cstat-no" title="statement not covered" >c=Ls(e);e</span>lse{<span class="cstat-no" title="statement not covered" >for(c=xe(e),s=c.indexOf("."),g?(i=2,t==16?r=r*4-3:t==8&amp;&amp;(r=r*3-2)):i=t,s&gt;=0&amp;&amp;(c=c.replace(".",""),d=new f(1),d.e=c.length-s,d.d=Xr(xe(d),10,i),d.e=d.d.length),p=Xr(c,10,i),o=l=p.length;p[--l]==0;)<span class="cstat-no" title="statement not covered" >p.pop();<span class="cstat-no" title="statement not covered" >i</span></span>f(!p[0])<span class="cstat-no" title="statement not covered" >c=g?"0p+0":"0";e</span>lse{<span class="cstat-no" title="statement not covered" >if(s&lt;0?o--:(e=new f(e),e.d=p,e.e=o,e=M(e,d,r,n,0,i),p=e.d,o=e.e,u=Ss),s=p[r],a=i/2,u=u||p[r+1]!==void 0,u=n&lt;4?(s!==void 0||u)&amp;&amp;(n===0||n===(e.s&lt;0?3:2)):s&gt;a||s===a&amp;&amp;(n===4||u||n===6&amp;&amp;p[r-1]&amp;1||n===(e.s&lt;0?8:7)),p.length=r,u)<span class="cstat-no" title="statement not covered" >for(;++p[--r]&gt;i-1;)<span class="cstat-no" title="statement not covered" >p[r]=0,r||(++o,p.unshift(1));<span class="cstat-no" title="statement not covered" >f</span></span></span>or(l=p.length;!p[l-1];--l);<span class="cstat-no" title="statement not covered" >f</span>or(s=0,c="";s&lt;l;s++)<span class="cstat-no" title="statement not covered" >c+=Si.charAt(p[s]);<span class="cstat-no" title="statement not covered" >i</span></span>f(g){<span class="cstat-no" title="statement not covered" >if(l&gt;1)<span class="cstat-no" title="statement not covered" >if(t==16||t==8){<span class="cstat-no" title="statement not covered" >for(s=t==16?4:3,--l;l%s;l++)<span class="cstat-no" title="statement not covered" >c+="0";<span class="cstat-no" title="statement not covered" >f</span></span>or(p=Xr(c,i,t),l=p.length;!p[l-1];--l);<span class="cstat-no" title="statement not covered" >f</span>or(s=1,c="1.";s&lt;l;s++)<span class="cstat-no" title="statement not covered" >c+=Si.charAt(p[s])}</span></span>else <span class="cstat-no" title="statement not covered" >c=c.charAt(0)+"."+c.slice(1);<span class="cstat-no" title="statement not covered" >c</span></span></span>=c+(o&lt;0?"p":"p+")+o}</span>else <span class="cstat-no" title="statement not covered" >if(o&lt;0){<span class="cstat-no" title="statement not covered" >for(;++o;)<span class="cstat-no" title="statement not covered" >c="0"+c;<span class="cstat-no" title="statement not covered" >c</span></span>="0."+c}</span>else <span class="cstat-no" title="statement not covered" >if(++o&gt;l)<span class="cstat-no" title="statement not covered" >for(o-=l;o--;)<span class="cstat-no" title="statement not covered" >c+="0";e</span></span>lse <span class="cstat-no" title="statement not covered" >o&lt;l&amp;&amp;(c=c.slice(0,o)+"."+c.slice(o))}<span class="cstat-no" title="statement not covered" ></span></span></span></span>c</span>=(t==16?"0x":t==2?"0b":t==8?"0o":"")+c}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e.s&lt;0?"-"+c:c}</span>function <span class="fstat-no" title="function not covered" >Rs(</span>e,t){<span class="cstat-no" title="statement not covered" >if(e.length&gt;t)<span class="cstat-no" title="statement not covered" >return e.length=t,!0}</span></span>function <span class="fstat-no" title="function not covered" >Nc(</span>e){<span class="cstat-no" title="statement not covered" >return new this(e).abs()}</span>function <span class="fstat-no" title="function not covered" >Lc(</span>e){<span class="cstat-no" title="statement not covered" >return new this(e).acos()}</span>function <span class="fstat-no" title="function not covered" >Fc(</span>e){<span class="cstat-no" title="statement not covered" >return new this(e).acosh()}</span>function <span class="fstat-no" title="function not covered" >Mc(</span>e,t){<span class="cstat-no" title="statement not covered" >return new this(e).plus(t)}</span>function <span class="fstat-no" title="function not covered" >$c(</span>e){<span class="cstat-no" title="statement not covered" >return new this(e).asin()}</span>function <span class="fstat-no" title="function not covered" >qc(</span>e){<span class="cstat-no" title="statement not covered" >return new this(e).asinh()}</span>function <span class="fstat-no" title="function not covered" >Vc(</span>e){<span class="cstat-no" title="statement not covered" >return new this(e).atan()}</span>function <span class="fstat-no" title="function not covered" >jc(</span>e){<span class="cstat-no" title="statement not covered" >return new this(e).atanh()}</span>function <span class="fstat-no" title="function not covered" >Bc(</span>e,t){<span class="cstat-no" title="statement not covered" >e=new this(e),t=new this(t);v</span>ar r,n=<span class="cstat-no" title="statement not covered" >this.precision,</span>i=<span class="cstat-no" title="statement not covered" >this.rounding,</span>o=<span class="cstat-no" title="statement not covered" >n+4;<span class="cstat-no" title="statement not covered" ></span>return!e.s||!t.s?r=new this(NaN):!e.d&amp;&amp;!t.d?(r=ge(this,o,1).times(t.s&gt;0?.25:.75),r.s=e.s):!t.d||e.isZero()?(r=t.s&lt;0?ge(this,n,i):new this(0),r.s=e.s):!e.d||t.isZero()?(r=ge(this,o,1).times(.5),r.s=e.s):t.s&lt;0?(this.precision=o,this.rounding=1,r=this.atan(M(e,t,o,1)),t=ge(this,o,1),this.precision=n,this.rounding=i,r=e.s&lt;0?r.minus(t):r.plus(t)):r=this.atan(M(e,t,o,1)),r}</span>function <span class="fstat-no" title="function not covered" >Uc(</span>e){<span class="cstat-no" title="statement not covered" >return new this(e).cbrt()}</span>function <span class="fstat-no" title="function not covered" >Qc(</span>e){<span class="cstat-no" title="statement not covered" >return y(e=new this(e),e.e+1,2)}</span>function <span class="fstat-no" title="function not covered" >Gc(</span>e,t,r){<span class="cstat-no" title="statement not covered" >return new this(e).clamp(t,r)}</span>function Jc(e){<span class="missing-if-branch" title="if path not taken" >I</span>if(!e||typeof e!="object")<span class="cstat-no" title="statement not covered" >throw Error(nn+"Object expected");v</span>ar t,r,n,i=e.defaults===!0,o=["precision",1,Ye,"rounding",0,8,"toExpNeg",-yt,0,"toExpPos",0,yt,"maxE",0,yt,"minE",-yt,0,"modulo",0,9];for(t=0;t&lt;o.length;t+=3)<span class="missing-if-branch" title="else path not taken" >E</span>if(r=o[t],i&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >this[r]=Ai[r])</span>,(n=e[r])!==void 0)if(re(n)===n&amp;&amp;n&gt;=o[t+1]&amp;&amp;n&lt;=o[t+2])this[r]=n;else <span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="else path not taken" >E</span>throw Error(Ke+r+": "+n);<span class="missing-if-branch" title="else path not taken" >E</span>i</span>f(r="crypto",i&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >this[r]=Ai[r])</span>,(n=e[r])!==void 0)if(n===!0||n===!1||<span class="branch-2 cbranch-no" title="branch not covered" >n===0|</span>|<span class="branch-3 cbranch-no" title="branch not covered" >n===1)<span class="missing-if-branch" title="if path not taken" >I</span></span>if(n)<span class="cstat-no" title="statement not covered" >if(typeof crypto&lt;"u"&amp;&amp;crypto&amp;&amp;(crypto.getRandomValues||crypto.randomBytes))<span class="cstat-no" title="statement not covered" >this[r]=!0;e</span>lse <span class="cstat-no" title="statement not covered" >throw Error(Is);e</span></span>lse this[r]=!1;else <span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="else path not taken" >E</span>throw Error(Ke+r+": "+n);r</span>eturn this}function <span class="fstat-no" title="function not covered" >Hc(</span>e){<span class="cstat-no" title="statement not covered" >return new this(e).cos()}</span>function <span class="fstat-no" title="function not covered" >Wc(</span>e){<span class="cstat-no" title="statement not covered" >return new this(e).cosh()}</span>function Ms(e){var t,r,n;function i(o){var s,a,l,u=this;<span class="missing-if-branch" title="if path not taken" >I</span>if(!(u instanceof i))<span class="cstat-no" title="statement not covered" >return new i(o);<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(u.constructor=i,Cs(o)){<span class="cstat-no" title="statement not covered" >u.s=o.s,b?!o.d||o.e&gt;i.maxE?(u.e=NaN,u.d=null):o.e&lt;i.minE?(u.e=0,u.d=[0]):(u.e=o.e,u.d=o.d.slice()):(u.e=o.e,u.d=o.d?o.d.slice():o.d);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="missing-if-branch" title="if path not taken" >I</span></span>if(l=typeof o,l==="number"){<span class="cstat-no" title="statement not covered" >if(o===0){<span class="cstat-no" title="statement not covered" >u.s=1/o&lt;0?-1:1,u.e=0,u.d=[0];<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(o&lt;0?(o=-o,u.s=-1):u.s=1,o===~~o&amp;&amp;o&lt;1e7){<span class="cstat-no" title="statement not covered" >for(s=0,a=o;a&gt;=10;a/=10)<span class="cstat-no" title="statement not covered" >s++;<span class="cstat-no" title="statement not covered" >b</span></span>?s&gt;i.maxE?(u.e=NaN,u.d=null):s&lt;i.minE?(u.e=0,u.d=[0]):(u.e=s,u.d=[o]):(u.e=s,u.d=[o]);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>else <span class="cstat-no" title="statement not covered" >if(o*0!==0){<span class="cstat-no" title="statement not covered" >o||(u.s=NaN),u.e=NaN,u.d=null;<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn ki(u,o.toString())}</span>else <span class="missing-if-branch" title="if path not taken" >I</span>if(l!=="string")<span class="cstat-no" title="statement not covered" >throw Error(Ke+o);r</span>eturn(a=o.charCodeAt(0))===45?(<span class="branch-0 cbranch-no" title="branch not covered" >o=o.slice(1),u.s=-1)</span>:(a===43&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >o=o.slice(1))</span>,u.s=1),ks.test(o)?ki(u,o):<span class="branch-1 cbranch-no" title="branch not covered" >Dc(u,o)}<span class="missing-if-branch" title="else path not taken" >E</span></span>if(i.prototype=m,i.ROUND_UP=0,i.ROUND_DOWN=1,i.ROUND_CEIL=2,i.ROUND_FLOOR=3,i.ROUND_HALF_UP=4,i.ROUND_HALF_DOWN=5,i.ROUND_HALF_EVEN=6,i.ROUND_HALF_CEIL=7,i.ROUND_HALF_FLOOR=8,i.EUCLID=9,i.config=i.set=Jc,i.clone=Ms,i.isDecimal=Cs,i.abs=Nc,i.acos=Lc,i.acosh=Fc,i.add=Mc,i.asin=$c,i.asinh=qc,i.atan=Vc,i.atanh=jc,i.atan2=Bc,i.cbrt=Uc,i.ceil=Qc,i.clamp=Gc,i.cos=Hc,i.cosh=Wc,i.div=Kc,i.exp=Yc,i.floor=zc,i.hypot=Zc,i.ln=Xc,i.log=ep,i.log10=rp,i.log2=tp,i.max=np,i.min=ip,i.mod=op,i.mul=sp,i.pow=ap,i.random=lp,i.round=up,i.sign=cp,i.sin=pp,i.sinh=dp,i.sqrt=mp,i.sub=fp,i.sum=gp,i.tan=hp,i.tanh=yp,i.trunc=Ep,e===void 0&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >e={})</span>,e&amp;&amp;e.defaults!==!0)for(n=["precision","rounding","toExpNeg","toExpPos","maxE","minE","modulo","crypto"],t=0;t&lt;n.length;)e.hasOwnProperty(r=n[t++])||(<span class="branch-1 cbranch-no" title="branch not covered" >e[r]=this[r])</span>;return i.config(e),i}function <span class="fstat-no" title="function not covered" >Kc(</span>e,t){<span class="cstat-no" title="statement not covered" >return new this(e).div(t)}</span>function <span class="fstat-no" title="function not covered" >Yc(</span>e){<span class="cstat-no" title="statement not covered" >return new this(e).exp()}</span>function <span class="fstat-no" title="function not covered" >zc(</span>e){<span class="cstat-no" title="statement not covered" >return y(e=new this(e),e.e+1,3)}</span>function <span class="fstat-no" title="function not covered" >Zc(</span>){var e,t,r=<span class="cstat-no" title="statement not covered" >new this(0);<span class="cstat-no" title="statement not covered" ></span>for(b=!1,e=0;e&lt;arguments.length;)<span class="cstat-no" title="statement not covered" >if(t=new this(arguments[e++]),t.d)<span class="cstat-no" title="statement not covered" >r.d&amp;&amp;(r=r.plus(t.times(t)));e</span>lse{<span class="cstat-no" title="statement not covered" >if(t.s)<span class="cstat-no" title="statement not covered" >return b=!0,new this(1/0);<span class="cstat-no" title="statement not covered" >r</span></span>=t}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn b=!0,r.sqrt()}</span>function Cs(e){return e instanceof it||e&amp;&amp;e.toStringTag===Os||!1}function <span class="fstat-no" title="function not covered" >Xc(</span>e){<span class="cstat-no" title="statement not covered" >return new this(e).ln()}</span>function <span class="fstat-no" title="function not covered" >ep(</span>e,t){<span class="cstat-no" title="statement not covered" >return new this(e).log(t)}</span>function <span class="fstat-no" title="function not covered" >tp(</span>e){<span class="cstat-no" title="statement not covered" >return new this(e).log(2)}</span>function <span class="fstat-no" title="function not covered" >rp(</span>e){<span class="cstat-no" title="statement not covered" >return new this(e).log(10)}</span>function <span class="fstat-no" title="function not covered" >np(</span>){<span class="cstat-no" title="statement not covered" >return Ns(this,arguments,"lt")}</span>function <span class="fstat-no" title="function not covered" >ip(</span>){<span class="cstat-no" title="statement not covered" >return Ns(this,arguments,"gt")}</span>function <span class="fstat-no" title="function not covered" >op(</span>e,t){<span class="cstat-no" title="statement not covered" >return new this(e).mod(t)}</span>function <span class="fstat-no" title="function not covered" >sp(</span>e,t){<span class="cstat-no" title="statement not covered" >return new this(e).mul(t)}</span>function <span class="fstat-no" title="function not covered" >ap(</span>e,t){<span class="cstat-no" title="statement not covered" >return new this(e).pow(t)}</span>function <span class="fstat-no" title="function not covered" >lp(</span>e){var t,r,n,i,o=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >new this(1),</span>a=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(e===void 0?e=this.precision:se(e,1,Ye),n=Math.ceil(e/E),this.crypto)<span class="cstat-no" title="statement not covered" >if(crypto.getRandomValues)<span class="cstat-no" title="statement not covered" >for(t=crypto.getRandomValues(new Uint32Array(n));o&lt;n;)<span class="cstat-no" title="statement not covered" >i=t[o],i&gt;=429e7?t[o]=crypto.getRandomValues(new Uint32Array(1))[0]:a[o++]=i%1e7;e</span></span>lse <span class="cstat-no" title="statement not covered" >if(crypto.randomBytes){<span class="cstat-no" title="statement not covered" >for(t=crypto.randomBytes(n*=4);o&lt;n;)<span class="cstat-no" title="statement not covered" >i=t[o]+(t[o+1]&lt;&lt;8)+(t[o+2]&lt;&lt;16)+((t[o+3]&amp;127)&lt;&lt;24),i&gt;=214e7?crypto.randomBytes(4).copy(t,o):(a.push(i%1e7),o+=4);<span class="cstat-no" title="statement not covered" >o</span></span>=n/4}</span>else <span class="cstat-no" title="statement not covered" >throw Error(Is);e</span></span></span>lse <span class="cstat-no" title="statement not covered" >for(;o&lt;n;)<span class="cstat-no" title="statement not covered" >a[o++]=Math.random()*1e7|0;<span class="cstat-no" title="statement not covered" >f</span></span></span>or(n=a[--o],e%=E,n&amp;&amp;e&amp;&amp;(i=G(10,E-e),a[o]=(n/i|0)*i);a[o]===0;o--)<span class="cstat-no" title="statement not covered" >a.pop();<span class="cstat-no" title="statement not covered" >i</span></span>f(o&lt;0)<span class="cstat-no" title="statement not covered" >r=0,a=[0];e</span>lse{<span class="cstat-no" title="statement not covered" >for(r=-1;a[0]===0;r-=E)<span class="cstat-no" title="statement not covered" >a.shift();<span class="cstat-no" title="statement not covered" >f</span></span>or(n=1,i=a[0];i&gt;=10;i/=10)<span class="cstat-no" title="statement not covered" >n++;<span class="cstat-no" title="statement not covered" >n</span></span>&lt;E&amp;&amp;(r-=E-n)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s.e=r,s.d=a,s}</span>function <span class="fstat-no" title="function not covered" >up(</span>e){<span class="cstat-no" title="statement not covered" >return y(e=new this(e),e.e+1,this.rounding)}</span>function <span class="fstat-no" title="function not covered" >cp(</span>e){<span class="cstat-no" title="statement not covered" >return e=new this(e),e.d?e.d[0]?e.s:0*e.s:e.s||NaN}</span>function <span class="fstat-no" title="function not covered" >pp(</span>e){<span class="cstat-no" title="statement not covered" >return new this(e).sin()}</span>function <span class="fstat-no" title="function not covered" >dp(</span>e){<span class="cstat-no" title="statement not covered" >return new this(e).sinh()}</span>function <span class="fstat-no" title="function not covered" >mp(</span>e){<span class="cstat-no" title="statement not covered" >return new this(e).sqrt()}</span>function <span class="fstat-no" title="function not covered" >fp(</span>e,t){<span class="cstat-no" title="statement not covered" >return new this(e).sub(t)}</span>function <span class="fstat-no" title="function not covered" >gp(</span>){var e=<span class="cstat-no" title="statement not covered" >0,</span>t=<span class="cstat-no" title="statement not covered" >arguments,</span>r=<span class="cstat-no" title="statement not covered" >new this(t[e]);<span class="cstat-no" title="statement not covered" ></span>for(b=!1;r.s&amp;&amp;++e&lt;t.length;)<span class="cstat-no" title="statement not covered" >r=r.plus(t[e]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn b=!0,y(r,this.precision,this.rounding)}</span>function <span class="fstat-no" title="function not covered" >hp(</span>e){<span class="cstat-no" title="statement not covered" >return new this(e).tan()}</span>function <span class="fstat-no" title="function not covered" >yp(</span>e){<span class="cstat-no" title="statement not covered" >return new this(e).tanh()}</span>function <span class="fstat-no" title="function not covered" >Ep(</span>e){<span class="cstat-no" title="statement not covered" >return y(e=new this(e),e.e+1,1)}</span>m[Symbol.for("nodejs.util.inspect.custom")]=m.toString;m[Symbol.toStringTag]="Decimal";var it=m.constructor=Ms(Ai);en=new it(en);tn=new it(tn);var ve=it;function bt(e){return e===null?e:Array.isArray(e)?<span class="branch-0 cbranch-no" title="branch not covered" >e.map(bt):</span>typeof e=="object"?bp(e)?<span class="branch-0 cbranch-no" title="branch not covered" >wp(e):</span>ht(e,bt):e}function bp(e){return e!==null&amp;&amp;typeof e=="object"&amp;&amp;typeof e.$type=="string"}function <span class="fstat-no" title="function not covered" >wp(</span>{$type:e,value:t}){<span class="cstat-no" title="statement not covered" >switch(e){case"BigInt":<span class="cstat-no" title="statement not covered" >return BigInt(t);c</span>ase"Bytes":{let{buffer:r,byteOffset:n,byteLength:i}=<span class="cstat-no" title="statement not covered" >Buffer.from(t,"base64");<span class="cstat-no" title="statement not covered" ></span>return new Uint8Array(r,n,i)}</span>case"DateTime":<span class="cstat-no" title="statement not covered" >return new Date(t);c</span>ase"Decimal":<span class="cstat-no" title="statement not covered" >return new ve(t);c</span>ase"Json":<span class="cstat-no" title="statement not covered" >return JSON.parse(t);d</span>efault:<span class="cstat-no" title="statement not covered" >Fe(t,"Unknown tagged value")}</span>}</span>function <span class="fstat-no" title="function not covered" >wt(</span>e){<span class="cstat-no" title="statement not covered" >return e.substring(0,1).toLowerCase()+e.substring(1)}</span>function xt(e){return e instanceof Date||Object.prototype.toString.call(e)==="[object Date]"}function <span class="fstat-no" title="function not covered" >an(</span>e){<span class="cstat-no" title="statement not covered" >return e.toString()!=="Invalid Date"}</span>function vt(e){return it.isDecimal(e)?<span class="branch-0 cbranch-no" title="branch not covered" >!0:</span>e!==null&amp;&amp;typeof e=="object"&amp;&amp;typeof e.s=="number"&amp;&amp;<span class="branch-3 cbranch-no" title="branch not covered" >typeof e.e=="number"&amp;</span>&amp;<span class="branch-4 cbranch-no" title="branch not covered" >typeof e.toFixed=="function"&amp;</span>&amp;<span class="branch-5 cbranch-no" title="branch not covered" >Array.isArray(e.d)}</span>var Us=D(bi());var Bs=D(require("fs"));var $s={keyword:_e,entity:_e,value:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >W(rt(e)),</span>punctuation:rt,directive:_e,function:_e,variable:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >W(rt(e)),</span>string:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >W(Ve(e)),</span>boolean:De,number:_e,comment:Ut};var xp=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e,</span>ln={},vp=0,x={manual:ln.Prism&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >ln.Prism.manual,</span>disableWorkerMessageHandler:ln.Prism&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >ln.Prism.disableWorkerMessageHandler,</span>util:{encode:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(e instanceof ye){let t=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return new ye(t.type,x.util.encode(t.content),t.alias)}</span>else <span class="cstat-no" title="statement not covered" >return Array.isArray(e)?e.map(x.util.encode):e.replace(/&amp;/g,"&amp;amp;").replace(/&lt;/g,"&amp;lt;").replace(/\u00a0/g," ")}</span></span>,type:function(e){return Object.prototype.toString.call(e).slice(8,-1)},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++vp}),e.__id},clone:function e(t,r){let n,i,o=x.util.type(t);switch(r=r||{},o){case"Object":if(i=x.util.objId(t),r[i])return r[i];n={},r[i]=n;for(let s in t)t.hasOwnProperty(s)&amp;&amp;(n[s]=e(t[s],r));return n;case"Array":return i=x.util.objId(t),r[i]?<span class="branch-0 cbranch-no" title="branch not covered" >r[i]:</span>(n=[],r[i]=n,t.forEach(function(s,a){n[a]=e(s,r)}),n);default:return t}}},languages:{extend:function(e,t){let r=x.util.clone(x.languages[e]);for(let n in t)r[n]=t[n];return r},insertBefore:function(e,t,r,n){n=n||x.languages;let i=n[e],o={};for(let a in i)<span class="missing-if-branch" title="else path not taken" >E</span>if(i.hasOwnProperty(a)){if(a==t)for(let l in r)r.hasOwnProperty(l)&amp;&amp;(o[l]=r[l]);r.hasOwnProperty(a)||(o[a]=i[a])}let s=n[e];return n[e]=o,x.languages.DFS(x.languages,function(a,l){l===s&amp;&amp;a!=e&amp;&amp;(this[a]=o)}),o},DFS:function e(t,r,n,i){i=i||{};let o=x.util.objId;for(let s in t)<span class="missing-if-branch" title="else path not taken" >E</span>if(t.hasOwnProperty(s)){r.call(t,s,t[s],n||s);let a=t[s],l=x.util.type(a);l==="Object"&amp;&amp;!i[o(a)]?(i[o(a)]=!0,e(a,r,null,i)):l==="Array"&amp;&amp;!i[o(a)]&amp;&amp;(i[o(a)]=!0,e(a,r,s,i))}}},plugins:{},highlight:<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){let n=<span class="cstat-no" title="statement not covered" >{code:e,grammar:t,language:r};<span class="cstat-no" title="statement not covered" ></span>return x.hooks.run("before-tokenize",n),n.tokens=x.tokenize(n.code,n.grammar),x.hooks.run("after-tokenize",n),ye.stringify(x.util.encode(n.tokens),n.language)}</span>,matchGrammar:<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,n,i,o,s){<span class="cstat-no" title="statement not covered" >for(let h in r){<span class="cstat-no" title="statement not covered" >if(!r.hasOwnProperty(h)||!r[h])<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f(h==s)<span class="cstat-no" title="statement not covered" >return;l</span></span>et O=<span class="cstat-no" title="statement not covered" >r[h];<span class="cstat-no" title="statement not covered" ></span>O=x.util.type(O)==="Array"?O:[O];<span class="cstat-no" title="statement not covered" >f</span>or(let P=<span class="cstat-no" title="statement not covered" >0;</span>P&lt;O.length;++P){let C=<span class="cstat-no" title="statement not covered" >O[P],</span>R=<span class="cstat-no" title="statement not covered" >C.inside,</span>k=<span class="cstat-no" title="statement not covered" >!!C.lookbehind,</span>A=<span class="cstat-no" title="statement not covered" >!!C.greedy,</span>ue=<span class="cstat-no" title="statement not covered" >0,</span>jt=<span class="cstat-no" title="statement not covered" >C.alias;<span class="cstat-no" title="statement not covered" ></span>if(A&amp;&amp;!C.pattern.global){let U=<span class="cstat-no" title="statement not covered" >C.pattern.toString().match(/[imuy]*$/)[0];<span class="cstat-no" title="statement not covered" ></span>C.pattern=RegExp(C.pattern.source,U+"g")}<span class="cstat-no" title="statement not covered" ></span>C</span>=C.pattern||C;<span class="cstat-no" title="statement not covered" >f</span>or(let U=<span class="cstat-no" title="statement not covered" >n,</span>oe=<span class="cstat-no" title="statement not covered" >i;</span>U&lt;t.length;oe+=t[U].length,++U){let Oe=<span class="cstat-no" title="statement not covered" >t[U];<span class="cstat-no" title="statement not covered" ></span>if(t.length&gt;e.length)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(Oe instanceof ye)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f(A&amp;&amp;U!=t.length-1){<span class="cstat-no" title="statement not covered" >C.lastIndex=oe;v</span>ar p=<span class="cstat-no" title="statement not covered" >C.exec(e);<span class="cstat-no" title="statement not covered" ></span>if(!p)<span class="cstat-no" title="statement not covered" >break;v</span></span>ar c=<span class="cstat-no" title="statement not covered" >p.index+(k?p[1].length:0),</span>d=<span class="cstat-no" title="statement not covered" >p.index+p[0].length,</span>a=<span class="cstat-no" title="statement not covered" >U,</span>l=<span class="cstat-no" title="statement not covered" >oe;<span class="cstat-no" title="statement not covered" ></span>for(let N=<span class="cstat-no" title="statement not covered" >t.length;</span>a&lt;N&amp;&amp;(l&lt;d||!t[a].type&amp;&amp;!t[a-1].greedy);++a)<span class="cstat-no" title="statement not covered" >l+=t[a].length,c&gt;=l&amp;&amp;(++U,oe=l);<span class="cstat-no" title="statement not covered" >i</span></span>f(t[U]instanceof ye)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >u</span></span>=a-U,Oe=e.slice(oe,l),p.index-=oe}</span>else{<span class="cstat-no" title="statement not covered" >C.lastIndex=0;v</span>ar p=<span class="cstat-no" title="statement not covered" >C.exec(Oe),</span>u=<span class="cstat-no" title="statement not covered" >1}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!p){<span class="cstat-no" title="statement not covered" >if(o)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >c</span></span>ontinue}<span class="cstat-no" title="statement not covered" ></span>k</span>&amp;&amp;(ue=p[1]?p[1].length:0);v</span>ar c=<span class="cstat-no" title="statement not covered" >p.index+ue,</span>p=<span class="cstat-no" title="statement not covered" >p[0].slice(ue),</span>d=<span class="cstat-no" title="statement not covered" >c+p.length,</span>f=<span class="cstat-no" title="statement not covered" >Oe.slice(0,c),</span>g=<span class="cstat-no" title="statement not covered" >Oe.slice(d);</span>let Y=<span class="cstat-no" title="statement not covered" >[U,u];<span class="cstat-no" title="statement not covered" ></span>f&amp;&amp;(++U,oe+=f.length,Y.push(f));l</span>et pt=<span class="cstat-no" title="statement not covered" >new ye(h,R?x.tokenize(p,R):p,jt,p,A);<span class="cstat-no" title="statement not covered" ></span>if(Y.push(pt),g&amp;&amp;Y.push(g),Array.prototype.splice.apply(t,Y),u!=1&amp;&amp;x.matchGrammar(e,t,r,U,oe,!0,h),o)<span class="cstat-no" title="statement not covered" >break}</span></span>}</span>}</span>}</span>,tokenize:<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){let r=<span class="cstat-no" title="statement not covered" >[e],</span>n=<span class="cstat-no" title="statement not covered" >t.rest;<span class="cstat-no" title="statement not covered" ></span>if(n){<span class="cstat-no" title="statement not covered" >for(let i in n)<span class="cstat-no" title="statement not covered" >t[i]=n[i];<span class="cstat-no" title="statement not covered" >d</span></span>elete t.rest}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn x.matchGrammar(e,r,t,0,0,!1),r}</span>,hooks:{all:{},add:<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){let r=<span class="cstat-no" title="statement not covered" >x.hooks.all;<span class="cstat-no" title="statement not covered" ></span>r[e]=r[e]||[],r[e].push(t)}</span>,run:<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){let r=<span class="cstat-no" title="statement not covered" >x.hooks.all[e];<span class="cstat-no" title="statement not covered" ></span>if(!(!r||!r.length))<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >0,</span>i;i=r[n++];)<span class="cstat-no" title="statement not covered" >i(t)}</span></span></span>},Token:ye};x.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0,greedy:!0}],string:{pattern:/(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},"class-name":{pattern:/((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i,lookbehind:!0,inside:{punctuation:/[.\\]/}},keyword:/\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,boolean:/\b(?:true|false)\b/,function:/\w+(?=\()/,number:/\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,operator:/--?|\+\+?|!=?=?|&lt;=?|&gt;=?|==?=?|&amp;&amp;?|\|\|?|\?|\*|\/|~|\^|%/,punctuation:/[{}[\];(),.:]/};x.languages.javascript=x.languages.extend("clike",{"class-name":[x.languages.clike["class-name"],{pattern:/(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/,lookbehind:!0}],keyword:[{pattern:/((?:^|})\s*)(?:catch|finally)\b/,lookbehind:!0},{pattern:/(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,lookbehind:!0}],number:/\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,function:/[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,operator:/-[-=]?|\+[+=]?|!=?=?|&lt;&lt;?=?|&gt;&gt;?&gt;?=?|=(?:==?|&gt;)?|&amp;[&amp;=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/});x.languages.javascript["class-name"][0].pattern=/(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;x.languages.insertBefore("javascript","keyword",{regex:{pattern:/((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/,lookbehind:!0,greedy:!0},"function-variable":{pattern:/[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=&gt;))/,alias:"function"},parameter:[{pattern:/(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/,lookbehind:!0,inside:x.languages.javascript},{pattern:/[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=&gt;)/i,inside:x.languages.javascript},{pattern:/(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=&gt;)/,lookbehind:!0,inside:x.languages.javascript},{pattern:/((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/,lookbehind:!0,inside:x.languages.javascript}],constant:/\b[A-Z](?:[A-Z_]|\dx?)*\b/});x.languages.markup&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >x.languages.markup.tag.addInlined("script","javascript");</span>x.languages.js=x.languages.javascript;x.languages.typescript=x.languages.extend("javascript",{keyword:/\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\b/,builtin:/\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/});x.languages.ts=x.languages.typescript;function <span class="fstat-no" title="function not covered" >ye(</span>e,t,r,n,i){<span class="cstat-no" title="statement not covered" >this.type=e,this.content=t,this.alias=r,this.length=(n||"").length|0,this.greedy=!!i}</span>ye.stringify=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return typeof e=="string"?e:Array.isArray(e)?e.map(<span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >return ye.stringify(r,t)}</span>).join(""):Pp(e.type)(e.content)}</span>;function <span class="fstat-no" title="function not covered" >Pp(</span>e){<span class="cstat-no" title="statement not covered" >return $s[e]||xp}</span>function <span class="fstat-no" title="function not covered" >qs(</span>e){<span class="cstat-no" title="statement not covered" >return Tp(e,x.languages.javascript)}</span>function <span class="fstat-no" title="function not covered" >Tp(</span>e,t){<span class="cstat-no" title="statement not covered" >return x.tokenize(e,t).map(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >ye.stringify(n))</span>.join("")}</span>var Vs=D(gs());function <span class="fstat-no" title="function not covered" >js(</span>e){<span class="cstat-no" title="statement not covered" >return(0,Vs.default)(e)}</span>var un=class e{<span class="fstat-no" title="function not covered" >st</span>atic read(t){let r;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >r=Bs.default.readFileSync(t,"utf-8")}</span>catch{<span class="cstat-no" title="statement not covered" >return null}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e.fromContent(r)}<span class="fstat-no" title="function not covered" ></span>st</span>atic fromContent(t){let r=<span class="cstat-no" title="statement not covered" >t.split(/\r?\n/);<span class="cstat-no" title="statement not covered" ></span>return new e(1,r)}<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t,r){<span class="cstat-no" title="statement not covered" >this.firstLineNumber=t,this.lines=r}<span class="fstat-no" title="function not covered" ></span>ge</span>t lastLineNumber(){<span class="cstat-no" title="statement not covered" >return this.firstLineNumber+this.lines.length-1}<span class="fstat-no" title="function not covered" ></span>ma</span>pLineAt(t,r){<span class="cstat-no" title="statement not covered" >if(t&lt;this.firstLineNumber||t&gt;this.lines.length+this.firstLineNumber)<span class="cstat-no" title="statement not covered" >return this;l</span></span>et n=<span class="cstat-no" title="statement not covered" >t-this.firstLineNumber,</span>i=<span class="cstat-no" title="statement not covered" >[...this.lines];<span class="cstat-no" title="statement not covered" ></span>return i[n]=r(i[n]),new e(this.firstLineNumber,i)}<span class="fstat-no" title="function not covered" ></span>ma</span>pLines(t){<span class="cstat-no" title="statement not covered" >return new e(this.firstLineNumber,this.lines.map(<span class="fstat-no" title="function not covered" >(r</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >t(r,this.firstLineNumber+n))</span>)}<span class="fstat-no" title="function not covered" ></span>li</span>neAt(t){<span class="cstat-no" title="statement not covered" >return this.lines[t-this.firstLineNumber]}<span class="fstat-no" title="function not covered" ></span>pr</span>ependSymbolAt(t,r){<span class="cstat-no" title="statement not covered" >return this.mapLines(<span class="fstat-no" title="function not covered" >(n</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >i===t?`${r} ${n}`:`  ${n}`)</span>}<span class="fstat-no" title="function not covered" ></span>sl</span>ice(t,r){let n=<span class="cstat-no" title="statement not covered" >this.lines.slice(t-1,r).join(`</span>
`);<span class="cstat-no" title="statement not covered" >return new e(t,js(n).split(`</span>
`))}<span class="fstat-no" title="function not covered" >hi</span>ghlight(){let t=<span class="cstat-no" title="statement not covered" >qs(this.toString());<span class="cstat-no" title="statement not covered" ></span>return new e(this.firstLineNumber,t.split(`</span>
`))}<span class="fstat-no" title="function not covered" >to</span>String(){<span class="cstat-no" title="statement not covered" >return this.lines.join(`</span>
`)}};var Rp={red:de,gray:Ut,dim:ke,bold:W,underline:X,highlightSource:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.highlight()}</span>,Cp={red:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e,</span>gray:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e,</span>dim:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e,</span>bold:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e,</span>underline:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e,</span>highlightSource:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e}</span>;function <span class="fstat-no" title="function not covered" >Sp(</span>{message:e,originalMethod:t,isPanic:r,callArguments:n}){<span class="cstat-no" title="statement not covered" >return{functionName:`prisma.${t}()`,message:e,isPanic:r??!1,callArguments:n}}</span>function <span class="fstat-no" title="function not covered" >Ap(</span>{callsite:e,message:t,originalMethod:r,isPanic:n,callArguments:i},o){let s=<span class="cstat-no" title="statement not covered" >Sp({message:t,originalMethod:r,isPanic:n,callArguments:i});<span class="cstat-no" title="statement not covered" ></span>if(!e||typeof window&lt;"u"||process.env.NODE_ENV==="production")<span class="cstat-no" title="statement not covered" >return s;l</span></span>et a=<span class="cstat-no" title="statement not covered" >e.getLocation();<span class="cstat-no" title="statement not covered" ></span>if(!a||!a.lineNumber||!a.columnNumber)<span class="cstat-no" title="statement not covered" >return s;l</span></span>et l=<span class="cstat-no" title="statement not covered" >Math.max(1,a.lineNumber-3),</span>u=<span class="cstat-no" title="statement not covered" >un.read(a.fileName)?.slice(l,a.lineNumber),</span>c=<span class="cstat-no" title="statement not covered" >u?.lineAt(a.lineNumber);<span class="cstat-no" title="statement not covered" ></span>if(u&amp;&amp;c){let p=<span class="cstat-no" title="statement not covered" >Op(c),</span>d=<span class="cstat-no" title="statement not covered" >Ip(c);<span class="cstat-no" title="statement not covered" ></span>if(!d)<span class="cstat-no" title="statement not covered" >return s;<span class="cstat-no" title="statement not covered" >s</span></span>.functionName=`${d.code})`,s.location=a,n||(u=u.mapLineAt(a.lineNumber,<span class="fstat-no" title="function not covered" >g=</span>&gt;<span class="cstat-no" title="statement not covered" >g.slice(0,d.openingBraceIndex))</span>),u=o.highlightSource(u);l</span>et f=<span class="cstat-no" title="statement not covered" >String(u.lastLineNumber).length;<span class="cstat-no" title="statement not covered" ></span>if(s.contextLines=u.mapLines(<span class="fstat-no" title="function not covered" >(g</span>,h)=&gt;<span class="cstat-no" title="statement not covered" >o.gray(String(h).padStart(f))+" "+g)</span>.mapLines(<span class="fstat-no" title="function not covered" >g=</span>&gt;<span class="cstat-no" title="statement not covered" >o.dim(g))</span>.prependSymbolAt(a.lineNumber,o.bold(o.red("\u2192"))),i){let g=<span class="cstat-no" title="statement not covered" >p+f+1;<span class="cstat-no" title="statement not covered" ></span>g+=2,s.callArguments=(0,Us.default)(i,g).slice(g)}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}</span>function <span class="fstat-no" title="function not covered" >Ip(</span>e){let t=<span class="cstat-no" title="statement not covered" >Object.keys(zt.ModelAction).join("|"),</span>n=<span class="cstat-no" title="statement not covered" >new RegExp(String.raw`\.(${t})\(`).exec(e);<span class="cstat-no" title="statement not covered" ></span>if(n){let i=<span class="cstat-no" title="statement not covered" >n.index+n[0].length,</span>o=<span class="cstat-no" title="statement not covered" >e.lastIndexOf(" ",n.index)+1;<span class="cstat-no" title="statement not covered" ></span>return{code:e.slice(o,i),openingBraceIndex:i}}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn null}</span>function <span class="fstat-no" title="function not covered" >Op(</span>e){let t=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;e.length;r++){<span class="cstat-no" title="statement not covered" >if(e.charAt(r)!==" ")<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >t</span></span>++}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >kp(</span>{functionName:e,location:t,message:r,isPanic:n,contextLines:i,callArguments:o},s){let a=<span class="cstat-no" title="statement not covered" >[""],</span>l=<span class="cstat-no" title="statement not covered" >t?" in":":";<span class="cstat-no" title="statement not covered" ></span>if(n?(a.push(s.red(`Oops, an unknown error occurred! This is ${s.bold("on us")}, you did nothing wrong.`)),a.push(s.red(`It occurred in the ${s.bold(`\`${e}\``)} invocation${l}`))):a.push(s.red(`Invalid ${s.bold(`\`${e}\``)} invocation${l}`)),t&amp;&amp;a.push(s.underline(Dp(t))),i){<span class="cstat-no" title="statement not covered" >a.push("");l</span>et u=<span class="cstat-no" title="statement not covered" >[i.toString()];<span class="cstat-no" title="statement not covered" ></span>o&amp;&amp;(u.push(o),u.push(s.dim(")"))),a.push(u.join("")),o&amp;&amp;a.push("")}</span>else <span class="cstat-no" title="statement not covered" >a.push(""),o&amp;&amp;a.push(o),a.push("");<span class="cstat-no" title="statement not covered" >r</span></span>eturn a.push(r),a.join(`</span>
`)}function <span class="fstat-no" title="function not covered" >Dp(</span>e){let t=<span class="cstat-no" title="statement not covered" >[e.fileName];<span class="cstat-no" title="statement not covered" ></span>return e.lineNumber&amp;&amp;t.push(String(e.lineNumber)),e.columnNumber&amp;&amp;t.push(String(e.columnNumber)),t.join(":")}</span>function <span class="fstat-no" title="function not covered" >cn(</span>e){let t=<span class="cstat-no" title="statement not covered" >e.showColors?Rp:Cp,</span>r;<span class="cstat-no" title="statement not covered" >return r=Ap(e,t),kp(r,t)}</span>var Ys=D(_i());function <span class="fstat-no" title="function not covered" >Hs(</span>e,t,r){let n=<span class="cstat-no" title="statement not covered" >Ws(e),</span>i=<span class="cstat-no" title="statement not covered" >_p(n),</span>o=<span class="cstat-no" title="statement not covered" >Lp(i);<span class="cstat-no" title="statement not covered" ></span>o?pn(o,t,r):t.addErrorMessage(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >"Unknown error")</span>}</span>function <span class="fstat-no" title="function not covered" >Ws(</span>e){<span class="cstat-no" title="statement not covered" >return e.errors.flatMap(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.kind==="Union"?Ws(t):[t])</span>}</span>function <span class="fstat-no" title="function not covered" >_p(</span>e){let t=<span class="cstat-no" title="statement not covered" >new Map,</span>r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let n of e){<span class="cstat-no" title="statement not covered" >if(n.kind!=="InvalidArgumentType"){<span class="cstat-no" title="statement not covered" >r.push(n);<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>l</span>et i=<span class="cstat-no" title="statement not covered" >`${n.selectionPath.join(".")}:${n.argumentPath.join(".")}`,</span>o=<span class="cstat-no" title="statement not covered" >t.get(i);<span class="cstat-no" title="statement not covered" ></span>o?t.set(i,{...n,argument:{...n.argument,typeNames:Np(o.argument.typeNames,n.argument.typeNames)}}):t.set(i,n)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r.push(...t.values()),r}</span>function <span class="fstat-no" title="function not covered" >Np(</span>e,t){<span class="cstat-no" title="statement not covered" >return[...new Set(e.concat(t))]}</span>function <span class="fstat-no" title="function not covered" >Lp(</span>e){<span class="cstat-no" title="statement not covered" >return Ci(e,<span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{let n=<span class="cstat-no" title="statement not covered" >Gs(t),</span>i=<span class="cstat-no" title="statement not covered" >Gs(r);<span class="cstat-no" title="statement not covered" ></span>return n!==i?n-i:Js(t)-Js(r)}</span>)}</span>function <span class="fstat-no" title="function not covered" >Gs(</span>e){let t=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return Array.isArray(e.selectionPath)&amp;&amp;(t+=e.selectionPath.length),Array.isArray(e.argumentPath)&amp;&amp;(t+=e.argumentPath.length),t}</span>function <span class="fstat-no" title="function not covered" >Js(</span>e){<span class="cstat-no" title="statement not covered" >switch(e.kind){case"InvalidArgumentValue":case"ValueTooLarge":<span class="cstat-no" title="statement not covered" >return 20;c</span>ase"InvalidArgumentType":<span class="cstat-no" title="statement not covered" >return 10;c</span>ase"RequiredArgumentMissing":<span class="cstat-no" title="statement not covered" >return-10;d</span>efault:<span class="cstat-no" title="statement not covered" >return 0}</span>}</span>var pe=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,r){<span class="cstat-no" title="statement not covered" >this.name=t;<span class="cstat-no" title="statement not covered" >t</span>his.value=r;<span class="cstat-no" title="statement not covered" >t</span>his.isRequired=!1}<span class="fstat-no" title="function not covered" ></span>ma</span>keRequired(){<span class="cstat-no" title="statement not covered" >return this.isRequired=!0,this}<span class="fstat-no" title="function not covered" ></span>wr</span>ite(t){let{colors:{green:r}}=<span class="cstat-no" title="statement not covered" >t.context;<span class="cstat-no" title="statement not covered" ></span>t.addMarginSymbol(r(this.isRequired?"+":"?")),t.write(r(this.name)),this.isRequired||t.write(r("?")),t.write(r(": ")),typeof this.value=="string"?t.write(r(this.value)):t.write(this.value)}</span>};var Pt=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>r){<span class="cstat-no" title="statement not covered" >this.context=r;<span class="cstat-no" title="statement not covered" >t</span>his.lines=[];<span class="cstat-no" title="statement not covered" >t</span>his.currentLine="";<span class="cstat-no" title="statement not covered" >t</span>his.currentIndent=0;<span class="cstat-no" title="statement not covered" >t</span>his.currentIndent=t}<span class="fstat-no" title="function not covered" ></span>wr</span>ite(t){<span class="cstat-no" title="statement not covered" >return typeof t=="string"?this.currentLine+=t:t.write(this),this}<span class="fstat-no" title="function not covered" ></span>wr</span>iteJoined(t,r,n=<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >(i</span>,o)=&gt;<span class="cstat-no" title="statement not covered" >o.write(i))</span></span>{let i=<span class="cstat-no" title="statement not covered" >r.length-1;<span class="cstat-no" title="statement not covered" ></span>for(let o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;r.length;o++)<span class="cstat-no" title="statement not covered" >n(r[o],this),o!==i&amp;&amp;this.write(t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this}<span class="fstat-no" title="function not covered" ></span>wr</span>iteLine(t){<span class="cstat-no" title="statement not covered" >return this.write(t).newLine()}<span class="fstat-no" title="function not covered" ></span>ne</span>wLine(){<span class="cstat-no" title="statement not covered" >this.lines.push(this.indentedCurrentLine()),this.currentLine="",this.marginSymbol=void 0;l</span>et t=<span class="cstat-no" title="statement not covered" >this.afterNextNewLineCallback;<span class="cstat-no" title="statement not covered" ></span>return this.afterNextNewLineCallback=void 0,t?.(),this}<span class="fstat-no" title="function not covered" ></span>wi</span>thIndent(t){<span class="cstat-no" title="statement not covered" >return this.indent(),t(this),this.unindent(),this}<span class="fstat-no" title="function not covered" ></span>af</span>terNextNewline(t){<span class="cstat-no" title="statement not covered" >return this.afterNextNewLineCallback=t,this}<span class="fstat-no" title="function not covered" ></span>in</span>dent(){<span class="cstat-no" title="statement not covered" >return this.currentIndent++,this}<span class="fstat-no" title="function not covered" ></span>un</span>indent(){<span class="cstat-no" title="statement not covered" >return this.currentIndent&gt;0&amp;&amp;this.currentIndent--,this}<span class="fstat-no" title="function not covered" ></span>ad</span>dMarginSymbol(t){<span class="cstat-no" title="statement not covered" >return this.marginSymbol=t,this}<span class="fstat-no" title="function not covered" ></span>to</span>String(){<span class="cstat-no" title="statement not covered" >return this.lines.concat(this.indentedCurrentLine()).join(`</span>
`)}<span class="fstat-no" title="function not covered" >ge</span>tCurrentLineLength(){<span class="cstat-no" title="statement not covered" >return this.currentLine.length}<span class="fstat-no" title="function not covered" ></span>in</span>dentedCurrentLine(){let t=<span class="cstat-no" title="statement not covered" >this.currentLine.padStart(this.currentLine.length+2*this.currentIndent);<span class="cstat-no" title="statement not covered" ></span>return this.marginSymbol?this.marginSymbol+t.slice(1):t}</span>};var dn=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.value=t}<span class="fstat-no" title="function not covered" ></span>wr</span>ite(t){<span class="cstat-no" title="statement not covered" >t.write(this.value)}<span class="fstat-no" title="function not covered" ></span>ma</span>rkAsError(){<span class="cstat-no" title="statement not covered" >this.value.markAsError()}</span>};var mn=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e,</span>fn={bold:mn,red:mn,green:mn,dim:mn,enabled:!1},Ks={bold:W,red:de,green:Ve,dim:ke,enabled:!0},Tt={<span class="fstat-no" title="function not covered" >wr</span>ite(e){<span class="cstat-no" title="statement not covered" >e.writeLine(",")}</span>};var Pe=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.contents=t;<span class="cstat-no" title="statement not covered" >t</span>his.isUnderlined=!1;<span class="cstat-no" title="statement not covered" >t</span>his.color=<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t}<span class="fstat-no" title="function not covered" ></span></span>un</span>derline(){<span class="cstat-no" title="statement not covered" >return this.isUnderlined=!0,this}<span class="fstat-no" title="function not covered" ></span>se</span>tColor(t){<span class="cstat-no" title="statement not covered" >return this.color=t,this}<span class="fstat-no" title="function not covered" ></span>wr</span>ite(t){let r=<span class="cstat-no" title="statement not covered" >t.getCurrentLineLength();<span class="cstat-no" title="statement not covered" ></span>t.write(this.color(this.contents)),this.isUnderlined&amp;&amp;t.afterNextNewline(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.write(" ".repeat(r)).writeLine(this.color("~".repeat(this.contents.length)))}</span>)}</span>};var ze=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.hasError=!1}<span class="fstat-no" title="function not covered" ></span>ma</span>rkAsError(){<span class="cstat-no" title="statement not covered" >return this.hasError=!0,this}</span>};var Rt=class extends ze{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(...arguments);<span class="cstat-no" title="statement not covered" >t</span>his.items=[]}<span class="fstat-no" title="function not covered" ></span>ad</span>dItem(r){<span class="cstat-no" title="statement not covered" >return this.items.push(new dn(r)),this}<span class="fstat-no" title="function not covered" ></span>ge</span>tField(r){<span class="cstat-no" title="statement not covered" >return this.items[r]}<span class="fstat-no" title="function not covered" ></span>ge</span>tPrintWidth(){<span class="cstat-no" title="statement not covered" >return this.items.length===0?2:Math.max(...this.items.map(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >n.value.getPrintWidth())</span>)+2}<span class="fstat-no" title="function not covered" ></span>wr</span>ite(r){<span class="cstat-no" title="statement not covered" >if(this.items.length===0){<span class="cstat-no" title="statement not covered" >this.writeEmpty(r);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>t</span>his.writeWithItems(r)}<span class="fstat-no" title="function not covered" ></span>wr</span>iteEmpty(r){let n=<span class="cstat-no" title="statement not covered" >new Pe("[]");<span class="cstat-no" title="statement not covered" ></span>this.hasError&amp;&amp;n.setColor(r.context.colors.red).underline(),r.write(n)}<span class="fstat-no" title="function not covered" ></span>wr</span>iteWithItems(r){let{colors:n}=<span class="cstat-no" title="statement not covered" >r.context;<span class="cstat-no" title="statement not covered" ></span>r.writeLine("[").withIndent(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >r.writeJoined(Tt,this.items).newLine())</span>.write("]"),this.hasError&amp;&amp;r.afterNextNewline(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >r.writeLine(n.red("~".repeat(this.getPrintWidth())))}</span>)}<span class="fstat-no" title="function not covered" ></span>as</span>Object(){}};var Ct=class e extends ze{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(...arguments);<span class="cstat-no" title="statement not covered" >t</span>his.fields={};<span class="cstat-no" title="statement not covered" >t</span>his.suggestions=[]}<span class="fstat-no" title="function not covered" ></span>ad</span>dField(r){<span class="cstat-no" title="statement not covered" >this.fields[r.name]=r}<span class="fstat-no" title="function not covered" ></span>ad</span>dSuggestion(r){<span class="cstat-no" title="statement not covered" >this.suggestions.push(r)}<span class="fstat-no" title="function not covered" ></span>ge</span>tField(r){<span class="cstat-no" title="statement not covered" >return this.fields[r]}<span class="fstat-no" title="function not covered" ></span>ge</span>tDeepField(r){let[n,...i]=<span class="cstat-no" title="statement not covered" >r,</span>o=<span class="cstat-no" title="statement not covered" >this.getField(n);<span class="cstat-no" title="statement not covered" ></span>if(!o)<span class="cstat-no" title="statement not covered" >return;l</span></span>et s=<span class="cstat-no" title="statement not covered" >o;<span class="cstat-no" title="statement not covered" ></span>for(let a of i){let l;<span class="cstat-no" title="statement not covered" >if(s.value instanceof e?l=s.value.getField(a):s.value instanceof Rt&amp;&amp;(l=s.value.getField(Number(a))),!l)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >s</span></span>=l}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}<span class="fstat-no" title="function not covered" ></span>ge</span>tDeepFieldValue(r){<span class="cstat-no" title="statement not covered" >return r.length===0?this:this.getDeepField(r)?.value}<span class="fstat-no" title="function not covered" ></span>ha</span>sField(r){<span class="cstat-no" title="statement not covered" >return!!this.getField(r)}<span class="fstat-no" title="function not covered" ></span>re</span>moveAllFields(){<span class="cstat-no" title="statement not covered" >this.fields={}}<span class="fstat-no" title="function not covered" ></span>re</span>moveField(r){<span class="cstat-no" title="statement not covered" >delete this.fields[r]}<span class="fstat-no" title="function not covered" ></span>ge</span>tFields(){<span class="cstat-no" title="statement not covered" >return this.fields}<span class="fstat-no" title="function not covered" ></span>is</span>Empty(){<span class="cstat-no" title="statement not covered" >return Object.keys(this.fields).length===0}<span class="fstat-no" title="function not covered" ></span>ge</span>tFieldValue(r){<span class="cstat-no" title="statement not covered" >return this.getField(r)?.value}<span class="fstat-no" title="function not covered" ></span>ge</span>tDeepSubSelectionValue(r){let n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>for(let i of r){<span class="cstat-no" title="statement not covered" >if(!(n instanceof e))<span class="cstat-no" title="statement not covered" >return;l</span></span>et o=<span class="cstat-no" title="statement not covered" >n.getSubSelectionValue(i);<span class="cstat-no" title="statement not covered" ></span>if(!o)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >n</span></span>=o}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}<span class="fstat-no" title="function not covered" ></span>ge</span>tDeepSelectionParent(r){let n=<span class="cstat-no" title="statement not covered" >this.getSelectionParent();<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >return;l</span></span>et i=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>for(let o of r){let s=<span class="cstat-no" title="statement not covered" >i.value.getFieldValue(o);<span class="cstat-no" title="statement not covered" ></span>if(!s||!(s instanceof e))<span class="cstat-no" title="statement not covered" >return;l</span></span>et a=<span class="cstat-no" title="statement not covered" >s.getSelectionParent();<span class="cstat-no" title="statement not covered" ></span>if(!a)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>=a}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}<span class="fstat-no" title="function not covered" ></span>ge</span>tSelectionParent(){let r=<span class="cstat-no" title="statement not covered" >this.getField("select")?.value.asObject();<span class="cstat-no" title="statement not covered" ></span>if(r)<span class="cstat-no" title="statement not covered" >return{kind:"select",value:r};l</span></span>et n=<span class="cstat-no" title="statement not covered" >this.getField("include")?.value.asObject();<span class="cstat-no" title="statement not covered" ></span>if(n)<span class="cstat-no" title="statement not covered" >return{kind:"include",value:n}}<span class="fstat-no" title="function not covered" ></span></span>ge</span>tSubSelectionValue(r){<span class="cstat-no" title="statement not covered" >return this.getSelectionParent()?.value.fields[r].value}<span class="fstat-no" title="function not covered" ></span>ge</span>tPrintWidth(){let r=<span class="cstat-no" title="statement not covered" >Object.values(this.fields);<span class="cstat-no" title="statement not covered" ></span>return r.length==0?2:Math.max(...r.map(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >i.getPrintWidth())</span>)+2}<span class="fstat-no" title="function not covered" ></span>wr</span>ite(r){let n=<span class="cstat-no" title="statement not covered" >Object.values(this.fields);<span class="cstat-no" title="statement not covered" ></span>if(n.length===0&amp;&amp;this.suggestions.length===0){<span class="cstat-no" title="statement not covered" >this.writeEmpty(r);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>t</span>his.writeWithContents(r,n)}<span class="fstat-no" title="function not covered" ></span>as</span>Object(){<span class="cstat-no" title="statement not covered" >return this}<span class="fstat-no" title="function not covered" ></span>wr</span>iteEmpty(r){let n=<span class="cstat-no" title="statement not covered" >new Pe("{}");<span class="cstat-no" title="statement not covered" ></span>this.hasError&amp;&amp;n.setColor(r.context.colors.red).underline(),r.write(n)}<span class="fstat-no" title="function not covered" ></span>wr</span>iteWithContents(r,n){<span class="cstat-no" title="statement not covered" >r.writeLine("{").withIndent(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >r.writeJoined(Tt,[...n,...this.suggestions]).newLine()}</span>),r.write("}"),this.hasError&amp;&amp;r.afterNextNewline(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >r.writeLine(r.context.colors.red("~".repeat(this.getPrintWidth())))}</span>)}</span>};var H=class extends ze{<span class="fstat-no" title="function not covered" >co</span>nstructor(r){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his.text=r}<span class="fstat-no" title="function not covered" ></span>ge</span>tPrintWidth(){<span class="cstat-no" title="statement not covered" >return this.text.length}<span class="fstat-no" title="function not covered" ></span>wr</span>ite(r){let n=<span class="cstat-no" title="statement not covered" >new Pe(this.text);<span class="cstat-no" title="statement not covered" ></span>this.hasError&amp;&amp;n.underline().setColor(r.context.colors.red),r.write(n)}<span class="fstat-no" title="function not covered" ></span>as</span>Object(){}};var nr=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.fields=[]}<span class="fstat-no" title="function not covered" ></span>ad</span>dField(t,r){<span class="cstat-no" title="statement not covered" >return this.fields.push({<span class="fstat-no" title="function not covered" >wr</span>ite(n){let{green:i,dim:o}=<span class="cstat-no" title="statement not covered" >n.context.colors;<span class="cstat-no" title="statement not covered" ></span>n.write(i(o(`${t}: ${r}`))).addMarginSymbol(i(o("+")))}</span>}),this}<span class="fstat-no" title="function not covered" ></span>wr</span>ite(t){let{colors:{green:r}}=<span class="cstat-no" title="statement not covered" >t.context;<span class="cstat-no" title="statement not covered" ></span>t.writeLine(r("{")).withIndent(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.writeJoined(Tt,this.fields).newLine()}</span>).write(r("}")).addMarginSymbol(r("+"))}</span>};function <span class="fstat-no" title="function not covered" >pn(</span>e,t,r){<span class="cstat-no" title="statement not covered" >switch(e.kind){case"MutuallyExclusiveFields":<span class="cstat-no" title="statement not covered" >Mp(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"IncludeOnScalar":<span class="cstat-no" title="statement not covered" >$p(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"EmptySelection":<span class="cstat-no" title="statement not covered" >qp(e,t,r);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"UnknownSelectionField":<span class="cstat-no" title="statement not covered" >Up(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"InvalidSelectionValue":<span class="cstat-no" title="statement not covered" >Qp(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"UnknownArgument":<span class="cstat-no" title="statement not covered" >Gp(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"UnknownInputField":<span class="cstat-no" title="statement not covered" >Jp(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"RequiredArgumentMissing":<span class="cstat-no" title="statement not covered" >Hp(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"InvalidArgumentType":<span class="cstat-no" title="statement not covered" >Wp(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"InvalidArgumentValue":<span class="cstat-no" title="statement not covered" >Kp(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"ValueTooLarge":<span class="cstat-no" title="statement not covered" >Yp(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"SomeFieldsMissing":<span class="cstat-no" title="statement not covered" >zp(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"TooManyFieldsGiven":<span class="cstat-no" title="statement not covered" >Zp(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"Union":<span class="cstat-no" title="statement not covered" >Hs(e,t,r);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error("not implemented: "+e.kind)}</span>}</span>function <span class="fstat-no" title="function not covered" >Mp(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;(r.getField(e.firstField)?.markAsError(),r.getField(e.secondField)?.markAsError()),t.addErrorMessage(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >`Please ${n.bold("either")} use ${n.green(`\`${e.firstField}\``)} or ${n.green(`\`${e.secondField}\``)}, but ${n.red("not both")} at the same time.`)</span>}</span>function <span class="fstat-no" title="function not covered" >$p(</span>e,t){let[r,n]=<span class="cstat-no" title="statement not covered" >ir(e.selectionPath),</span>i=<span class="cstat-no" title="statement not covered" >e.outputType,</span>o=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSelectionParent(r)?.value;<span class="cstat-no" title="statement not covered" ></span>if(o&amp;&amp;(o.getField(n)?.markAsError(),i))<span class="cstat-no" title="statement not covered" >for(let s of i.fields)<span class="cstat-no" title="statement not covered" >s.isRelation&amp;&amp;o.addSuggestion(new pe(s.name,"true"));<span class="cstat-no" title="statement not covered" >t</span></span></span>.addErrorMessage(<span class="fstat-no" title="function not covered" >s=</span>&gt;{let a=<span class="cstat-no" title="statement not covered" >`Invalid scalar field ${s.red(`\`${n}\``)} for ${s.bold("include")} statement`;<span class="cstat-no" title="statement not covered" ></span>return i?a+=` on model ${s.bold(i.name)}. ${or(s)}`:a+=".",a+=`</span></span>
Note that ${s.bold("include")} statements only accept relation fields.`,a})}function <span class="fstat-no" title="function not covered" >qp(</span>e,t,r){let n=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" ></span>if(n){let i=<span class="cstat-no" title="statement not covered" >n.getField("omit")?.value.asObject();<span class="cstat-no" title="statement not covered" ></span>if(i){<span class="cstat-no" title="statement not covered" >Vp(e,t,i);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(n.hasField("select")){<span class="cstat-no" title="statement not covered" >jp(e,t);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(r?.[wt(e.outputType.name)]){<span class="cstat-no" title="statement not covered" >Bp(e,t);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>t</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >`Unknown field at "${e.selectionPath.join(".")} selection"`)</span>}</span>function <span class="fstat-no" title="function not covered" >Vp(</span>e,t,r){<span class="cstat-no" title="statement not covered" >r.removeAllFields();<span class="cstat-no" title="statement not covered" >f</span>or(let n of e.outputType.fields)<span class="cstat-no" title="statement not covered" >r.addSuggestion(new pe(n.name,"false"));<span class="cstat-no" title="statement not covered" >t</span></span>.addErrorMessage(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >`The ${n.red("omit")} statement includes every field of the model ${n.bold(e.outputType.name)}. At least one field must be included in the result`)</span>}</span>function <span class="fstat-no" title="function not covered" >jp(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >e.outputType,</span>n=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSelectionParent(e.selectionPath)?.value,</span>i=<span class="cstat-no" title="statement not covered" >n?.isEmpty()??!1;<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;(n.removeAllFields(),Xs(n,r)),t.addErrorMessage(<span class="fstat-no" title="function not covered" >o=</span>&gt;<span class="cstat-no" title="statement not covered" >i?`The ${o.red("`select`")} statement for type ${o.bold(r.name)} must not be empty. ${or(o)}`:`The ${o.red("`select`")} statement for type ${o.bold(r.name)} needs ${o.bold("at least one truthy value")}.`)</span>}</span>function <span class="fstat-no" title="function not covered" >Bp(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >new nr;<span class="cstat-no" title="statement not covered" ></span>for(let i of e.outputType.fields)<span class="cstat-no" title="statement not covered" >i.isRelation||r.addField(i.name,"false");l</span></span>et n=<span class="cstat-no" title="statement not covered" >new pe("omit",r).makeRequired();<span class="cstat-no" title="statement not covered" ></span>if(e.selectionPath.length===0)<span class="cstat-no" title="statement not covered" >t.arguments.addSuggestion(n);e</span>lse{let[i,o]=<span class="cstat-no" title="statement not covered" >ir(e.selectionPath),</span>a=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSelectionParent(i)?.value.asObject()?.getField(o);<span class="cstat-no" title="statement not covered" ></span>if(a){let l=<span class="cstat-no" title="statement not covered" >a?.value.asObject()??new Ct;<span class="cstat-no" title="statement not covered" ></span>l.addSuggestion(n),a.value=l}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >`The global ${i.red("omit")} configuration excludes every field of the model ${i.bold(e.outputType.name)}. At least one field must be included in the result`)</span>}</span>function <span class="fstat-no" title="function not covered" >Up(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >ea(e.selectionPath,t);<span class="cstat-no" title="statement not covered" ></span>if(r.parentKind!=="unknown"){<span class="cstat-no" title="statement not covered" >r.field.markAsError();l</span>et n=<span class="cstat-no" title="statement not covered" >r.parent;<span class="cstat-no" title="statement not covered" ></span>switch(r.parentKind){case"select":<span class="cstat-no" title="statement not covered" >Xs(n,e.outputType);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"include":<span class="cstat-no" title="statement not covered" >Xp(n,e.outputType);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"omit":<span class="cstat-no" title="statement not covered" >ed(n,e.outputType);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >n=</span>&gt;{let i=<span class="cstat-no" title="statement not covered" >[`Unknown field ${n.red(`\`${r.fieldName}\``)}`];<span class="cstat-no" title="statement not covered" ></span>return r.parentKind!=="unknown"&amp;&amp;i.push(`for ${n.bold(r.parentKind)} statement`),i.push(`on model ${n.bold(`\`${e.outputType.name}\``)}.`),i.push(or(n)),i.join(" ")}</span>)}</span>function <span class="fstat-no" title="function not covered" >Qp(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >ea(e.selectionPath,t);<span class="cstat-no" title="statement not covered" ></span>r.parentKind!=="unknown"&amp;&amp;r.field.value.markAsError(),t.addErrorMessage(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >`Invalid value for selection field \`${n.red(r.fieldName)}\`: ${e.underlyingError}`)</span>}</span>function <span class="fstat-no" title="function not covered" >Gp(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >e.argumentPath[0],</span>n=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;(n.getField(r)?.markAsError(),td(n,e.arguments)),t.addErrorMessage(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >zs(i,r,e.arguments.map(<span class="fstat-no" title="function not covered" >o=</span>&gt;<span class="cstat-no" title="statement not covered" >o.name)</span>))</span>}</span>function <span class="fstat-no" title="function not covered" >Jp(</span>e,t){let[r,n]=<span class="cstat-no" title="statement not covered" >ir(e.argumentPath),</span>i=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" ></span>if(i){<span class="cstat-no" title="statement not covered" >i.getDeepField(e.argumentPath)?.markAsError();l</span>et o=<span class="cstat-no" title="statement not covered" >i.getDeepFieldValue(r)?.asObject();<span class="cstat-no" title="statement not covered" ></span>o&amp;&amp;ta(o,e.inputType)}<span class="cstat-no" title="statement not covered" ></span>t</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >o=</span>&gt;<span class="cstat-no" title="statement not covered" >zs(o,n,e.inputType.fields.map(<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >s.name)</span>))</span>}</span>function <span class="fstat-no" title="function not covered" >zs(</span>e,t,r){let n=<span class="cstat-no" title="statement not covered" >[`Unknown argument \`${e.red(t)}\`.`],</span>i=<span class="cstat-no" title="statement not covered" >nd(t,r);<span class="cstat-no" title="statement not covered" ></span>return i&amp;&amp;n.push(`Did you mean \`${e.green(i)}\`?`),r.length&gt;0&amp;&amp;n.push(or(e)),n.join(" ")}</span>function <span class="fstat-no" title="function not covered" >Hp(</span>e,t){let r;<span class="cstat-no" title="statement not covered" >t.addErrorMessage(<span class="fstat-no" title="function not covered" >l=</span>&gt;<span class="cstat-no" title="statement not covered" >r?.value instanceof H&amp;&amp;r.value.text==="null"?`Argument \`${l.green(o)}\` must not be ${l.red("null")}.`:`Argument \`${l.green(o)}\` is missing.`)</span>;l</span>et n=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >return;l</span></span>et[i,o]=<span class="cstat-no" title="statement not covered" >ir(e.argumentPath),</span>s=<span class="cstat-no" title="statement not covered" >new nr,</span>a=<span class="cstat-no" title="statement not covered" >n.getDeepFieldValue(i)?.asObject();<span class="cstat-no" title="statement not covered" ></span>if(a)<span class="cstat-no" title="statement not covered" >if(r=a.getField(o),r&amp;&amp;a.removeField(o),e.inputTypes.length===1&amp;&amp;e.inputTypes[0].kind==="object"){<span class="cstat-no" title="statement not covered" >for(let l of e.inputTypes[0].fields)<span class="cstat-no" title="statement not covered" >s.addField(l.name,l.typeNames.join(" | "));<span class="cstat-no" title="statement not covered" >a</span></span>.addSuggestion(new pe(o,s).makeRequired())}</span>else{let l=<span class="cstat-no" title="statement not covered" >e.inputTypes.map(Zs).join(" | ");<span class="cstat-no" title="statement not covered" ></span>a.addSuggestion(new pe(o,l).makeRequired())}</span>}</span></span>function <span class="fstat-no" title="function not covered" >Zs(</span>e){<span class="cstat-no" title="statement not covered" >return e.kind==="list"?`${Zs(e.elementType)}[]`:e.name}</span>function <span class="fstat-no" title="function not covered" >Wp(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >e.argument.name,</span>n=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;n.getDeepFieldValue(e.argumentPath)?.markAsError(),t.addErrorMessage(<span class="fstat-no" title="function not covered" >i=</span>&gt;{let o=<span class="cstat-no" title="statement not covered" >gn("or",e.argument.typeNames.map(<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >i.green(s))</span>);<span class="cstat-no" title="statement not covered" ></span>return`Argument \`${i.bold(r)}\`: Invalid value provided. Expected ${o}, provided ${i.red(e.inferredType)}.`}</span>)}</span>function <span class="fstat-no" title="function not covered" >Kp(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >e.argument.name,</span>n=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;n.getDeepFieldValue(e.argumentPath)?.markAsError(),t.addErrorMessage(<span class="fstat-no" title="function not covered" >i=</span>&gt;{let o=<span class="cstat-no" title="statement not covered" >[`Invalid value for argument \`${i.bold(r)}\``];<span class="cstat-no" title="statement not covered" ></span>if(e.underlyingError&amp;&amp;o.push(`: ${e.underlyingError}`),o.push("."),e.argument.typeNames.length&gt;0){let s=<span class="cstat-no" title="statement not covered" >gn("or",e.argument.typeNames.map(<span class="fstat-no" title="function not covered" >a=</span>&gt;<span class="cstat-no" title="statement not covered" >i.green(a))</span>);<span class="cstat-no" title="statement not covered" ></span>o.push(` Expected ${s}.`)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn o.join("")}</span>)}</span>function <span class="fstat-no" title="function not covered" >Yp(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >e.argument.name,</span>n=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject(),</span>i;<span class="cstat-no" title="statement not covered" >if(n){let s=<span class="cstat-no" title="statement not covered" >n.getDeepField(e.argumentPath)?.value;<span class="cstat-no" title="statement not covered" ></span>s?.markAsError(),s instanceof H&amp;&amp;(i=s.text)}<span class="cstat-no" title="statement not covered" ></span>t</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >o=</span>&gt;{let s=<span class="cstat-no" title="statement not covered" >["Unable to fit value"];<span class="cstat-no" title="statement not covered" ></span>return i&amp;&amp;s.push(o.red(i)),s.push(`into a 64-bit signed integer for field \`${o.bold(r)}\``),s.join(" ")}</span>)}</span>function <span class="fstat-no" title="function not covered" >zp(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >e.argumentPath[e.argumentPath.length-1],</span>n=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" ></span>if(n){let i=<span class="cstat-no" title="statement not covered" >n.getDeepFieldValue(e.argumentPath)?.asObject();<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;ta(i,e.inputType)}<span class="cstat-no" title="statement not covered" ></span>t</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >i=</span>&gt;{let o=<span class="cstat-no" title="statement not covered" >[`Argument \`${i.bold(r)}\` of type ${i.bold(e.inputType.name)} needs`];<span class="cstat-no" title="statement not covered" ></span>return e.constraints.minFieldCount===1?e.constraints.requiredFields?o.push(`${i.green("at least one of")} ${gn("or",e.constraints.requiredFields.map(<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >`\`${i.bold(s)}\``)</span>)} arguments.`):o.push(`${i.green("at least one")} argument.`):o.push(`${i.green(`at least ${e.constraints.minFieldCount}`)} arguments.`),o.push(or(i)),o.join(" ")}</span>)}</span>function <span class="fstat-no" title="function not covered" >Zp(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >e.argumentPath[e.argumentPath.length-1],</span>n=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject(),</span>i=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(n){let o=<span class="cstat-no" title="statement not covered" >n.getDeepFieldValue(e.argumentPath)?.asObject();<span class="cstat-no" title="statement not covered" ></span>o&amp;&amp;(o.markAsError(),i=Object.keys(o.getFields()))}<span class="cstat-no" title="statement not covered" ></span>t</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >o=</span>&gt;{let s=<span class="cstat-no" title="statement not covered" >[`Argument \`${o.bold(r)}\` of type ${o.bold(e.inputType.name)} needs`];<span class="cstat-no" title="statement not covered" ></span>return e.constraints.minFieldCount===1&amp;&amp;e.constraints.maxFieldCount==1?s.push(`${o.green("exactly one")} argument,`):e.constraints.maxFieldCount==1?s.push(`${o.green("at most one")} argument,`):s.push(`${o.green(`at most ${e.constraints.maxFieldCount}`)} arguments,`),s.push(`but you provided ${gn("and",i.map(<span class="fstat-no" title="function not covered" >a=</span>&gt;<span class="cstat-no" title="statement not covered" >o.red(a))</span>)}. Please choose`),e.constraints.maxFieldCount===1?s.push("one."):s.push(`${e.constraints.maxFieldCount}.`),s.join(" ")}</span>)}</span>function <span class="fstat-no" title="function not covered" >Xs(</span>e,t){<span class="cstat-no" title="statement not covered" >for(let r of t.fields)<span class="cstat-no" title="statement not covered" >e.hasField(r.name)||e.addSuggestion(new pe(r.name,"true"))}</span></span>function <span class="fstat-no" title="function not covered" >Xp(</span>e,t){<span class="cstat-no" title="statement not covered" >for(let r of t.fields)<span class="cstat-no" title="statement not covered" >r.isRelation&amp;&amp;!e.hasField(r.name)&amp;&amp;e.addSuggestion(new pe(r.name,"true"))}</span></span>function <span class="fstat-no" title="function not covered" >ed(</span>e,t){<span class="cstat-no" title="statement not covered" >for(let r of t.fields)<span class="cstat-no" title="statement not covered" >!e.hasField(r.name)&amp;&amp;!r.isRelation&amp;&amp;e.addSuggestion(new pe(r.name,"true"))}</span></span>function <span class="fstat-no" title="function not covered" >td(</span>e,t){<span class="cstat-no" title="statement not covered" >for(let r of t)<span class="cstat-no" title="statement not covered" >e.hasField(r.name)||e.addSuggestion(new pe(r.name,r.typeNames.join(" | ")))}</span></span>function <span class="fstat-no" title="function not covered" >ea(</span>e,t){let[r,n]=<span class="cstat-no" title="statement not covered" >ir(e),</span>i=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSubSelectionValue(r)?.asObject();<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >return{parentKind:"unknown",fieldName:n};l</span></span>et o=<span class="cstat-no" title="statement not covered" >i.getFieldValue("select")?.asObject(),</span>s=<span class="cstat-no" title="statement not covered" >i.getFieldValue("include")?.asObject(),</span>a=<span class="cstat-no" title="statement not covered" >i.getFieldValue("omit")?.asObject(),</span>l=<span class="cstat-no" title="statement not covered" >o?.getField(n);<span class="cstat-no" title="statement not covered" ></span>return o&amp;&amp;l?{parentKind:"select",parent:o,field:l,fieldName:n}:(l=s?.getField(n),s&amp;&amp;l?{parentKind:"include",field:l,parent:s,fieldName:n}:(l=a?.getField(n),a&amp;&amp;l?{parentKind:"omit",field:l,parent:a,fieldName:n}:{parentKind:"unknown",fieldName:n}))}</span>function <span class="fstat-no" title="function not covered" >ta(</span>e,t){<span class="cstat-no" title="statement not covered" >if(t.kind==="object")<span class="cstat-no" title="statement not covered" >for(let r of t.fields)<span class="cstat-no" title="statement not covered" >e.hasField(r.name)||e.addSuggestion(new pe(r.name,r.typeNames.join(" | ")))}</span></span></span>function <span class="fstat-no" title="function not covered" >ir(</span>e){let t=<span class="cstat-no" title="statement not covered" >[...e],</span>r=<span class="cstat-no" title="statement not covered" >t.pop();<span class="cstat-no" title="statement not covered" ></span>if(!r)<span class="cstat-no" title="statement not covered" >throw new Error("unexpected empty path");<span class="cstat-no" title="statement not covered" >r</span></span>eturn[t,r]}</span>function <span class="fstat-no" title="function not covered" >or(</span>{green:e,enabled:t}){<span class="cstat-no" title="statement not covered" >return"Available options are "+(t?`listed in ${e("green")}`:"marked with ?")+"."}</span>function <span class="fstat-no" title="function not covered" >gn(</span>e,t){<span class="cstat-no" title="statement not covered" >if(t.length===1)<span class="cstat-no" title="statement not covered" >return t[0];l</span></span>et r=<span class="cstat-no" title="statement not covered" >[...t],</span>n=<span class="cstat-no" title="statement not covered" >r.pop();<span class="cstat-no" title="statement not covered" ></span>return`${r.join(", ")} ${e} ${n}`}</span>var rd=3;function <span class="fstat-no" title="function not covered" >nd(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >1/0,</span>n;<span class="cstat-no" title="statement not covered" >for(let i of t){let o=<span class="cstat-no" title="statement not covered" >(0,Ys.default)(e,i);<span class="cstat-no" title="statement not covered" ></span>o&gt;rd||o&lt;r&amp;&amp;(r=o,n=i)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}</span>function <span class="fstat-no" title="function not covered" >ra(</span>e){<span class="cstat-no" title="statement not covered" >return e.substring(0,1).toLowerCase()+e.substring(1)}</span>var sr=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,r,n,i,o){<span class="cstat-no" title="statement not covered" >this.modelName=t,this.name=r,this.typeName=n,this.isList=i,this.isEnum=o}<span class="fstat-no" title="function not covered" ></span>_t</span>oGraphQLInputType(){let t=<span class="cstat-no" title="statement not covered" >this.isList?"List":"",</span>r=<span class="cstat-no" title="statement not covered" >this.isEnum?"Enum":"";<span class="cstat-no" title="statement not covered" ></span>return`${t}${r}${this.typeName}FieldRefInput&lt;${this.modelName}&gt;`}</span>};function St(e){return e instanceof sr}var hn=Symbol(),Ni=new WeakMap,$e=class{constructor(t){t===hn?Ni.set(this,`Prisma.${this._getName()}`):<span class="branch-1 cbranch-no" title="branch not covered" >Ni.set(this,`new Prisma.${this._getNamespace()}.${this._getName()}()`)}</span>_getName(){return this.constructor.name}<span class="fstat-no" title="function not covered" >to</span>String(){<span class="cstat-no" title="statement not covered" >return Ni.get(this)}</span>},ar=class extends $e{<span class="fstat-no" title="function not covered" >_g</span>etNamespace(){<span class="cstat-no" title="statement not covered" >return"NullTypes"}</span>},lr=class extends ar{};Li(lr,"DbNull");var ur=class extends ar{};Li(ur,"JsonNull");var cr=class extends ar{};Li(cr,"AnyNull");var yn={classes:{DbNull:lr,JsonNull:ur,AnyNull:cr},instances:{DbNull:new lr(hn),JsonNull:new ur(hn),AnyNull:new cr(hn)}};function Li(e,t){Object.defineProperty(e,"name",{value:t,configurable:!0})}var na=": ",En=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,r){<span class="cstat-no" title="statement not covered" >this.name=t;<span class="cstat-no" title="statement not covered" >t</span>his.value=r;<span class="cstat-no" title="statement not covered" >t</span>his.hasError=!1}<span class="fstat-no" title="function not covered" ></span>ma</span>rkAsError(){<span class="cstat-no" title="statement not covered" >this.hasError=!0}<span class="fstat-no" title="function not covered" ></span>ge</span>tPrintWidth(){<span class="cstat-no" title="statement not covered" >return this.name.length+this.value.getPrintWidth()+na.length}<span class="fstat-no" title="function not covered" ></span>wr</span>ite(t){let r=<span class="cstat-no" title="statement not covered" >new Pe(this.name);<span class="cstat-no" title="statement not covered" ></span>this.hasError&amp;&amp;r.underline().setColor(t.context.colors.red),t.write(r).write(na).write(this.value)}</span>};var Fi=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.errorMessages=[];<span class="cstat-no" title="statement not covered" >t</span>his.arguments=t}<span class="fstat-no" title="function not covered" ></span>wr</span>ite(t){<span class="cstat-no" title="statement not covered" >t.write(this.arguments)}<span class="fstat-no" title="function not covered" ></span>ad</span>dErrorMessage(t){<span class="cstat-no" title="statement not covered" >this.errorMessages.push(t)}<span class="fstat-no" title="function not covered" ></span>re</span>nderAllMessages(t){<span class="cstat-no" title="statement not covered" >return this.errorMessages.map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >r(t))</span>.join(`</span>
`)}};function <span class="fstat-no" title="function not covered" >At(</span>e){<span class="cstat-no" title="statement not covered" >return new Fi(ia(e))}</span>function <span class="fstat-no" title="function not covered" >ia(</span>e){let t=<span class="cstat-no" title="statement not covered" >new Ct;<span class="cstat-no" title="statement not covered" ></span>for(let[r,n]of Object.entries(e)){let i=<span class="cstat-no" title="statement not covered" >new En(r,oa(n));<span class="cstat-no" title="statement not covered" ></span>t.addField(i)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >oa(</span>e){<span class="cstat-no" title="statement not covered" >if(typeof e=="string")<span class="cstat-no" title="statement not covered" >return new H(JSON.stringify(e));<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof e=="number"||typeof e=="boolean")<span class="cstat-no" title="statement not covered" >return new H(String(e));<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof e=="bigint")<span class="cstat-no" title="statement not covered" >return new H(`${e}n`);<span class="cstat-no" title="statement not covered" >i</span></span>f(e===null)<span class="cstat-no" title="statement not covered" >return new H("null");<span class="cstat-no" title="statement not covered" >i</span></span>f(e===void 0)<span class="cstat-no" title="statement not covered" >return new H("undefined");<span class="cstat-no" title="statement not covered" >i</span></span>f(vt(e))<span class="cstat-no" title="statement not covered" >return new H(`new Prisma.Decimal("${e.toFixed()}")`);<span class="cstat-no" title="statement not covered" >i</span></span>f(e instanceof Uint8Array)<span class="cstat-no" title="statement not covered" >return Buffer.isBuffer(e)?new H(`Buffer.alloc(${e.byteLength})`):new H(`new Uint8Array(${e.byteLength})`);<span class="cstat-no" title="statement not covered" >i</span></span>f(e instanceof Date){let t=<span class="cstat-no" title="statement not covered" >an(e)?e.toISOString():"Invalid Date";<span class="cstat-no" title="statement not covered" ></span>return new H(`new Date("${t}")`)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e instanceof $e?new H(`Prisma.${e._getName()}`):St(e)?new H(`prisma.${ra(e.modelName)}.$fields.${e.name}`):Array.isArray(e)?id(e):typeof e=="object"?ia(e):new H(Object.prototype.toString.call(e))}</span>function <span class="fstat-no" title="function not covered" >id(</span>e){let t=<span class="cstat-no" title="statement not covered" >new Rt;<span class="cstat-no" title="statement not covered" ></span>for(let r of e)<span class="cstat-no" title="statement not covered" >t.addItem(oa(r));<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>function <span class="fstat-no" title="function not covered" >bn(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >t==="pretty"?Ks:fn,</span>n=<span class="cstat-no" title="statement not covered" >e.renderAllMessages(r),</span>i=<span class="cstat-no" title="statement not covered" >new Pt(0,{colors:r}).write(e).toString();<span class="cstat-no" title="statement not covered" ></span>return{message:n,args:i}}</span>function <span class="fstat-no" title="function not covered" >wn(</span>{args:e,errors:t,errorFormat:r,callsite:n,originalMethod:i,clientVersion:o,globalOmit:s}){let a=<span class="cstat-no" title="statement not covered" >At(e);<span class="cstat-no" title="statement not covered" ></span>for(let p of t)<span class="cstat-no" title="statement not covered" >pn(p,a,s);l</span></span>et{message:l,args:u}=<span class="cstat-no" title="statement not covered" >bn(a,r),</span>c=<span class="cstat-no" title="statement not covered" >cn({message:l,callsite:n,originalMethod:i,showColors:r==="pretty",callArguments:u});<span class="cstat-no" title="statement not covered" ></span>throw new te(c,{clientVersion:o})}</span>var Te=class{constructor(){this._map=new Map}<span class="fstat-no" title="function not covered" >ge</span>t(t){<span class="cstat-no" title="statement not covered" >return this._map.get(t)?.value}</span>set(t,r){this._map.set(t,{value:r})}getOrCreate(t,r){let n=this._map.get(t);<span class="missing-if-branch" title="if path not taken" >I</span>if(n)<span class="cstat-no" title="statement not covered" >return n.value;l</span>et i=r();return this.set(t,i),i}};function pr(e){let t;return{<span class="fstat-no" title="function not covered" >ge</span>t(){<span class="cstat-no" title="statement not covered" >return t||(t={value:e()}),t.value}</span>}}function Re(e){return e.replace(/^./,t=&gt;t.toLowerCase())}function <span class="fstat-no" title="function not covered" >aa(</span>e,t,r){let n=<span class="cstat-no" title="statement not covered" >Re(r);<span class="cstat-no" title="statement not covered" ></span>return!t.result||!(t.result.$allModels||t.result[n])?e:od({...e,...sa(t.name,e,t.result.$allModels),...sa(t.name,e,t.result[n])})}</span>function <span class="fstat-no" title="function not covered" >od(</span>e){let t=<span class="cstat-no" title="statement not covered" >new Te,</span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(n</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >t.getOrCreate(n,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >i.has(n)?[n]:(i.add(n),e[n]?e[n].needs.flatMap(<span class="fstat-no" title="function not covered" >o=</span>&gt;<span class="cstat-no" title="statement not covered" >r(o,i))</span>:[n]))</span>;<span class="cstat-no" title="statement not covered" ></span></span>return ht(e,<span class="fstat-no" title="function not covered" >n=</span>&gt;(<span class="cstat-no" title="statement not covered" >{...n,needs:r(n.name,new Set)})</span>)}</span>function <span class="fstat-no" title="function not covered" >sa(</span>e,t,r){<span class="cstat-no" title="statement not covered" >return r?ht(r,<span class="fstat-no" title="function not covered" >({</span>needs:n,compute:i},o)=&gt;(<span class="cstat-no" title="statement not covered" >{name:o,needs:n?Object.keys(n).filter(<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >n[s])</span>:[],compute:sd(t,o,i)})</span>):{}}</span>function <span class="fstat-no" title="function not covered" >sd(</span>e,t,r){let n=<span class="cstat-no" title="statement not covered" >e?.[t]?.compute;<span class="cstat-no" title="statement not covered" ></span>return n?<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >r({...i,[t]:n(i)}):</span>r}</span>function <span class="fstat-no" title="function not covered" >la(</span>e,t){<span class="cstat-no" title="statement not covered" >if(!t)<span class="cstat-no" title="statement not covered" >return e;l</span></span>et r=<span class="cstat-no" title="statement not covered" >{...e};<span class="cstat-no" title="statement not covered" ></span>for(let n of Object.values(t))<span class="cstat-no" title="statement not covered" >if(e[n.name])<span class="cstat-no" title="statement not covered" >for(let i of n.needs)<span class="cstat-no" title="statement not covered" >r[i]=!0;<span class="cstat-no" title="statement not covered" >r</span></span></span></span>eturn r}</span>function ua(e,t){<span class="missing-if-branch" title="else path not taken" >E</span>if(!t)return e;let r=<span class="cstat-no" title="statement not covered" >{...e};<span class="cstat-no" title="statement not covered" ></span>for(let n of Object.values(t))<span class="cstat-no" title="statement not covered" >if(!e[n.name])<span class="cstat-no" title="statement not covered" >for(let i of n.needs)<span class="cstat-no" title="statement not covered" >delete r[i];<span class="cstat-no" title="statement not covered" >r</span></span></span></span>eturn r}</span>var xn=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,r){<span class="cstat-no" title="statement not covered" >this.extension=t;<span class="cstat-no" title="statement not covered" >t</span>his.previous=r;<span class="cstat-no" title="statement not covered" >t</span>his.computedFieldsCache=new Te;<span class="cstat-no" title="statement not covered" >t</span>his.modelExtensionsCache=new Te;<span class="cstat-no" title="statement not covered" >t</span>his.queryCallbacksCache=new Te;<span class="cstat-no" title="statement not covered" >t</span>his.clientExtensions=pr(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.extension.client?{...this.previous?.getAllClientExtensions(),...this.extension.client}:this.previous?.getAllClientExtensions())</span>;<span class="cstat-no" title="statement not covered" >t</span>his.batchCallbacks=pr(<span class="fstat-no" title="function not covered" >()</span>=&gt;{let t=<span class="cstat-no" title="statement not covered" >this.previous?.getAllBatchQueryCallbacks()??[],</span>r=<span class="cstat-no" title="statement not covered" >this.extension.query?.$__internalBatch;<span class="cstat-no" title="statement not covered" ></span>return r?t.concat(r):t}</span>)}<span class="fstat-no" title="function not covered" ></span>ge</span>tAllComputedFields(t){<span class="cstat-no" title="statement not covered" >return this.computedFieldsCache.getOrCreate(t,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >aa(this.previous?.getAllComputedFields(t),this.extension,t))</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>tAllClientExtensions(){<span class="cstat-no" title="statement not covered" >return this.clientExtensions.get()}<span class="fstat-no" title="function not covered" ></span>ge</span>tAllModelExtensions(t){<span class="cstat-no" title="statement not covered" >return this.modelExtensionsCache.getOrCreate(t,<span class="fstat-no" title="function not covered" >()</span>=&gt;{let r=<span class="cstat-no" title="statement not covered" >Re(t);<span class="cstat-no" title="statement not covered" ></span>return!this.extension.model||!(this.extension.model[r]||this.extension.model.$allModels)?this.previous?.getAllModelExtensions(t):{...this.previous?.getAllModelExtensions(t),...this.extension.model.$allModels,...this.extension.model[r]}}</span>)}<span class="fstat-no" title="function not covered" ></span>ge</span>tAllQueryCallbacks(t,r){<span class="cstat-no" title="statement not covered" >return this.queryCallbacksCache.getOrCreate(`${t}:${r}`,<span class="fstat-no" title="function not covered" >()</span>=&gt;{let n=<span class="cstat-no" title="statement not covered" >this.previous?.getAllQueryCallbacks(t,r)??[],</span>i=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >this.extension.query;<span class="cstat-no" title="statement not covered" ></span>return!o||!(o[t]||o.$allModels||o[r]||o.$allOperations)?n:(o[t]!==void 0&amp;&amp;(o[t][r]!==void 0&amp;&amp;i.push(o[t][r]),o[t].$allOperations!==void 0&amp;&amp;i.push(o[t].$allOperations)),t!=="$none"&amp;&amp;o.$allModels!==void 0&amp;&amp;(o.$allModels[r]!==void 0&amp;&amp;i.push(o.$allModels[r]),o.$allModels.$allOperations!==void 0&amp;&amp;i.push(o.$allModels.$allOperations)),o[r]!==void 0&amp;&amp;i.push(o[r]),o.$allOperations!==void 0&amp;&amp;i.push(o.$allOperations),n.concat(i))}</span>)}<span class="fstat-no" title="function not covered" ></span>ge</span>tAllBatchQueryCallbacks(){<span class="cstat-no" title="statement not covered" >return this.batchCallbacks.get()}</span>},It=class e{constructor(t){this.head=t}static empty(){return new e}<span class="fstat-no" title="function not covered" >st</span>atic single(t){<span class="cstat-no" title="statement not covered" >return new e(new xn(t))}</span>isEmpty(){return this.head===void 0}<span class="fstat-no" title="function not covered" >ap</span>pend(t){<span class="cstat-no" title="statement not covered" >return new e(new xn(t,this.head))}</span>getAllComputedFields(t){return this.head?.getAllComputedFields(t)}getAllClientExtensions(){return this.head?.getAllClientExtensions()}getAllModelExtensions(t){return this.head?.getAllModelExtensions(t)}<span class="fstat-no" title="function not covered" >ge</span>tAllQueryCallbacks(t,r){<span class="cstat-no" title="statement not covered" >return this.head?.getAllQueryCallbacks(t,r)??[]}<span class="fstat-no" title="function not covered" ></span>ge</span>tAllBatchQueryCallbacks(){<span class="cstat-no" title="statement not covered" >return this.head?.getAllBatchQueryCallbacks()??[]}</span>};var ca=Symbol(),dr=class{constructor(t){<span class="missing-if-branch" title="if path not taken" >I</span>if(t!==ca)<span class="cstat-no" title="statement not covered" >throw new Error("Skip instance can not be constructed directly")}<span class="fstat-no" title="function not covered" ></span>if</span>Undefined(t){<span class="cstat-no" title="statement not covered" >return t===void 0?vn:t}</span>},vn=new dr(ca);function Ce(e){return e instanceof dr}var ad={findUnique:"findUnique",findUniqueOrThrow:"findUniqueOrThrow",findFirst:"findFirst",findFirstOrThrow:"findFirstOrThrow",findMany:"findMany",count:"aggregate",create:"createOne",createMany:"createMany",createManyAndReturn:"createManyAndReturn",update:"updateOne",updateMany:"updateMany",updateManyAndReturn:"updateManyAndReturn",upsert:"upsertOne",delete:"deleteOne",deleteMany:"deleteMany",executeRaw:"executeRaw",queryRaw:"queryRaw",aggregate:"aggregate",groupBy:"groupBy",runCommandRaw:"runCommandRaw",findRaw:"findRaw",aggregateRaw:"aggregateRaw"},pa="explicitly `undefined` values are not allowed";function Pn({modelName:e,action:t,args:r,runtimeDataModel:n,extensions:i=<span class="branch-0 cbranch-no" title="branch not covered" >It.empty(),</span>callsite:o,clientMethod:s,errorFormat:a,clientVersion:l,previewFeatures:u,globalOmit:c}){let p=new Mi({runtimeDataModel:n,modelName:e,action:t,rootArgs:r,callsite:o,extensions:i,selectionPath:[],argumentPath:[],originalMethod:s,errorFormat:a,clientVersion:l,previewFeatures:u,globalOmit:c});return{modelName:e,action:ad[t],query:mr(r,p)}}function mr({select:e,include:t,...r}=<span class="branch-0 cbranch-no" title="branch not covered" >{},</span>n){let i=r.omit;return delete r.omit,{arguments:ma(r,n),selection:ld(e,t,i,n)}}function ld(e,t,r,n){return e?(<span class="branch-0 cbranch-no" title="branch not covered" >t?n.throwValidationError({kind:"MutuallyExclusiveFields",firstField:"include",secondField:"select",selectionPath:n.getSelectionPath()}):r&amp;&amp;n.throwValidationError({kind:"MutuallyExclusiveFields",firstField:"omit",secondField:"select",selectionPath:n.getSelectionPath()}),dd(e,n))</span>:ud(n,t,r)}function ud(e,t,r){let n={};return e.modelOrType&amp;&amp;!e.isRawAction()&amp;&amp;(n.$composites=!0,n.$scalars=!0),t&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >cd(n,t,e),</span>pd(n,r,e),n}function <span class="fstat-no" title="function not covered" >cd(</span>e,t,r){<span class="cstat-no" title="statement not covered" >for(let[n,i]of Object.entries(t)){<span class="cstat-no" title="statement not covered" >if(Ce(i))<span class="cstat-no" title="statement not covered" >continue;l</span></span>et o=<span class="cstat-no" title="statement not covered" >r.nestSelection(n);<span class="cstat-no" title="statement not covered" ></span>if($i(i,o),i===!1||i===void 0){<span class="cstat-no" title="statement not covered" >e[n]=!1;<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>l</span>et s=<span class="cstat-no" title="statement not covered" >r.findField(n);<span class="cstat-no" title="statement not covered" ></span>if(s&amp;&amp;s.kind!=="object"&amp;&amp;r.throwValidationError({kind:"IncludeOnScalar",selectionPath:r.getSelectionPath().concat(n),outputType:r.getOutputTypeDescription()}),s){<span class="cstat-no" title="statement not covered" >e[n]=mr(i===!0?{}:i,o);<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(i===!0){<span class="cstat-no" title="statement not covered" >e[n]=!0;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>e</span>[n]=mr(i,o)}</span>}</span>function pd(e,t,r){let n=r.getComputedFields(),i={...r.getGlobalOmit(),...t},o=ua(i,n);for(let[s,a]of Object.entries(o)){<span class="cstat-no" title="statement not covered" >if(Ce(a))<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >$</span></span>i(a,r.nestSelection(s));l</span>et l=<span class="cstat-no" title="statement not covered" >r.findField(s);<span class="cstat-no" title="statement not covered" ></span>n?.[s]&amp;&amp;!l||(e[s]=!a)}</span>}function <span class="fstat-no" title="function not covered" >dd(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >{},</span>n=<span class="cstat-no" title="statement not covered" >t.getComputedFields(),</span>i=<span class="cstat-no" title="statement not covered" >la(e,n);<span class="cstat-no" title="statement not covered" ></span>for(let[o,s]of Object.entries(i)){<span class="cstat-no" title="statement not covered" >if(Ce(s))<span class="cstat-no" title="statement not covered" >continue;l</span></span>et a=<span class="cstat-no" title="statement not covered" >t.nestSelection(o);<span class="cstat-no" title="statement not covered" ></span>$i(s,a);l</span>et l=<span class="cstat-no" title="statement not covered" >t.findField(o);<span class="cstat-no" title="statement not covered" ></span>if(!(n?.[o]&amp;&amp;!l)){<span class="cstat-no" title="statement not covered" >if(s===!1||s===void 0||Ce(s)){<span class="cstat-no" title="statement not covered" >r[o]=!1;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(s===!0){<span class="cstat-no" title="statement not covered" >l?.kind==="object"?r[o]=mr({},a):r[o]=!0;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>r</span>[o]=mr(s,a)}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>function da(e,t){<span class="missing-if-branch" title="if path not taken" >I</span>if(e===null)<span class="cstat-no" title="statement not covered" >return null;i</span>f(typeof e=="string"||typeof e=="number"||typeof e=="boolean")return e;<span class="missing-if-branch" title="if path not taken" >I</span>if(typeof e=="bigint")<span class="cstat-no" title="statement not covered" >return{$type:"BigInt",value:String(e)};<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(xt(e)){<span class="cstat-no" title="statement not covered" >if(an(e))<span class="cstat-no" title="statement not covered" >return{$type:"DateTime",value:e.toISOString()};<span class="cstat-no" title="statement not covered" >t</span></span>.throwValidationError({kind:"InvalidArgumentValue",selectionPath:t.getSelectionPath(),argumentPath:t.getArgumentPath(),argument:{name:t.getArgumentName(),typeNames:["Date"]},underlyingError:"Provided Date object is invalid"})}<span class="missing-if-branch" title="if path not taken" >I</span></span>if(St(e))<span class="cstat-no" title="statement not covered" >return{$type:"FieldRef",value:{_ref:e.name,_container:e.modelName}};<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(Array.isArray(e))<span class="cstat-no" title="statement not covered" >return md(e,t);<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(ArrayBuffer.isView(e)){let{buffer:r,byteOffset:n,byteLength:i}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return{$type:"Bytes",value:Buffer.from(r,n,i).toString("base64")}}<span class="missing-if-branch" title="if path not taken" >I</span></span>if(fd(e))<span class="cstat-no" title="statement not covered" >return e.values;<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(vt(e))<span class="cstat-no" title="statement not covered" >return{$type:"Decimal",value:e.toFixed()};<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(e instanceof $e){<span class="cstat-no" title="statement not covered" >if(e!==yn.instances[e._getName()])<span class="cstat-no" title="statement not covered" >throw new Error("Invalid ObjectEnumValue");<span class="cstat-no" title="statement not covered" >r</span></span>eturn{$type:"Enum",value:e._getName()}}<span class="missing-if-branch" title="if path not taken" >I</span></span>if(gd(e))<span class="cstat-no" title="statement not covered" >return e.toJSON();<span class="missing-if-branch" title="else path not taken" >E</span>i</span>f(typeof e=="object")return ma(e,t);<span class="cstat-no" title="statement not covered" >t.throwValidationError({kind:"InvalidArgumentValue",selectionPath:t.getSelectionPath(),argumentPath:t.getArgumentPath(),argument:{name:t.getArgumentName(),typeNames:[]},underlyingError:`We could not serialize ${Object.prototype.toString.call(e)} value. Serialize the object to JSON or implement a ".toJSON()" method on it`})}</span>function ma(e,t){<span class="missing-if-branch" title="if path not taken" >I</span>if(e.$type)<span class="cstat-no" title="statement not covered" >return{$type:"Raw",value:e};l</span>et r={};for(let n in e){let i=e[n],o=t.nestArgument(n);Ce(i)||(i!==void 0?r[n]=da(i,o):<span class="branch-1 cbranch-no" title="branch not covered" >t.isPreviewFeatureOn("strictUndefinedChecks")&amp;&amp;t.throwValidationError({kind:"InvalidArgumentValue",argumentPath:o.getArgumentPath(),selectionPath:t.getSelectionPath(),argument:{name:t.getArgumentName(),typeNames:[]},underlyingError:pa}))</span>}return r}function <span class="fstat-no" title="function not covered" >md(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;e.length;n++){let i=<span class="cstat-no" title="statement not covered" >t.nestArgument(String(n)),</span>o=<span class="cstat-no" title="statement not covered" >e[n];<span class="cstat-no" title="statement not covered" ></span>if(o===void 0||Ce(o)){let s=<span class="cstat-no" title="statement not covered" >o===void 0?"undefined":"Prisma.skip";<span class="cstat-no" title="statement not covered" ></span>t.throwValidationError({kind:"InvalidArgumentValue",selectionPath:i.getSelectionPath(),argumentPath:i.getArgumentPath(),argument:{name:`${t.getArgumentName()}[${n}]`,typeNames:[]},underlyingError:`Can not use \`${s}\` value within array. Use \`null\` or filter out \`${s}\` values`})}<span class="cstat-no" title="statement not covered" ></span>r</span>.push(da(o,i))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>function fd(e){return typeof e=="object"&amp;&amp;e!==null&amp;&amp;e.__prismaRawParameters__===!0}function gd(e){return typeof e=="object"&amp;&amp;e!==null&amp;&amp;typeof e.toJSON=="function"}function <span class="fstat-no" title="function not covered" >$i(</span>e,t){<span class="cstat-no" title="statement not covered" >e===void 0&amp;&amp;t.isPreviewFeatureOn("strictUndefinedChecks")&amp;&amp;t.throwValidationError({kind:"InvalidSelectionValue",selectionPath:t.getSelectionPath(),underlyingError:pa})}</span>var Mi=class e{constructor(t){this.params=t;this.params.modelName&amp;&amp;(this.modelOrType=this.params.runtimeDataModel.models[this.params.modelName]??<span class="branch-1 cbranch-no" title="branch not covered" >this.params.runtimeDataModel.types[this.params.modelName])</span>}<span class="fstat-no" title="function not covered" >th</span>rowValidationError(t){<span class="cstat-no" title="statement not covered" >wn({errors:[t],originalMethod:this.params.originalMethod,args:this.params.rootArgs??{},callsite:this.params.callsite,errorFormat:this.params.errorFormat,clientVersion:this.params.clientVersion,globalOmit:this.params.globalOmit})}<span class="fstat-no" title="function not covered" ></span>ge</span>tSelectionPath(){<span class="cstat-no" title="statement not covered" >return this.params.selectionPath}<span class="fstat-no" title="function not covered" ></span>ge</span>tArgumentPath(){<span class="cstat-no" title="statement not covered" >return this.params.argumentPath}<span class="fstat-no" title="function not covered" ></span>ge</span>tArgumentName(){<span class="cstat-no" title="statement not covered" >return this.params.argumentPath[this.params.argumentPath.length-1]}<span class="fstat-no" title="function not covered" ></span>ge</span>tOutputTypeDescription(){<span class="cstat-no" title="statement not covered" >if(!(!this.params.modelName||!this.modelOrType))<span class="cstat-no" title="statement not covered" >return{name:this.params.modelName,fields:this.modelOrType.fields.map(<span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >{name:t.name,typeName:"boolean",isRelation:t.kind==="object"})</span>)}}</span></span>isRawAction(){return["executeRaw","queryRaw","runCommandRaw","findRaw","aggregateRaw"].includes(this.params.action)}<span class="fstat-no" title="function not covered" >is</span>PreviewFeatureOn(t){<span class="cstat-no" title="statement not covered" >return this.params.previewFeatures.includes(t)}</span>getComputedFields(){<span class="missing-if-branch" title="else path not taken" >E</span>if(this.params.modelName)return this.params.extensions.getAllComputedFields(this.params.modelName)}<span class="fstat-no" title="function not covered" >fi</span>ndField(t){<span class="cstat-no" title="statement not covered" >return this.modelOrType?.fields.find(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >r.name===t)</span>}<span class="fstat-no" title="function not covered" ></span>ne</span>stSelection(t){let r=<span class="cstat-no" title="statement not covered" >this.findField(t),</span>n=<span class="cstat-no" title="statement not covered" >r?.kind==="object"?r.type:void 0;<span class="cstat-no" title="statement not covered" ></span>return new e({...this.params,modelName:n,selectionPath:this.params.selectionPath.concat(t)})}</span>getGlobalOmit(){return this.params.modelName&amp;&amp;this.shouldApplyGlobalOmit()?this.params.globalOmit?.[wt(this.params.modelName)]??{}:{}}shouldApplyGlobalOmit(){switch(this.params.action){<span class="branch-0 cbranch-no" title="branch not covered" >case"findFirst":<span class="branch-1 cbranch-no" title="branch not covered" >c</span>ase"findFirstOrThrow":<span class="branch-2 cbranch-no" title="branch not covered" >c</span>ase"findUniqueOrThrow":<span class="branch-3 cbranch-no" title="branch not covered" >c</span>ase"findMany":<span class="branch-4 cbranch-no" title="branch not covered" >c</span>ase"upsert":c</span>ase"findUnique":case"createManyAndReturn":case"create":case"update":case"updateManyAndReturn":case"delete":return!0;<span class="branch-11 cbranch-no" title="branch not covered" >case"executeRaw":<span class="branch-12 cbranch-no" title="branch not covered" >c</span>ase"aggregateRaw":<span class="branch-13 cbranch-no" title="branch not covered" >c</span>ase"runCommandRaw":<span class="branch-14 cbranch-no" title="branch not covered" >c</span>ase"findRaw":<span class="branch-15 cbranch-no" title="branch not covered" >c</span>ase"createMany":c</span>ase"deleteMany":case"groupBy":case"updateMany":case"count":case"aggregate":case"queryRaw":return!1;<span class="branch-22 cbranch-no" title="branch not covered" >default:<span class="cstat-no" title="statement not covered" >Fe(this.params.action,"Unknown action")}</span></span>}nestArgument(t){return new e({...this.params,argumentPath:this.params.argumentPath.concat(t)})}};var Ot=class{constructor(t){this._engine=t}<span class="fstat-no" title="function not covered" >pr</span>ometheus(t){<span class="cstat-no" title="statement not covered" >return this._engine.metrics({format:"prometheus",...t})}<span class="fstat-no" title="function not covered" ></span>js</span>on(t){<span class="cstat-no" title="statement not covered" >return this._engine.metrics({format:"json",...t})}</span>};function <span class="fstat-no" title="function not covered" >fa(</span>e){<span class="cstat-no" title="statement not covered" >return{models:qi(e.models),enums:qi(e.enums),types:qi(e.types)}}</span>function <span class="fstat-no" title="function not covered" >qi(</span>e){let t=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let{name:r,...n}of e)<span class="cstat-no" title="statement not covered" >t[r]=n;<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>function ga(e,t){let r=pr(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >hd(t))</span>;Object.defineProperty(e,"dmmf",{get:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >r.get()}</span>)}function <span class="fstat-no" title="function not covered" >hd(</span>e){<span class="cstat-no" title="statement not covered" >return{datamodel:{models:Vi(e.models),enums:Vi(e.enums),types:Vi(e.types)}}}</span>function <span class="fstat-no" title="function not covered" >Vi(</span>e){<span class="cstat-no" title="statement not covered" >return Object.entries(e).map(<span class="fstat-no" title="function not covered" >([</span>t,r])=&gt;(<span class="cstat-no" title="statement not covered" >{name:t,...r})</span>)}</span>var ji=new WeakMap,Tn="$$PrismaTypedSql",Bi=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,r){<span class="cstat-no" title="statement not covered" >ji.set(this,{sql:t,values:r}),Object.defineProperty(this,Tn,{value:Tn})}<span class="fstat-no" title="function not covered" ></span>ge</span>t sql(){<span class="cstat-no" title="statement not covered" >return ji.get(this).sql}<span class="fstat-no" title="function not covered" ></span>ge</span>t values(){<span class="cstat-no" title="statement not covered" >return ji.get(this).values}</span>};function <span class="fstat-no" title="function not covered" >ha(</span>e){<span class="cstat-no" title="statement not covered" >return<span class="fstat-no" title="function not covered" >(.</span>..t)=&gt;<span class="cstat-no" title="statement not covered" >new Bi(e,t)}</span></span>function <span class="fstat-no" title="function not covered" >ya(</span>e){<span class="cstat-no" title="statement not covered" >return e!=null&amp;&amp;e[Tn]===Tn}</span>function <span class="fstat-no" title="function not covered" >fr(</span>e){<span class="cstat-no" title="statement not covered" >return{ok:!1,error:e,<span class="fstat-no" title="function not covered" >ma</span>p(){<span class="cstat-no" title="statement not covered" >return fr(e)}</span>,<span class="fstat-no" title="function not covered" >fl</span>atMap(){<span class="cstat-no" title="statement not covered" >return fr(e)}</span>}}</span>var Ui=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.registeredErrors=[]}<span class="fstat-no" title="function not covered" ></span>co</span>nsumeError(t){<span class="cstat-no" title="statement not covered" >return this.registeredErrors[t]}<span class="fstat-no" title="function not covered" ></span>re</span>gisterNewError(t){let r=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;this.registeredErrors[r]!==void 0;)<span class="cstat-no" title="statement not covered" >r++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.registeredErrors[r]={error:t},r}</span>},Qi=<span class="fstat-no" title="function not covered" >e=</span>&gt;{let t=<span class="cstat-no" title="statement not covered" >new Ui,</span>r=<span class="cstat-no" title="statement not covered" >Se(t,e.transactionContext.bind(e)),</span>n=<span class="cstat-no" title="statement not covered" >{adapterName:e.adapterName,errorRegistry:t,queryRaw:Se(t,e.queryRaw.bind(e)),executeRaw:Se(t,e.executeRaw.bind(e)),provider:e.provider,transactionContext:<span class="fstat-no" title="function not covered" >as</span>ync(...i)=&gt;<span class="cstat-no" title="statement not covered" >(await r(...i)).map(<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >yd(t,s))</span>}</span>;<span class="cstat-no" title="statement not covered" ></span>return e.getConnectionInfo&amp;&amp;(n.getConnectionInfo=bd(t,e.getConnectionInfo.bind(e))),n}</span>,yd=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{let r=<span class="cstat-no" title="statement not covered" >Se(e,t.startTransaction.bind(t));<span class="cstat-no" title="statement not covered" ></span>return{adapterName:t.adapterName,provider:t.provider,queryRaw:Se(e,t.queryRaw.bind(t)),executeRaw:Se(e,t.executeRaw.bind(t)),startTransaction:<span class="fstat-no" title="function not covered" >as</span>ync(...n)=&gt;<span class="cstat-no" title="statement not covered" >(await r(...n)).map(<span class="fstat-no" title="function not covered" >o=</span>&gt;<span class="cstat-no" title="statement not covered" >Ed(e,o))</span>}</span>}</span>,Ed=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;(<span class="cstat-no" title="statement not covered" >{adapterName:t.adapterName,provider:t.provider,options:t.options,queryRaw:Se(e,t.queryRaw.bind(t)),executeRaw:Se(e,t.executeRaw.bind(t)),commit:Se(e,t.commit.bind(t)),rollback:Se(e,t.rollback.bind(t))})</span>;function <span class="fstat-no" title="function not covered" >Se(</span>e,t){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >as</span>ync(...r)=&gt;{<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return await t(...r)}</span>catch(n){let i=<span class="cstat-no" title="statement not covered" >e.registerNewError(n);<span class="cstat-no" title="statement not covered" ></span>return fr({kind:"GenericJs",id:i})}</span>}</span>}</span>function <span class="fstat-no" title="function not covered" >bd(</span>e,t){<span class="cstat-no" title="statement not covered" >return<span class="fstat-no" title="function not covered" >(.</span>..r)=&gt;{<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return t(...r)}</span>catch(n){let i=<span class="cstat-no" title="statement not covered" >e.registerNewError(n);<span class="cstat-no" title="statement not covered" ></span>return fr({kind:"GenericJs",id:i})}</span>}</span>}</span>var Kl=D(li());var Yl=require("async_hooks"),zl=require("events"),Zl=D(require("fs")),Nr=D(require("path"));var ae=class e{constructor(t,r){<span class="missing-if-branch" title="if path not taken" >I</span>if(t.length-1!==r.length)<span class="cstat-no" title="statement not covered" >throw t.length===0?new TypeError("Expected at least 1 string"):new TypeError(`Expected ${t.length} strings to have ${t.length-1} values`);l</span>et n=r.reduce(<span class="fstat-no" title="function not covered" >(s</span>,a)=&gt;<span class="cstat-no" title="statement not covered" >s+(a instanceof e?a.values.length:1),</span>0);this.values=new Array(n),this.strings=new Array(n+1),this.strings[0]=t[0];let i=0,o=0;for(;i&lt;r.length;){let s=<span class="cstat-no" title="statement not covered" >r[i++],</span>a=<span class="cstat-no" title="statement not covered" >t[i];<span class="cstat-no" title="statement not covered" ></span>if(s instanceof e){<span class="cstat-no" title="statement not covered" >this.strings[o]+=s.strings[0];l</span>et l=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;l&lt;s.values.length;)<span class="cstat-no" title="statement not covered" >this.values[o++]=s.values[l++],this.strings[o]=s.strings[l];<span class="cstat-no" title="statement not covered" >t</span></span>his.strings[o]+=a}</span>else <span class="cstat-no" title="statement not covered" >this.values[o++]=s,this.strings[o]=a}</span></span>}<span class="fstat-no" title="function not covered" >ge</span>t sql(){let t=<span class="cstat-no" title="statement not covered" >this.strings.length,</span>r=<span class="cstat-no" title="statement not covered" >1,</span>n=<span class="cstat-no" title="statement not covered" >this.strings[0];<span class="cstat-no" title="statement not covered" ></span>for(;r&lt;t;)<span class="cstat-no" title="statement not covered" >n+=`?${this.strings[r++]}`;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}<span class="fstat-no" title="function not covered" ></span>ge</span>t statement(){let t=<span class="cstat-no" title="statement not covered" >this.strings.length,</span>r=<span class="cstat-no" title="statement not covered" >1,</span>n=<span class="cstat-no" title="statement not covered" >this.strings[0];<span class="cstat-no" title="statement not covered" ></span>for(;r&lt;t;)<span class="cstat-no" title="statement not covered" >n+=`:${r}${this.strings[r++]}`;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}<span class="fstat-no" title="function not covered" ></span>ge</span>t text(){let t=<span class="cstat-no" title="statement not covered" >this.strings.length,</span>r=<span class="cstat-no" title="statement not covered" >1,</span>n=<span class="cstat-no" title="statement not covered" >this.strings[0];<span class="cstat-no" title="statement not covered" ></span>for(;r&lt;t;)<span class="cstat-no" title="statement not covered" >n+=`$${r}${this.strings[r++]}`;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}<span class="fstat-no" title="function not covered" ></span>in</span>spect(){<span class="cstat-no" title="statement not covered" >return{sql:this.sql,statement:this.statement,text:this.text,values:this.values}}</span>};function <span class="fstat-no" title="function not covered" >Ea(</span>e,t=<span class="branch-0 cbranch-no" title="branch not covered" >",",</span>r=<span class="branch-0 cbranch-no" title="branch not covered" >"",</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >"")</span>{<span class="cstat-no" title="statement not covered" >if(e.length===0)<span class="cstat-no" title="statement not covered" >throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");<span class="cstat-no" title="statement not covered" >r</span></span>eturn new ae([r,...Array(e.length-1).fill(t),n],e)}</span>function Gi(e){return new ae([e],[])}var ba=Gi("");function <span class="fstat-no" title="function not covered" >Ji(</span>e,...t){<span class="cstat-no" title="statement not covered" >return new ae(e,t)}</span>function gr(e){return{getKeys(){return Object.keys(e)},<span class="fstat-no" title="function not covered" >ge</span>tPropertyValue(t){<span class="cstat-no" title="statement not covered" >return e[t]}</span>}}function ie(e,t){return{getKeys(){return[e]},<span class="fstat-no" title="function not covered" >ge</span>tPropertyValue(){<span class="cstat-no" title="statement not covered" >return t()}</span>}}function ot(e){let t=new Te;return{getKeys(){return e.getKeys()},getPropertyValue(r){return t.getOrCreate(r,()=&gt;e.getPropertyValue(r))},<span class="fstat-no" title="function not covered" >ge</span>tPropertyDescriptor(r){<span class="cstat-no" title="statement not covered" >return e.getPropertyDescriptor?.(r)}</span>}}var Rn={enumerable:!0,configurable:!0,writable:!0};function Cn(e){let t=new Set(e);return{getPrototypeOf:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Object.prototype,</span>getOwnPropertyDescriptor:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Rn,</span>has:<span class="fstat-no" title="function not covered" >(r</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >t.has(n),</span>set:<span class="fstat-no" title="function not covered" >(r</span>,n,i)=&gt;<span class="cstat-no" title="statement not covered" >t.add(n)&amp;&amp;Reflect.set(r,n,i),</span>ownKeys:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >[...t]}</span>}var wa=Symbol.for("nodejs.util.inspect.custom");function Ae(e,t){let r=wd(t),n=new Set,i=new Proxy(e,{get(o,s){<span class="missing-if-branch" title="if path not taken" >I</span>if(n.has(s))<span class="cstat-no" title="statement not covered" >return o[s];l</span>et a=r.get(s);return a?a.getPropertyValue(s):o[s]},<span class="fstat-no" title="function not covered" >ha</span>s(o,s){<span class="cstat-no" title="statement not covered" >if(n.has(s))<span class="cstat-no" title="statement not covered" >return!0;l</span></span>et a=<span class="cstat-no" title="statement not covered" >r.get(s);<span class="cstat-no" title="statement not covered" ></span>return a?a.has?.(s)??!0:Reflect.has(o,s)}</span>,<span class="fstat-no" title="function not covered" >ow</span>nKeys(o){let s=<span class="cstat-no" title="statement not covered" >xa(Reflect.ownKeys(o),r),</span>a=<span class="cstat-no" title="statement not covered" >xa(Array.from(r.keys()),r);<span class="cstat-no" title="statement not covered" ></span>return[...new Set([...s,...a,...n])]}</span>,set(o,s,a){return r.get(s)?.getPropertyDescriptor?.(s)?.writable===!1?<span class="branch-0 cbranch-no" title="branch not covered" >!1:</span>(n.add(s),Reflect.set(o,s,a))},<span class="fstat-no" title="function not covered" >ge</span>tOwnPropertyDescriptor(o,s){let a=<span class="cstat-no" title="statement not covered" >Reflect.getOwnPropertyDescriptor(o,s);<span class="cstat-no" title="statement not covered" ></span>if(a&amp;&amp;!a.configurable)<span class="cstat-no" title="statement not covered" >return a;l</span></span>et l=<span class="cstat-no" title="statement not covered" >r.get(s);<span class="cstat-no" title="statement not covered" ></span>return l?l.getPropertyDescriptor?{...Rn,...l?.getPropertyDescriptor(s)}:Rn:a}</span>,<span class="fstat-no" title="function not covered" >de</span>fineProperty(o,s,a){<span class="cstat-no" title="statement not covered" >return n.add(s),Reflect.defineProperty(o,s,a)}</span>,getPrototypeOf:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Object.prototype}</span>);return i[wa]=<span class="fstat-no" title="function not covered" >fu</span>nction(){let o=<span class="cstat-no" title="statement not covered" >{...this};<span class="cstat-no" title="statement not covered" ></span>return delete o[wa],o}</span>,i}function wd(e){let t=new Map;for(let r of e){let n=r.getKeys();for(let i of n)t.set(i,r)}return t}function <span class="fstat-no" title="function not covered" >xa(</span>e,t){<span class="cstat-no" title="statement not covered" >return e.filter(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >t.get(r)?.has?.(r)??!0)</span>}</span>function <span class="fstat-no" title="function not covered" >kt(</span>e){<span class="cstat-no" title="statement not covered" >return{<span class="fstat-no" title="function not covered" >ge</span>tKeys(){<span class="cstat-no" title="statement not covered" >return e}</span>,<span class="fstat-no" title="function not covered" >ha</span>s(){<span class="cstat-no" title="statement not covered" >return!1}</span>,<span class="fstat-no" title="function not covered" >ge</span>tPropertyValue(){}}}</span>function <span class="fstat-no" title="function not covered" >Dt(</span>e,t){<span class="cstat-no" title="statement not covered" >return{batch:e,transaction:t?.kind==="batch"?{isolationLevel:t.options.isolationLevel}:void 0}}</span>function <span class="fstat-no" title="function not covered" >va(</span>e){<span class="cstat-no" title="statement not covered" >if(e===void 0)<span class="cstat-no" title="statement not covered" >return"";l</span></span>et t=<span class="cstat-no" title="statement not covered" >At(e);<span class="cstat-no" title="statement not covered" ></span>return new Pt(0,{colors:fn}).write(t).toString()}</span>var xd="P2037";function <span class="fstat-no" title="function not covered" >_t(</span>{error:e,user_facing_error:t},r,n){<span class="cstat-no" title="statement not covered" >return t.error_code?new ee(vd(t,n),{code:t.error_code,clientVersion:r,meta:t.meta,batchRequestIdx:t.batch_request_idx}):new B(e,{clientVersion:r,batchRequestIdx:t.batch_request_idx})}</span>function <span class="fstat-no" title="function not covered" >vd(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >e.message;<span class="cstat-no" title="statement not covered" ></span>return(t==="postgresql"||t==="postgres"||t==="mysql")&amp;&amp;e.error_code===xd&amp;&amp;(r+=`</span>
Prisma Accelerate has built-in connection pooling to prevent such errors: https://pris.ly/client/error-accelerate`),r}var hr="&lt;unknown&gt;";function <span class="fstat-no" title="function not covered" >Pa(</span>e){var t=<span class="cstat-no" title="statement not covered" >e.split(`</span>
`);<span class="cstat-no" title="statement not covered" >return t.reduce(<span class="fstat-no" title="function not covered" >fu</span>nction(r,n){var i=<span class="cstat-no" title="statement not covered" >Rd(n)||Sd(n)||Od(n)||Nd(n)||Dd(n);<span class="cstat-no" title="statement not covered" ></span>return i&amp;&amp;r.push(i),r}</span>,[])}</span>var Pd=/^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|&lt;anonymous&gt;|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,Td=/\((\S*)(?::(\d+))(?::(\d+))\)/;function <span class="fstat-no" title="function not covered" >Rd(</span>e){var t=<span class="cstat-no" title="statement not covered" >Pd.exec(e);<span class="cstat-no" title="statement not covered" ></span>if(!t)<span class="cstat-no" title="statement not covered" >return null;v</span></span>ar r=<span class="cstat-no" title="statement not covered" >t[2]&amp;&amp;t[2].indexOf("native")===0,</span>n=<span class="cstat-no" title="statement not covered" >t[2]&amp;&amp;t[2].indexOf("eval")===0,</span>i=<span class="cstat-no" title="statement not covered" >Td.exec(t[2]);<span class="cstat-no" title="statement not covered" ></span>return n&amp;&amp;i!=null&amp;&amp;(t[2]=i[1],t[3]=i[2],t[4]=i[3]),{file:r?null:t[2],methodName:t[1]||hr,arguments:r?[t[2]]:[],lineNumber:t[3]?+t[3]:null,column:t[4]?+t[4]:null}}</span>var Cd=/^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;function <span class="fstat-no" title="function not covered" >Sd(</span>e){var t=<span class="cstat-no" title="statement not covered" >Cd.exec(e);<span class="cstat-no" title="statement not covered" ></span>return t?{file:t[2],methodName:t[1]||hr,arguments:[],lineNumber:+t[3],column:t[4]?+t[4]:null}:null}</span>var Ad=/^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i,Id=/(\S+) line (\d+)(?: &gt; eval line \d+)* &gt; eval/i;function <span class="fstat-no" title="function not covered" >Od(</span>e){var t=<span class="cstat-no" title="statement not covered" >Ad.exec(e);<span class="cstat-no" title="statement not covered" ></span>if(!t)<span class="cstat-no" title="statement not covered" >return null;v</span></span>ar r=<span class="cstat-no" title="statement not covered" >t[3]&amp;&amp;t[3].indexOf(" &gt; eval")&gt;-1,</span>n=<span class="cstat-no" title="statement not covered" >Id.exec(t[3]);<span class="cstat-no" title="statement not covered" ></span>return r&amp;&amp;n!=null&amp;&amp;(t[3]=n[1],t[4]=n[2],t[5]=null),{file:t[3],methodName:t[1]||hr,arguments:t[2]?t[2].split(","):[],lineNumber:t[4]?+t[4]:null,column:t[5]?+t[5]:null}}</span>var kd=/^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;function <span class="fstat-no" title="function not covered" >Dd(</span>e){var t=<span class="cstat-no" title="statement not covered" >kd.exec(e);<span class="cstat-no" title="statement not covered" ></span>return t?{file:t[3],methodName:t[1]||hr,arguments:[],lineNumber:+t[4],column:t[5]?+t[5]:null}:null}</span>var _d=/^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;function <span class="fstat-no" title="function not covered" >Nd(</span>e){var t=<span class="cstat-no" title="statement not covered" >_d.exec(e);<span class="cstat-no" title="statement not covered" ></span>return t?{file:t[2],methodName:t[1]||hr,arguments:[],lineNumber:+t[3],column:t[4]?+t[4]:null}:null}</span>var Hi=class{<span class="fstat-no" title="function not covered" >ge</span>tLocation(){<span class="cstat-no" title="statement not covered" >return null}</span>},Wi=class{constructor(){this._error=new Error}<span class="fstat-no" title="function not covered" >ge</span>tLocation(){let t=<span class="cstat-no" title="statement not covered" >this._error.stack;<span class="cstat-no" title="statement not covered" ></span>if(!t)<span class="cstat-no" title="statement not covered" >return null;l</span></span>et n=<span class="cstat-no" title="statement not covered" >Pa(t).find(<span class="fstat-no" title="function not covered" >i=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!i.file)<span class="cstat-no" title="statement not covered" >return!1;l</span></span>et o=<span class="cstat-no" title="statement not covered" >Ei(i.file);<span class="cstat-no" title="statement not covered" ></span>return o!=="&lt;anonymous&gt;"&amp;&amp;!o.includes("@prisma")&amp;&amp;!o.includes("/packages/client/src/runtime/")&amp;&amp;!o.endsWith("/runtime/binary.js")&amp;&amp;!o.endsWith("/runtime/library.js")&amp;&amp;!o.endsWith("/runtime/edge.js")&amp;&amp;!o.endsWith("/runtime/edge-esm.js")&amp;&amp;!o.startsWith("internal/")&amp;&amp;!i.methodName.includes("new ")&amp;&amp;!i.methodName.includes("getCallSite")&amp;&amp;!i.methodName.includes("Proxy.")&amp;&amp;i.methodName.split(".").length&lt;4}</span>);<span class="cstat-no" title="statement not covered" ></span>return!n||!n.file?null:{fileName:n.file,lineNumber:n.lineNumber,columnNumber:n.column}}</span>};function Ze(e){return e==="minimal"?<span class="branch-0 cbranch-no" title="branch not covered" >typeof $EnabledCallSite=="function"&amp;&amp;e!=="minimal"?new $EnabledCallSite:new Hi:</span>new Wi}var Ta={_avg:!0,_count:!0,_sum:!0,_min:!0,_max:!0};function <span class="fstat-no" title="function not covered" >Nt(</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{let t=<span class="cstat-no" title="statement not covered" >Fd(e);<span class="cstat-no" title="statement not covered" ></span>return Object.entries(t).reduce(<span class="fstat-no" title="function not covered" >(n</span>,[i,o])=&gt;(<span class="cstat-no" title="statement not covered" >Ta[i]!==void 0?n.select[i]={select:o}:n[i]=o,n)</span>,{select:{}})}</span>function <span class="fstat-no" title="function not covered" >Fd(</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return typeof e._count=="boolean"?{...e,_count:{_all:e._count}}:e}</span>function <span class="fstat-no" title="function not covered" >Sn(</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >typeof e._count=="boolean"&amp;&amp;(t._count=t._count._all),t)</span>}</span>function <span class="fstat-no" title="function not covered" >Ra(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >Sn(e);<span class="cstat-no" title="statement not covered" ></span>return t({action:"aggregate",unpacker:r,argsMapper:Nt})(e)}</span>function <span class="fstat-no" title="function not covered" >Md(</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{let{select:t,...r}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return typeof t=="object"?Nt({...r,_count:t}):Nt({...r,_count:{_all:!0}})}</span>function <span class="fstat-no" title="function not covered" >$d(</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return typeof e.select=="object"?<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Sn(e)(t)._count:<span class="fstat-no" title="function not covered" ></span>t=</span>&gt;<span class="cstat-no" title="statement not covered" >Sn(e)(t)._count._all}</span></span>function <span class="fstat-no" title="function not covered" >Ca(</span>e,t){<span class="cstat-no" title="statement not covered" >return t({action:"count",unpacker:$d(e),argsMapper:Md})(e)}</span>function <span class="fstat-no" title="function not covered" >qd(</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{let t=<span class="cstat-no" title="statement not covered" >Nt(e);<span class="cstat-no" title="statement not covered" ></span>if(Array.isArray(t.by))<span class="cstat-no" title="statement not covered" >for(let r of t.by)<span class="cstat-no" title="statement not covered" >typeof r=="string"&amp;&amp;(t.select[r]=!0);e</span></span>lse <span class="cstat-no" title="statement not covered" >typeof t.by=="string"&amp;&amp;(t.select[t.by]=!0);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>function <span class="fstat-no" title="function not covered" >Vd(</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >typeof e?._count=="boolean"&amp;&amp;t.forEach(<span class="fstat-no" title="function not covered" >r=</span>&gt;{<span class="cstat-no" title="statement not covered" >r._count=r._count._all}</span>),t)</span>}</span>function <span class="fstat-no" title="function not covered" >Sa(</span>e,t){<span class="cstat-no" title="statement not covered" >return t({action:"groupBy",unpacker:Vd(e),argsMapper:qd})(e)}</span>function <span class="fstat-no" title="function not covered" >Aa(</span>e,t,r){<span class="cstat-no" title="statement not covered" >if(t==="aggregate")<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >Ra(n,r);<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(t==="count")<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >Ca(n,r);<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(t==="groupBy")<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >Sa(n,r)}</span></span></span>function <span class="fstat-no" title="function not covered" >Ia(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >t.fields.filter(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >!i.relationName)</span>,</span>n=<span class="cstat-no" title="statement not covered" >Ri(r,<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >i.name)</span>;<span class="cstat-no" title="statement not covered" ></span>return new Proxy({},{<span class="fstat-no" title="function not covered" >ge</span>t(i,o){<span class="cstat-no" title="statement not covered" >if(o in i||typeof o=="symbol")<span class="cstat-no" title="statement not covered" >return i[o];l</span></span>et s=<span class="cstat-no" title="statement not covered" >n[o];<span class="cstat-no" title="statement not covered" ></span>if(s)<span class="cstat-no" title="statement not covered" >return new sr(e,o,s.type,s.isList,s.kind==="enum")}</span></span>,...Cn(Object.keys(n))})}</span>var Oa=e=&gt;Array.isArray(e)?e:<span class="branch-1 cbranch-no" title="branch not covered" >e.split("."),</span>Ki=(e,t)=&gt;Oa(t).reduce(<span class="fstat-no" title="function not covered" >(r</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >r&amp;&amp;r[n],</span>e),ka=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;<span class="cstat-no" title="statement not covered" >Oa(t).reduceRight(<span class="fstat-no" title="function not covered" >(n</span>,i,o,s)=&gt;<span class="cstat-no" title="statement not covered" >Object.assign({},Ki(e,s.slice(0,o)),{[i]:n}),</span>r);</span>function jd(e,t){return e===void 0||<span class="branch-1 cbranch-no" title="branch not covered" >t===void 0?</span>[]:<span class="branch-1 cbranch-no" title="branch not covered" >[...t,"select",e]}</span>function Bd(e,t,r){return t===void 0?e??<span class="branch-1 cbranch-no" title="branch not covered" >{}:<span class="branch-1 cbranch-no" title="branch not covered" ></span>ka(t,r,e||!0)}</span>function Yi(e,t,r,n,i,o){let a=e._runtimeDataModel.models[t].fields.reduce((l,u)=&gt;({...l,[u.name]:u}),{});return l=&gt;{let u=Ze(e._errorFormat),c=jd(n,i),p=Bd(l,o,c),d=r({dataPath:c,callsite:u})(p),f=Ud(e,t);return new Proxy(d,{get(g,h){<span class="missing-if-branch" title="else path not taken" >E</span>if(!f.includes(h))return g[h];let P=<span class="cstat-no" title="statement not covered" >[a[h].type,r,h],</span>C=<span class="cstat-no" title="statement not covered" >[c,p];<span class="cstat-no" title="statement not covered" ></span>return Yi(e,...P,...C)}</span>,...Cn([...f,...Object.getOwnPropertyNames(d)])})}}function Ud(e,t){return e._runtimeDataModel.models[t].fields.filter(r=&gt;r.kind==="object").map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >r.name)</span>}var Qd=["findUnique","findUniqueOrThrow","findFirst","findFirstOrThrow","create","update","upsert","delete"],Gd=["aggregate","count","groupBy"];function zi(e,t){let r=e._extensions.getAllModelExtensions(t)??{},n=[Jd(e,t),Wd(e,t),gr(r),ie("name",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t)</span>,ie("$name",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t)</span>,ie("$parent",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e._appliedParent)</span>];return Ae({},n)}function Jd(e,t){let r=Re(t),n=Object.keys(zt.ModelAction).concat("count");return{getKeys(){return n},getPropertyValue(i){let o=i,s=a=&gt;l=&gt;{let u=Ze(e._errorFormat);return e._createPrismaPromise(c=&gt;{let p={args:l,dataPath:[],action:o,model:t,clientMethod:`${r}.${i}`,jsModelName:r,transaction:c,callsite:u};return e._request({...p,...a})})};return Qd.includes(o)?Yi(e,t,s):Hd(i)?<span class="branch-0 cbranch-no" title="branch not covered" >Aa(e,i,s):</span>s({})}}}function Hd(e){return Gd.includes(e)}function Wd(e,t){return ot(ie("fields",<span class="fstat-no" title="function not covered" >()</span>=&gt;{let r=<span class="cstat-no" title="statement not covered" >e._runtimeDataModel.models[t];<span class="cstat-no" title="statement not covered" ></span>return Ia(t,r)}</span>))}function Da(e){return e.replace(/^./,t=&gt;t.toUpperCase())}var Zi=Symbol();function yr(e){let t=[Kd(e),ie(Zi,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e)</span>,ie("$parent",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e._appliedParent)</span>],r=e._extensions.getAllClientExtensions();return r&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >t.push(gr(r)),</span>Ae(e,t)}function Kd(e){let t=Object.keys(e._runtimeDataModel.models),r=t.map(Re),n=[...new Set(t.concat(r))];return ot({getKeys(){return n},getPropertyValue(i){let o=Da(i);<span class="missing-if-branch" title="if path not taken" >I</span>if(e._runtimeDataModel.models[o]!==void 0)<span class="cstat-no" title="statement not covered" >return zi(e,o);<span class="missing-if-branch" title="else path not taken" >E</span>i</span>f(e._runtimeDataModel.models[i]!==void 0)return zi(e,i)},<span class="fstat-no" title="function not covered" >ge</span>tPropertyDescriptor(i){<span class="cstat-no" title="statement not covered" >if(!r.includes(i))<span class="cstat-no" title="statement not covered" >return{enumerable:!1}}</span></span>})}function <span class="fstat-no" title="function not covered" >_a(</span>e){<span class="cstat-no" title="statement not covered" >return e[Zi]?e[Zi]:e}</span>function <span class="fstat-no" title="function not covered" >Na(</span>e){<span class="cstat-no" title="statement not covered" >if(typeof e=="function")<span class="cstat-no" title="statement not covered" >return e(this);<span class="cstat-no" title="statement not covered" >i</span></span>f(e.client?.__AccelerateEngine){let r=<span class="cstat-no" title="statement not covered" >e.client.__AccelerateEngine;<span class="cstat-no" title="statement not covered" ></span>this._originalClient._engine=new r(this._originalClient._accelerateEngineConfig)}</span>l</span>et t=<span class="cstat-no" title="statement not covered" >Object.create(this._originalClient,{_extensions:{value:this._extensions.append(e)},_appliedParent:{value:this,configurable:!0},$use:{value:void 0},$on:{value:void 0}});<span class="cstat-no" title="statement not covered" ></span>return yr(t)}</span>function <span class="fstat-no" title="function not covered" >La(</span>{result:e,modelName:t,select:r,omit:n,extensions:i}){let o=<span class="cstat-no" title="statement not covered" >i.getAllComputedFields(t);<span class="cstat-no" title="statement not covered" ></span>if(!o)<span class="cstat-no" title="statement not covered" >return e;l</span></span>et s=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let l of Object.values(o)){<span class="cstat-no" title="statement not covered" >if(n){<span class="cstat-no" title="statement not covered" >if(n[l.name])<span class="cstat-no" title="statement not covered" >continue;l</span></span>et u=<span class="cstat-no" title="statement not covered" >l.needs.filter(<span class="fstat-no" title="function not covered" >c=</span>&gt;<span class="cstat-no" title="statement not covered" >n[c])</span>;<span class="cstat-no" title="statement not covered" ></span>u.length&gt;0&amp;&amp;a.push(kt(u))}</span>else <span class="cstat-no" title="statement not covered" >if(r){<span class="cstat-no" title="statement not covered" >if(!r[l.name])<span class="cstat-no" title="statement not covered" >continue;l</span></span>et u=<span class="cstat-no" title="statement not covered" >l.needs.filter(<span class="fstat-no" title="function not covered" >c=</span>&gt;<span class="cstat-no" title="statement not covered" >!r[c])</span>;<span class="cstat-no" title="statement not covered" ></span>u.length&gt;0&amp;&amp;a.push(kt(u))}<span class="cstat-no" title="statement not covered" ></span>Y</span></span>d(e,l.needs)&amp;&amp;s.push(zd(l,Ae(e,s)))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s.length&gt;0||a.length&gt;0?Ae(e,[...s,...a]):e}</span>function <span class="fstat-no" title="function not covered" >Yd(</span>e,t){<span class="cstat-no" title="statement not covered" >return t.every(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >Ti(e,r))</span>}</span>function <span class="fstat-no" title="function not covered" >zd(</span>e,t){<span class="cstat-no" title="statement not covered" >return ot(ie(e.name,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e.compute(t))</span>)}</span>function <span class="fstat-no" title="function not covered" >An(</span>{visitor:e,result:t,args:r,runtimeDataModel:n,modelName:i}){<span class="cstat-no" title="statement not covered" >if(Array.isArray(t)){<span class="cstat-no" title="statement not covered" >for(let s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;t.length;s++)<span class="cstat-no" title="statement not covered" >t[s]=An({result:t[s],args:r,modelName:i,runtimeDataModel:n,visitor:e});<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>l</span>et o=<span class="cstat-no" title="statement not covered" >e(t,i,r)??t;<span class="cstat-no" title="statement not covered" ></span>return r.include&amp;&amp;Fa({includeOrSelect:r.include,result:o,parentModelName:i,runtimeDataModel:n,visitor:e}),r.select&amp;&amp;Fa({includeOrSelect:r.select,result:o,parentModelName:i,runtimeDataModel:n,visitor:e}),o}</span>function <span class="fstat-no" title="function not covered" >Fa(</span>{includeOrSelect:e,result:t,parentModelName:r,runtimeDataModel:n,visitor:i}){<span class="cstat-no" title="statement not covered" >for(let[o,s]of Object.entries(e)){<span class="cstat-no" title="statement not covered" >if(!s||t[o]==null||Ce(s))<span class="cstat-no" title="statement not covered" >continue;l</span></span>et l=<span class="cstat-no" title="statement not covered" >n.models[r].fields.find(<span class="fstat-no" title="function not covered" >c=</span>&gt;<span class="cstat-no" title="statement not covered" >c.name===o)</span>;<span class="cstat-no" title="statement not covered" ></span>if(!l||l.kind!=="object"||!l.relationName)<span class="cstat-no" title="statement not covered" >continue;l</span></span>et u=<span class="cstat-no" title="statement not covered" >typeof s=="object"?s:{};<span class="cstat-no" title="statement not covered" ></span>t[o]=An({visitor:i,result:t[o],args:u,modelName:l.type,runtimeDataModel:n})}</span>}</span>function Ma({result:e,modelName:t,args:r,extensions:n,runtimeDataModel:i,globalOmit:o}){return n.isEmpty()||<span class="branch-1 cbranch-no" title="branch not covered" >e==null|</span>|<span class="branch-2 cbranch-no" title="branch not covered" >typeof e!="object"|</span>|<span class="branch-3 cbranch-no" title="branch not covered" >!i.models[t]?</span>e:<span class="branch-1 cbranch-no" title="branch not covered" >An({result:e,args:r??{},modelName:t,runtimeDataModel:i,visitor:<span class="fstat-no" title="function not covered" >(a</span>,l,u)=&gt;{let c=<span class="cstat-no" title="statement not covered" >Re(l);<span class="cstat-no" title="statement not covered" ></span>return La({result:a,modelName:c,select:u.select,omit:u.select?void 0:{...o?.[c],...u.omit},extensions:n})}</span>})}</span>function <span class="fstat-no" title="function not covered" >$a(</span>e){<span class="cstat-no" title="statement not covered" >if(e instanceof ae)<span class="cstat-no" title="statement not covered" >return Zd(e);<span class="cstat-no" title="statement not covered" >i</span></span>f(Array.isArray(e)){let r=<span class="cstat-no" title="statement not covered" >[e[0]];<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >1;</span>n&lt;e.length;n++)<span class="cstat-no" title="statement not covered" >r[n]=Er(e[n]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>l</span>et t=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let r in e)<span class="cstat-no" title="statement not covered" >t[r]=Er(e[r]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>function <span class="fstat-no" title="function not covered" >Zd(</span>e){<span class="cstat-no" title="statement not covered" >return new ae(e.strings,e.values)}</span>function <span class="fstat-no" title="function not covered" >Er(</span>e){<span class="cstat-no" title="statement not covered" >if(typeof e!="object"||e==null||e instanceof $e||St(e))<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >i</span></span>f(vt(e))<span class="cstat-no" title="statement not covered" >return new ve(e.toFixed());<span class="cstat-no" title="statement not covered" >i</span></span>f(xt(e))<span class="cstat-no" title="statement not covered" >return new Date(+e);<span class="cstat-no" title="statement not covered" >i</span></span>f(ArrayBuffer.isView(e))<span class="cstat-no" title="statement not covered" >return e.slice(0);<span class="cstat-no" title="statement not covered" >i</span></span>f(Array.isArray(e)){let t=<span class="cstat-no" title="statement not covered" >e.length,</span>r;<span class="cstat-no" title="statement not covered" >for(r=Array(t);t--;)<span class="cstat-no" title="statement not covered" >r[t]=Er(e[t]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}<span class="cstat-no" title="statement not covered" ></span>i</span>f(typeof e=="object"){let t=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let r in e)<span class="cstat-no" title="statement not covered" >r==="__proto__"?Object.defineProperty(t,r,{value:Er(e[r]),configurable:!0,enumerable:!0,writable:!0}):t[r]=Er(e[r]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}<span class="cstat-no" title="statement not covered" ></span>F</span>e(e,"Unknown value")}</span>function <span class="fstat-no" title="function not covered" >Va(</span>e,t,r,n=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >return e._createPrismaPromise(<span class="fstat-no" title="function not covered" >i=</span>&gt;{let o=<span class="cstat-no" title="statement not covered" >t.customDataProxyFetch;<span class="cstat-no" title="statement not covered" ></span>return"transaction"in t&amp;&amp;i!==void 0&amp;&amp;(t.transaction?.kind==="batch"&amp;&amp;t.transaction.lock.then(),t.transaction=i),n===r.length?e._executeRequest(t):r[n]({model:t.model,operation:t.model?t.action:t.clientMethod,args:$a(t.args??{}),__internalParams:t,query:<span class="fstat-no" title="function not covered" >(s</span>,a=<span class="branch-0 cbranch-no" title="branch not covered" >t)</span>=&gt;{let l=<span class="cstat-no" title="statement not covered" >a.customDataProxyFetch;<span class="cstat-no" title="statement not covered" ></span>return a.customDataProxyFetch=Qa(o,l),a.args=s,Va(e,a,r,n+1)}</span>})}</span>)}</span>function ja(e,t){let{jsModelName:r,action:n,clientMethod:i}=t,o=r?n:<span class="branch-1 cbranch-no" title="branch not covered" >i;<span class="missing-if-branch" title="else path not taken" >E</span></span>if(e._extensions.isEmpty())return e._executeRequest(t);let s=<span class="cstat-no" title="statement not covered" >e._extensions.getAllQueryCallbacks(r??"$none",o);<span class="cstat-no" title="statement not covered" ></span>return Va(e,t,s)}</span>function Ba(e){return <span class="fstat-no" title="function not covered" >t=</span>&gt;{let r=<span class="cstat-no" title="statement not covered" >{requests:t},</span>n=<span class="cstat-no" title="statement not covered" >t[0].extensions.getAllBatchQueryCallbacks();<span class="cstat-no" title="statement not covered" ></span>return n.length?Ua(r,n,0,e):e(r)}</span>}function <span class="fstat-no" title="function not covered" >Ua(</span>e,t,r,n){<span class="cstat-no" title="statement not covered" >if(r===t.length)<span class="cstat-no" title="statement not covered" >return n(e);l</span></span>et i=<span class="cstat-no" title="statement not covered" >e.customDataProxyFetch,</span>o=<span class="cstat-no" title="statement not covered" >e.requests[0].transaction;<span class="cstat-no" title="statement not covered" ></span>return t[r]({args:{queries:e.requests.map(<span class="fstat-no" title="function not covered" >s=</span>&gt;(<span class="cstat-no" title="statement not covered" >{model:s.modelName,operation:s.action,args:s.args})</span>),transaction:o?{isolationLevel:o.kind==="batch"?o.isolationLevel:void 0}:void 0},__internalParams:e,<span class="fstat-no" title="function not covered" >qu</span>ery(s,a=<span class="branch-0 cbranch-no" title="branch not covered" >e)</span>{let l=<span class="cstat-no" title="statement not covered" >a.customDataProxyFetch;<span class="cstat-no" title="statement not covered" ></span>return a.customDataProxyFetch=Qa(i,l),Ua(a,t,r+1,n)}</span>})}</span>var qa=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e;</span>function <span class="fstat-no" title="function not covered" >Qa(</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >qa,</span>t=<span class="branch-0 cbranch-no" title="branch not covered" >qa)</span>{<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >e(t(r))}</span></span>var Ga=F("prisma:client"),Ja={Vercel:"vercel","Netlify CI":"netlify"};function Ha({postinstall:e,ciName:t,clientVersion:r}){<span class="missing-if-branch" title="if path not taken" >I</span>if(Ga("checkPlatformCaching:postinstall",e),Ga("checkPlatformCaching:ciName",t),e===!0&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >t&amp;</span>&amp;<span class="branch-2 cbranch-no" title="branch not covered" >t in Ja)</span>{let n=<span class="cstat-no" title="statement not covered" >`Prisma has detected that this project was built on ${t}, which caches dependencies. This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered. To fix this, make sure to run the \`prisma generate\` command during the build process.</span>
&nbsp;
Learn how: https://pris.ly/d/${Ja[t]}-build`;<span class="cstat-no" title="statement not covered" >throw console.error(n),new T(n,r)}</span>}function Wa(e,t){return e?e.datasources?e.datasources:e.datasourceUrl?<span class="branch-0 cbranch-no" title="branch not covered" >{[t[0]]:{url:e.datasourceUrl}}:</span>{}:<span class="branch-1 cbranch-no" title="branch not covered" >{}}</span>var Xd="Cloudflare-Workers",em="node";function <span class="fstat-no" title="function not covered" >Ka(</span>){<span class="cstat-no" title="statement not covered" >return typeof Netlify=="object"?"netlify":typeof EdgeRuntime=="string"?"edge-light":globalThis.navigator?.userAgent===Xd?"workerd":globalThis.Deno?"deno":globalThis.__lagon__?"lagon":globalThis.process?.release?.name===em?"node":globalThis.Bun?"bun":globalThis.fastly?"fastly":"unknown"}</span>var tm={node:"Node.js",workerd:"Cloudflare Workers",deno:"Deno and Deno Deploy",netlify:"Netlify Edge Functions","edge-light":"Edge Runtime (Vercel Edge Functions, Vercel Edge Middleware, Next.js (Pages Router) Edge API Routes, Next.js (App Router) Edge Route Handlers or Next.js Middleware)"};function <span class="fstat-no" title="function not covered" >In(</span>){let e=<span class="cstat-no" title="statement not covered" >Ka();<span class="cstat-no" title="statement not covered" ></span>return{id:e,prettyName:tm[e]||e,isEdge:["workerd","deno","netlify","edge-light"].includes(e)}}</span>var el=D(require("fs")),br=D(require("path"));function <span class="fstat-no" title="function not covered" >On(</span>e){let{runtimeBinaryTarget:t}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return`Add "${t}" to \`binaryTargets\` in the "schema.prisma" file and run \`prisma generate\` after saving it:</span>
&nbsp;
${rm(e)}`}function <span class="fstat-no" title="function not covered" >rm(</span>e){let{generator:t,generatorBinaryTargets:r,runtimeBinaryTarget:n}=<span class="cstat-no" title="statement not covered" >e,</span>i=<span class="cstat-no" title="statement not covered" >{fromEnvVar:null,value:n},</span>o=<span class="cstat-no" title="statement not covered" >[...r,i];<span class="cstat-no" title="statement not covered" ></span>return xi({...t,binaryTargets:o})}</span>function <span class="fstat-no" title="function not covered" >Xe(</span>e){let{runtimeBinaryTarget:t}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return`Prisma Client could not locate the Query Engine for runtime "${t}".`}</span>function <span class="fstat-no" title="function not covered" >et(</span>e){let{searchedLocations:t}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return`The following locations have been searched:</span>
${[...new Set(t)].map(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >`  ${i}`)</span>.join(`
`)}`}function <span class="fstat-no" title="function not covered" >Ya(</span>e){let{runtimeBinaryTarget:t}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return`${Xe(e)}</span>
&nbsp;
This happened because \`binaryTargets\` have been pinned, but the actual deployment also required "${t}".
${On(e)}
&nbsp;
${et(e)}`}function <span class="fstat-no" title="function not covered" >kn(</span>e){<span class="cstat-no" title="statement not covered" >return`We would appreciate if you could take the time to share some information with us.</span>
Please help us by answering a few questions: https://pris.ly/${e}`}function <span class="fstat-no" title="function not covered" >Dn(</span>e){let{errorStack:t}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return t?.match(/\/\.next|\/next@|\/next\//)?`</span>
&nbsp;
We detected that you are using Next.js, learn how to fix this: https://pris.ly/d/engine-not-found-nextjs.`:""}function <span class="fstat-no" title="function not covered" >za(</span>e){let{queryEngineName:t}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return`${Xe(e)}${Dn(e)}</span>
&nbsp;
This is likely caused by a bundler that has not copied "${t}" next to the resulting bundle.
Ensure that "${t}" has been copied next to the bundle or in "${e.expectedLocation}".
&nbsp;
${kn("engine-not-found-bundler-investigation")}
&nbsp;
${et(e)}`}function <span class="fstat-no" title="function not covered" >Za(</span>e){let{runtimeBinaryTarget:t,generatorBinaryTargets:r}=<span class="cstat-no" title="statement not covered" >e,</span>n=<span class="cstat-no" title="statement not covered" >r.find(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >i.native)</span>;<span class="cstat-no" title="statement not covered" ></span>return`${Xe(e)}</span>
&nbsp;
This happened because Prisma Client was generated for "${n?.value??"unknown"}", but the actual deployment required "${t}".
${On(e)}
&nbsp;
${et(e)}`}function <span class="fstat-no" title="function not covered" >Xa(</span>e){let{queryEngineName:t}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return`${Xe(e)}${Dn(e)}</span>
&nbsp;
This is likely caused by tooling that has not copied "${t}" to the deployment folder.
Ensure that you ran \`prisma generate\` and that "${t}" has been copied to "${e.expectedLocation}".
&nbsp;
${kn("engine-not-found-tooling-investigation")}
&nbsp;
${et(e)}`}var nm=F("prisma:client:engines:resolveEnginePath"),im=<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >new RegExp("runtime[\\\\/]library\\.m?js$");</span>async function tl(e,t){let r={binary:process.env.PRISMA_QUERY_ENGINE_BINARY,library:process.env.PRISMA_QUERY_ENGINE_LIBRARY}[e]??t.prismaPath;<span class="missing-if-branch" title="if path not taken" >I</span>if(r!==void 0)<span class="cstat-no" title="statement not covered" >return r;l</span>et{enginePath:n,searchedLocations:i}=await om(e,t);<span class="missing-if-branch" title="else path not taken" >E</span>if(nm("enginePath",n),n!==void 0&amp;&amp;e==="binary"&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >pi(n),</span>n!==void 0)return t.prismaPath=n;let o=<span class="cstat-no" title="statement not covered" >await nt(),</span>s=<span class="cstat-no" title="statement not covered" >t.generator?.binaryTargets??[],</span>a=<span class="cstat-no" title="statement not covered" >s.some(<span class="fstat-no" title="function not covered" >d=</span>&gt;<span class="cstat-no" title="statement not covered" >d.native)</span>,</span>l=<span class="cstat-no" title="statement not covered" >!s.some(<span class="fstat-no" title="function not covered" >d=</span>&gt;<span class="cstat-no" title="statement not covered" >d.value===o)</span>,</span>u=<span class="cstat-no" title="statement not covered" >__filename.match(im())===null,</span>c=<span class="cstat-no" title="statement not covered" >{searchedLocations:i,generatorBinaryTargets:s,generator:t.generator,runtimeBinaryTarget:o,queryEngineName:rl(e,o),expectedLocation:br.default.relative(process.cwd(),t.dirname),errorStack:new Error().stack},</span>p;<span class="cstat-no" title="statement not covered" >throw a&amp;&amp;l?p=Za(c):l?p=Ya(c):u?p=za(c):p=Xa(c),new T(p,t.clientVersion)}</span>async function om(engineType,config){let binaryTarget=await nt(),searchedLocations=[],dirname=eval("__dirname"),searchLocations=[config.dirname,br.default.resolve(dirname,".."),config.generator?.output?.value??<span class="branch-1 cbranch-no" title="branch not covered" >dirname,</span>br.default.resolve(dirname,"../../../.prisma/client"),"/tmp/prisma-engines",config.cwd];__filename.includes("resolveEnginePath")&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >searchLocations.push(ts());</span>for(let e of searchLocations){let t=rl(engineType,binaryTarget),r=br.default.join(e,t);<span class="missing-if-branch" title="else path not taken" >E</span>if(searchedLocations.push(e),el.default.existsSync(r))return{enginePath:r,searchedLocations}}<span class="cstat-no" title="statement not covered" >return{enginePath:void 0,searchedLocations}}</span>function rl(e,t){return e==="library"?qr(t,"fs"):<span class="branch-1 cbranch-no" title="branch not covered" >`query-engine-${t}${t==="windows"?".exe":""}`}</span>var Xi=D(Pi());function <span class="fstat-no" title="function not covered" >nl(</span>e){<span class="cstat-no" title="statement not covered" >return e?e.replace(/".*"/g,'"X"').replace(/[\s:\[]([+-]?([0-9]*[.])?[0-9]+)/g,<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >`${t[0]}5`)</span>:""}</span>function <span class="fstat-no" title="function not covered" >il(</span>e){<span class="cstat-no" title="statement not covered" >return e.split(`</span>
`).map(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.replace(/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)\s*/,"").replace(/\+\d+\s*ms$/,""))</span>.join(`
`)}var ol=D(vs());function <span class="fstat-no" title="function not covered" >sl(</span>{title:e,user:t=<span class="branch-0 cbranch-no" title="branch not covered" >"prisma",</span>repo:r=<span class="branch-0 cbranch-no" title="branch not covered" >"prisma",</span>template:n=<span class="branch-0 cbranch-no" title="branch not covered" >"bug_report.yml",</span>body:i}){<span class="cstat-no" title="statement not covered" >return(0,ol.default)({user:t,repo:r,template:n,title:e,body:i})}</span>function <span class="fstat-no" title="function not covered" >al(</span>{version:e,binaryTarget:t,title:r,description:n,engineVersion:i,database:o,query:s}){let a=<span class="cstat-no" title="statement not covered" >ko(6e3-(s?.length??0)),</span>l=<span class="cstat-no" title="statement not covered" >il((0,Xi.default)(a)),</span>u=<span class="cstat-no" title="statement not covered" >n?`# Description</span>
\`\`\`
${n}
\`\`\``:"",c=<span class="cstat-no" title="statement not covered" >(0,Xi.default)(`Hi Prisma Team! My Prisma Client just crashed. This is the report:</span>
## Versions
&nbsp;
| Name            | Version            |
|-----------------|--------------------|
| Node            | ${process.version?.padEnd(19)}| 
| OS              | ${t?.padEnd(19)}|
| Prisma Client   | ${e?.padEnd(19)}|
| Query Engine    | ${i?.padEnd(19)}|
| Database        | ${o?.padEnd(19)}|
&nbsp;
${u}
&nbsp;
## Logs
\`\`\`
${l}
\`\`\`
&nbsp;
## Client Snippet
\`\`\`ts
// PLEASE FILL YOUR CODE SNIPPET HERE
\`\`\`
&nbsp;
## Schema
\`\`\`prisma
// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE
\`\`\`
&nbsp;
## Prisma Engine Query
\`\`\`
${s?nl(s):""}
\`\`\`
`),p=<span class="cstat-no" title="statement not covered" >sl({title:r,body:c});<span class="cstat-no" title="statement not covered" ></span>return`${r}</span>
&nbsp;
This is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.
&nbsp;
${X(p)}
&nbsp;
If you want the Prisma team to look into it, please open the link above \u{1F64F}
To increase the chance of success, please post your schema and a snippet of
how you used Prisma Client in the issue. 
`}function Lt({inlineDatasources:e,overrideDatasources:t,env:r,clientVersion:n}){let i,o=Object.keys(e)[0],s=e[o]?.url,a=t[o]?.url;<span class="missing-if-branch" title="if path not taken" >I</span>if(o===void 0?<span class="branch-0 cbranch-no" title="branch not covered" >i=void 0:</span>a?i=a:s?.value?<span class="branch-0 cbranch-no" title="branch not covered" >i=s.value:</span>s?.fromEnvVar&amp;&amp;(i=r[s.fromEnvVar]),s?.fromEnvVar!==void 0&amp;&amp;i===void 0)<span class="cstat-no" title="statement not covered" >throw new T(`error: Environment variable not found: ${s.fromEnvVar}.`,n);<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(i===void 0)<span class="cstat-no" title="statement not covered" >throw new T("error: Missing URL environment variable, value, or override.",n);r</span>eturn i}var _n=class extends Error{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,r){<span class="cstat-no" title="statement not covered" >super(t),this.clientVersion=r.clientVersion,this.cause=r.cause}<span class="fstat-no" title="function not covered" ></span>ge</span>t[Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return this.name}</span>};var le=class extends _n{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,r){<span class="cstat-no" title="statement not covered" >super(t,r),this.isRetryable=r.isRetryable??!0}</span>};function <span class="fstat-no" title="function not covered" >S(</span>e,t){<span class="cstat-no" title="statement not covered" >return{...e,isRetryable:t}}</span>var Ft=class extends le{<span class="fstat-no" title="function not covered" >co</span>nstructor(r){<span class="cstat-no" title="statement not covered" >super("This request must be retried",S(r,!0));<span class="cstat-no" title="statement not covered" >t</span>his.name="ForcedRetryError";<span class="cstat-no" title="statement not covered" >t</span>his.code="P5001"}</span>};w(Ft,"ForcedRetryError");var st=class extends le{<span class="fstat-no" title="function not covered" >co</span>nstructor(r,n){<span class="cstat-no" title="statement not covered" >super(r,S(n,!1));<span class="cstat-no" title="statement not covered" >t</span>his.name="InvalidDatasourceError";<span class="cstat-no" title="statement not covered" >t</span>his.code="P6001"}</span>};w(st,"InvalidDatasourceError");var at=class extends le{<span class="fstat-no" title="function not covered" >co</span>nstructor(r,n){<span class="cstat-no" title="statement not covered" >super(r,S(n,!1));<span class="cstat-no" title="statement not covered" >t</span>his.name="NotImplementedYetError";<span class="cstat-no" title="statement not covered" >t</span>his.code="P5004"}</span>};w(at,"NotImplementedYetError");var V=class extends le{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,r){<span class="cstat-no" title="statement not covered" >super(t,r),this.response=r.response;l</span>et n=<span class="cstat-no" title="statement not covered" >this.response.headers.get("prisma-request-id");<span class="cstat-no" title="statement not covered" ></span>if(n){let i=<span class="cstat-no" title="statement not covered" >`(The request id was: ${n})`;<span class="cstat-no" title="statement not covered" ></span>this.message=this.message+" "+i}</span>}</span>};var lt=class extends V{<span class="fstat-no" title="function not covered" >co</span>nstructor(r){<span class="cstat-no" title="statement not covered" >super("Schema needs to be uploaded",S(r,!0));<span class="cstat-no" title="statement not covered" >t</span>his.name="SchemaMissingError";<span class="cstat-no" title="statement not covered" >t</span>his.code="P5005"}</span>};w(lt,"SchemaMissingError");var eo="This request could not be understood by the server",wr=class extends V{<span class="fstat-no" title="function not covered" >co</span>nstructor(r,n,i){<span class="cstat-no" title="statement not covered" >super(n||eo,S(r,!1));<span class="cstat-no" title="statement not covered" >t</span>his.name="BadRequestError";<span class="cstat-no" title="statement not covered" >t</span>his.code="P5000";<span class="cstat-no" title="statement not covered" >i</span>&amp;&amp;(this.code=i)}</span>};w(wr,"BadRequestError");var xr=class extends V{<span class="fstat-no" title="function not covered" >co</span>nstructor(r,n){<span class="cstat-no" title="statement not covered" >super("Engine not started: healthcheck timeout",S(r,!0));<span class="cstat-no" title="statement not covered" >t</span>his.name="HealthcheckTimeoutError";<span class="cstat-no" title="statement not covered" >t</span>his.code="P5013";<span class="cstat-no" title="statement not covered" >t</span>his.logs=n}</span>};w(xr,"HealthcheckTimeoutError");var vr=class extends V{<span class="fstat-no" title="function not covered" >co</span>nstructor(r,n,i){<span class="cstat-no" title="statement not covered" >super(n,S(r,!0));<span class="cstat-no" title="statement not covered" >t</span>his.name="EngineStartupError";<span class="cstat-no" title="statement not covered" >t</span>his.code="P5014";<span class="cstat-no" title="statement not covered" >t</span>his.logs=i}</span>};w(vr,"EngineStartupError");var Pr=class extends V{<span class="fstat-no" title="function not covered" >co</span>nstructor(r){<span class="cstat-no" title="statement not covered" >super("Engine version is not supported",S(r,!1));<span class="cstat-no" title="statement not covered" >t</span>his.name="EngineVersionNotSupportedError";<span class="cstat-no" title="statement not covered" >t</span>his.code="P5012"}</span>};w(Pr,"EngineVersionNotSupportedError");var to="Request timed out",Tr=class extends V{<span class="fstat-no" title="function not covered" >co</span>nstructor(r,n=<span class="branch-0 cbranch-no" title="branch not covered" >to)</span>{<span class="cstat-no" title="statement not covered" >super(n,S(r,!1));<span class="cstat-no" title="statement not covered" >t</span>his.name="GatewayTimeoutError";<span class="cstat-no" title="statement not covered" >t</span>his.code="P5009"}</span>};w(Tr,"GatewayTimeoutError");var sm="Interactive transaction error",Rr=class extends V{<span class="fstat-no" title="function not covered" >co</span>nstructor(r,n=<span class="branch-0 cbranch-no" title="branch not covered" >sm)</span>{<span class="cstat-no" title="statement not covered" >super(n,S(r,!1));<span class="cstat-no" title="statement not covered" >t</span>his.name="InteractiveTransactionError";<span class="cstat-no" title="statement not covered" >t</span>his.code="P5015"}</span>};w(Rr,"InteractiveTransactionError");var am="Request parameters are invalid",Cr=class extends V{<span class="fstat-no" title="function not covered" >co</span>nstructor(r,n=<span class="branch-0 cbranch-no" title="branch not covered" >am)</span>{<span class="cstat-no" title="statement not covered" >super(n,S(r,!1));<span class="cstat-no" title="statement not covered" >t</span>his.name="InvalidRequestError";<span class="cstat-no" title="statement not covered" >t</span>his.code="P5011"}</span>};w(Cr,"InvalidRequestError");var ro="Requested resource does not exist",Sr=class extends V{<span class="fstat-no" title="function not covered" >co</span>nstructor(r,n=<span class="branch-0 cbranch-no" title="branch not covered" >ro)</span>{<span class="cstat-no" title="statement not covered" >super(n,S(r,!1));<span class="cstat-no" title="statement not covered" >t</span>his.name="NotFoundError";<span class="cstat-no" title="statement not covered" >t</span>his.code="P5003"}</span>};w(Sr,"NotFoundError");var no="Unknown server error",Mt=class extends V{<span class="fstat-no" title="function not covered" >co</span>nstructor(r,n,i){<span class="cstat-no" title="statement not covered" >super(n||no,S(r,!0));<span class="cstat-no" title="statement not covered" >t</span>his.name="ServerError";<span class="cstat-no" title="statement not covered" >t</span>his.code="P5006";<span class="cstat-no" title="statement not covered" >t</span>his.logs=i}</span>};w(Mt,"ServerError");var io="Unauthorized, check your connection string",Ar=class extends V{<span class="fstat-no" title="function not covered" >co</span>nstructor(r,n=<span class="branch-0 cbranch-no" title="branch not covered" >io)</span>{<span class="cstat-no" title="statement not covered" >super(n,S(r,!1));<span class="cstat-no" title="statement not covered" >t</span>his.name="UnauthorizedError";<span class="cstat-no" title="statement not covered" >t</span>his.code="P5007"}</span>};w(Ar,"UnauthorizedError");var oo="Usage exceeded, retry again later",Ir=class extends V{<span class="fstat-no" title="function not covered" >co</span>nstructor(r,n=<span class="branch-0 cbranch-no" title="branch not covered" >oo)</span>{<span class="cstat-no" title="statement not covered" >super(n,S(r,!0));<span class="cstat-no" title="statement not covered" >t</span>his.name="UsageExceededError";<span class="cstat-no" title="statement not covered" >t</span>his.code="P5008"}</span>};w(Ir,"UsageExceededError");async function <span class="fstat-no" title="function not covered" >lm(</span>e){let t;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >t=await e.text()}</span>catch{<span class="cstat-no" title="statement not covered" >return{type:"EmptyError"}}<span class="cstat-no" title="statement not covered" ></span>t</span>ry{let r=<span class="cstat-no" title="statement not covered" >JSON.parse(t);<span class="cstat-no" title="statement not covered" ></span>if(typeof r=="string")<span class="cstat-no" title="statement not covered" >switch(r){case"InternalDataProxyError":<span class="cstat-no" title="statement not covered" >return{type:"DataProxyError",body:r};d</span>efault:<span class="cstat-no" title="statement not covered" >return{type:"UnknownTextError",body:r}}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(typeof r=="object"&amp;&amp;r!==null){<span class="cstat-no" title="statement not covered" >if("is_panic"in r&amp;&amp;"message"in r&amp;&amp;"error_code"in r)<span class="cstat-no" title="statement not covered" >return{type:"QueryEngineError",body:r};<span class="cstat-no" title="statement not covered" >i</span></span>f("EngineNotStarted"in r||"InteractiveTransactionMisrouted"in r||"InvalidRequestError"in r){let n=<span class="cstat-no" title="statement not covered" >Object.values(r)[0].reason;<span class="cstat-no" title="statement not covered" ></span>return typeof n=="string"&amp;&amp;!["SchemaMissing","EngineVersionNotSupported"].includes(n)?{type:"UnknownJsonError",body:r}:{type:"DataProxyError",body:r}}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{type:"UnknownJsonError",body:r}}</span>catch{<span class="cstat-no" title="statement not covered" >return t===""?{type:"EmptyError"}:{type:"UnknownTextError",body:t}}</span>}</span>async function <span class="fstat-no" title="function not covered" >Or(</span>e,t){<span class="cstat-no" title="statement not covered" >if(e.ok)<span class="cstat-no" title="statement not covered" >return;l</span></span>et r=<span class="cstat-no" title="statement not covered" >{clientVersion:t,response:e},</span>n=<span class="cstat-no" title="statement not covered" >await lm(e);<span class="cstat-no" title="statement not covered" ></span>if(n.type==="QueryEngineError")<span class="cstat-no" title="statement not covered" >throw new ee(n.body.message,{code:n.body.error_code,clientVersion:t});<span class="cstat-no" title="statement not covered" >i</span></span>f(n.type==="DataProxyError"){<span class="cstat-no" title="statement not covered" >if(n.body==="InternalDataProxyError")<span class="cstat-no" title="statement not covered" >throw new Mt(r,"Internal Data Proxy error");<span class="cstat-no" title="statement not covered" >i</span></span>f("EngineNotStarted"in n.body){<span class="cstat-no" title="statement not covered" >if(n.body.EngineNotStarted.reason==="SchemaMissing")<span class="cstat-no" title="statement not covered" >return new lt(r);<span class="cstat-no" title="statement not covered" >i</span></span>f(n.body.EngineNotStarted.reason==="EngineVersionNotSupported")<span class="cstat-no" title="statement not covered" >throw new Pr(r);<span class="cstat-no" title="statement not covered" >i</span></span>f("EngineStartupError"in n.body.EngineNotStarted.reason){let{msg:i,logs:o}=<span class="cstat-no" title="statement not covered" >n.body.EngineNotStarted.reason.EngineStartupError;<span class="cstat-no" title="statement not covered" ></span>throw new vr(r,i,o)}<span class="cstat-no" title="statement not covered" ></span>i</span>f("KnownEngineStartupError"in n.body.EngineNotStarted.reason){let{msg:i,error_code:o}=<span class="cstat-no" title="statement not covered" >n.body.EngineNotStarted.reason.KnownEngineStartupError;<span class="cstat-no" title="statement not covered" ></span>throw new T(i,t,o)}<span class="cstat-no" title="statement not covered" ></span>i</span>f("HealthcheckTimeout"in n.body.EngineNotStarted.reason){let{logs:i}=<span class="cstat-no" title="statement not covered" >n.body.EngineNotStarted.reason.HealthcheckTimeout;<span class="cstat-no" title="statement not covered" ></span>throw new xr(r,i)}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f("InteractiveTransactionMisrouted"in n.body){let i=<span class="cstat-no" title="statement not covered" >{IDParseError:"Could not parse interactive transaction ID",NoQueryEngineFoundError:"Could not find Query Engine for the specified host and transaction ID",TransactionStartError:"Could not start interactive transaction"};<span class="cstat-no" title="statement not covered" ></span>throw new Rr(r,i[n.body.InteractiveTransactionMisrouted.reason])}<span class="cstat-no" title="statement not covered" ></span>i</span>f("InvalidRequestError"in n.body)<span class="cstat-no" title="statement not covered" >throw new Cr(r,n.body.InvalidRequestError.reason)}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(e.status===401||e.status===403)<span class="cstat-no" title="statement not covered" >throw new Ar(r,$t(io,n));<span class="cstat-no" title="statement not covered" >i</span></span>f(e.status===404)<span class="cstat-no" title="statement not covered" >return new Sr(r,$t(ro,n));<span class="cstat-no" title="statement not covered" >i</span></span>f(e.status===429)<span class="cstat-no" title="statement not covered" >throw new Ir(r,$t(oo,n));<span class="cstat-no" title="statement not covered" >i</span></span>f(e.status===504)<span class="cstat-no" title="statement not covered" >throw new Tr(r,$t(to,n));<span class="cstat-no" title="statement not covered" >i</span></span>f(e.status&gt;=500)<span class="cstat-no" title="statement not covered" >throw new Mt(r,$t(no,n));<span class="cstat-no" title="statement not covered" >i</span></span>f(e.status&gt;=400)<span class="cstat-no" title="statement not covered" >throw new wr(r,$t(eo,n))}</span></span>function <span class="fstat-no" title="function not covered" >$t(</span>e,t){<span class="cstat-no" title="statement not covered" >return t.type==="EmptyError"?e:`${e}: ${JSON.stringify(t)}`}</span>function <span class="fstat-no" title="function not covered" >ll(</span>e){let t=<span class="cstat-no" title="statement not covered" >Math.pow(2,e)*50,</span>r=<span class="cstat-no" title="statement not covered" >Math.ceil(Math.random()*t)-Math.ceil(t/2),</span>n=<span class="cstat-no" title="statement not covered" >t+r;<span class="cstat-no" title="statement not covered" ></span>return new Promise(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >setTimeout(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >i(n),</span>n))</span>}</span>var qe="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";function <span class="fstat-no" title="function not covered" >ul(</span>e){let t=<span class="cstat-no" title="statement not covered" >new TextEncoder().encode(e),</span>r=<span class="cstat-no" title="statement not covered" >"",</span>n=<span class="cstat-no" title="statement not covered" >t.byteLength,</span>i=<span class="cstat-no" title="statement not covered" >n%3,</span>o=<span class="cstat-no" title="statement not covered" >n-i,</span>s,a,l,u,c;<span class="cstat-no" title="statement not covered" >for(let p=<span class="cstat-no" title="statement not covered" >0;</span>p&lt;o;p=p+3)<span class="cstat-no" title="statement not covered" >c=t[p]&lt;&lt;16|t[p+1]&lt;&lt;8|t[p+2],s=(c&amp;16515072)&gt;&gt;18,a=(c&amp;258048)&gt;&gt;12,l=(c&amp;4032)&gt;&gt;6,u=c&amp;63,r+=qe[s]+qe[a]+qe[l]+qe[u];<span class="cstat-no" title="statement not covered" >r</span></span>eturn i==1?(c=t[o],s=(c&amp;252)&gt;&gt;2,a=(c&amp;3)&lt;&lt;4,r+=qe[s]+qe[a]+"=="):i==2&amp;&amp;(c=t[o]&lt;&lt;8|t[o+1],s=(c&amp;64512)&gt;&gt;10,a=(c&amp;1008)&gt;&gt;4,l=(c&amp;15)&lt;&lt;2,r+=qe[s]+qe[a]+qe[l]+"="),r}</span>function <span class="fstat-no" title="function not covered" >cl(</span>e){<span class="cstat-no" title="statement not covered" >if(!!e.generator?.previewFeatures.some(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >r.toLowerCase().includes("metrics"))</span>)<span class="cstat-no" title="statement not covered" >throw new T("The `metrics` preview feature is not yet available with Accelerate.\nPlease remove `metrics` from the `previewFeatures` in your schema.\n\nMore information about Accelerate: https://pris.ly/d/accelerate",e.clientVersion)}</span></span>function <span class="fstat-no" title="function not covered" >um(</span>e){<span class="cstat-no" title="statement not covered" >return e[0]*1e3+e[1]/1e6}</span>function <span class="fstat-no" title="function not covered" >so(</span>e){<span class="cstat-no" title="statement not covered" >return new Date(um(e))}</span>var pl={"@prisma/debug":"workspace:*","@prisma/engines-version":"6.2.0-14.4123509d24aa4dede1e864b46351bf2790323b69","@prisma/fetch-engine":"workspace:*","@prisma/get-platform":"workspace:*"};var kr=class extends le{<span class="fstat-no" title="function not covered" >co</span>nstructor(r,n){<span class="cstat-no" title="statement not covered" >super(`Cannot fetch data from service:</span>
${r}`,S(n,!0));<span class="cstat-no" title="statement not covered" >this.name="RequestError";<span class="cstat-no" title="statement not covered" >t</span>his.code="P5010"}</span>};w(kr,"RequestError");async function <span class="fstat-no" title="function not covered" >ut(</span>e,t,r=<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >n)</span></span>{let{clientVersion:n,...i}=<span class="cstat-no" title="statement not covered" >t,</span>o=<span class="cstat-no" title="statement not covered" >r(fetch);<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >return await o(e,i)}</span>catch(s){let a=<span class="cstat-no" title="statement not covered" >s.message??"Unknown error";<span class="cstat-no" title="statement not covered" ></span>throw new kr(a,{clientVersion:n,cause:s})}</span>}</span>var pm=/^[1-9][0-9]*\.[0-9]+\.[0-9]+$/,dl=F("prisma:client:dataproxyEngine");async function <span class="fstat-no" title="function not covered" >dm(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >pl["@prisma/engines-version"],</span>n=<span class="cstat-no" title="statement not covered" >t.clientVersion??"unknown";<span class="cstat-no" title="statement not covered" ></span>if(process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION)<span class="cstat-no" title="statement not covered" >return process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION;<span class="cstat-no" title="statement not covered" >i</span></span>f(e.includes("accelerate")&amp;&amp;n!=="0.0.0"&amp;&amp;n!=="in-memory")<span class="cstat-no" title="statement not covered" >return n;l</span></span>et[i,o]=<span class="cstat-no" title="statement not covered" >n?.split("-")??[];<span class="cstat-no" title="statement not covered" ></span>if(o===void 0&amp;&amp;pm.test(i))<span class="cstat-no" title="statement not covered" >return i;<span class="cstat-no" title="statement not covered" >i</span></span>f(o!==void 0||n==="0.0.0"||n==="in-memory"){<span class="cstat-no" title="statement not covered" >if(e.startsWith("localhost")||e.startsWith("127.0.0.1"))<span class="cstat-no" title="statement not covered" >return"0.0.0";l</span></span>et[s]=<span class="cstat-no" title="statement not covered" >r.split("-")??[],</span>[a,l,u]=<span class="cstat-no" title="statement not covered" >s.split("."),</span>c=<span class="cstat-no" title="statement not covered" >mm(`&lt;=${a}.${l}.${u}`),</span>p=<span class="cstat-no" title="statement not covered" >await ut(c,{clientVersion:n});<span class="cstat-no" title="statement not covered" ></span>if(!p.ok)<span class="cstat-no" title="statement not covered" >throw new Error(`Failed to fetch stable Prisma version, unpkg.com status ${p.status} ${p.statusText}, response body: ${await p.text()||"&lt;empty body&gt;"}`);l</span></span>et d=<span class="cstat-no" title="statement not covered" >await p.text();<span class="cstat-no" title="statement not covered" ></span>dl("length of body fetched from unpkg.com",d.length);l</span>et f;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >f=JSON.parse(d)}</span>catch(g){<span class="cstat-no" title="statement not covered" >throw console.error("JSON.parse error: body fetched from unpkg.com: ",d),g}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn f.version}<span class="cstat-no" title="statement not covered" ></span>t</span>hrow new at("Only `major.minor.patch` versions are supported by Accelerate.",{clientVersion:n})}</span>async function <span class="fstat-no" title="function not covered" >ml(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >await dm(e,t);<span class="cstat-no" title="statement not covered" ></span>return dl("version",r),r}</span>function <span class="fstat-no" title="function not covered" >mm(</span>e){<span class="cstat-no" title="statement not covered" >return encodeURI(`https://unpkg.com/prisma@${e}/package.json`)}</span>var fl=3,Nn=F("prisma:client:dataproxyEngine"),ao=class{<span class="fstat-no" title="function not covered" >co</span>nstructor({apiKey:t,tracingHelper:r,logLevel:n,logQueries:i,engineHash:o}){<span class="cstat-no" title="statement not covered" >this.apiKey=t,this.tracingHelper=r,this.logLevel=n,this.logQueries=i,this.engineHash=o}<span class="fstat-no" title="function not covered" ></span>bu</span>ild({traceparent:t,interactiveTransaction:r}=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{let n=<span class="cstat-no" title="statement not covered" >{Authorization:`Bearer ${this.apiKey}`,"Prisma-Engine-Hash":this.engineHash};<span class="cstat-no" title="statement not covered" ></span>this.tracingHelper.isEnabled()&amp;&amp;(n.traceparent=t??this.tracingHelper.getTraceParent()),r&amp;&amp;(n["X-transaction-id"]=r.id);l</span>et i=<span class="cstat-no" title="statement not covered" >this.buildCaptureSettings();<span class="cstat-no" title="statement not covered" ></span>return i.length&gt;0&amp;&amp;(n["X-capture-telemetry"]=i.join(", ")),n}<span class="fstat-no" title="function not covered" ></span>bu</span>ildCaptureSettings(){let t=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return this.tracingHelper.isEnabled()&amp;&amp;t.push("tracing"),this.logLevel&amp;&amp;t.push(this.logLevel),this.logQueries&amp;&amp;t.push("query"),t}</span>},Dr=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.name="DataProxyEngine";<span class="cstat-no" title="statement not covered" >c</span>l(t),this.config=t,this.env={...t.env,...typeof process&lt;"u"?process.env:{}},this.inlineSchema=ul(t.inlineSchema),this.inlineDatasources=t.inlineDatasources,this.inlineSchemaHash=t.inlineSchemaHash,this.clientVersion=t.clientVersion,this.engineHash=t.engineVersion,this.logEmitter=t.logEmitter,this.tracingHelper=t.tracingHelper}<span class="fstat-no" title="function not covered" ></span>ap</span>iKey(){<span class="cstat-no" title="statement not covered" >return this.headerBuilder.apiKey}<span class="fstat-no" title="function not covered" ></span>ve</span>rsion(){<span class="cstat-no" title="statement not covered" >return this.engineHash}<span class="fstat-no" title="function not covered" ></span>as</span>ync start(){<span class="cstat-no" title="statement not covered" >this.startPromise!==void 0&amp;&amp;await this.startPromise,this.startPromise=(<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{let[t,r]=<span class="cstat-no" title="statement not covered" >this.extractHostAndApiKey();<span class="cstat-no" title="statement not covered" ></span>this.host=t,this.headerBuilder=new ao({apiKey:r,tracingHelper:this.tracingHelper,logLevel:this.config.logLevel,logQueries:this.config.logQueries,engineHash:this.engineHash}),this.remoteClientVersion=await ml(t,this.config),Nn("host",this.host)}</span>)(),await this.startPromise}<span class="fstat-no" title="function not covered" ></span>as</span>ync stop(){}<span class="fstat-no" title="function not covered" >pr</span>opagateResponseExtensions(t){<span class="cstat-no" title="statement not covered" >t?.logs?.length&amp;&amp;t.logs.forEach(<span class="fstat-no" title="function not covered" >r=</span>&gt;{<span class="cstat-no" title="statement not covered" >switch(r.level){case"debug":case"trace":<span class="cstat-no" title="statement not covered" >Nn(r);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"error":case"warn":case"info":{<span class="cstat-no" title="statement not covered" >this.logEmitter.emit(r.level,{timestamp:so(r.timestamp),message:r.attributes.message??"",target:r.target});<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"query":{<span class="cstat-no" title="statement not covered" >this.logEmitter.emit("query",{query:r.attributes.query??"",timestamp:so(r.timestamp),duration:r.attributes.duration_ms??0,params:r.attributes.params??"",target:r.target});<span class="cstat-no" title="statement not covered" >b</span>reak}</span>default:<span class="cstat-no" title="statement not covered" >r.level}</span>}</span>),t?.traces?.length&amp;&amp;this.tracingHelper.dispatchEngineSpans(t.traces)}<span class="fstat-no" title="function not covered" ></span>on</span>BeforeExit(){<span class="cstat-no" title="statement not covered" >throw new Error('"beforeExit" hook is not applicable to the remote query engine')}<span class="fstat-no" title="function not covered" ></span>as</span>ync url(t){<span class="cstat-no" title="statement not covered" >return await this.start(),`https://${this.host}/${this.remoteClientVersion}/${this.inlineSchemaHash}/${t}`}<span class="fstat-no" title="function not covered" ></span>as</span>ync uploadSchema(){let t=<span class="cstat-no" title="statement not covered" >{name:"schemaUpload",internal:!0};<span class="cstat-no" title="statement not covered" ></span>return this.tracingHelper.runInChildSpan(t,<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{let r=<span class="cstat-no" title="statement not covered" >await ut(await this.url("schema"),{method:"PUT",headers:this.headerBuilder.build(),body:this.inlineSchema,clientVersion:this.clientVersion});<span class="cstat-no" title="statement not covered" ></span>r.ok||Nn("schema response status",r.status);l</span>et n=<span class="cstat-no" title="statement not covered" >await Or(r,this.clientVersion);<span class="cstat-no" title="statement not covered" ></span>if(n)<span class="cstat-no" title="statement not covered" >throw this.logEmitter.emit("warn",{message:`Error while uploading schema: ${n.message}`,timestamp:new Date,target:""}),n;<span class="cstat-no" title="statement not covered" >t</span></span>his.logEmitter.emit("info",{message:`Schema (re)uploaded (hash: ${this.inlineSchemaHash})`,timestamp:new Date,target:""})}</span>)}<span class="fstat-no" title="function not covered" ></span>re</span>quest(t,{traceparent:r,interactiveTransaction:n,customDataProxyFetch:i}){<span class="cstat-no" title="statement not covered" >return this.requestInternal({body:t,traceparent:r,interactiveTransaction:n,customDataProxyFetch:i})}<span class="fstat-no" title="function not covered" ></span>as</span>ync requestBatch(t,{traceparent:r,transaction:n,customDataProxyFetch:i}){let o=<span class="cstat-no" title="statement not covered" >n?.kind==="itx"?n.options:void 0,</span>s=<span class="cstat-no" title="statement not covered" >Dt(t,n);<span class="cstat-no" title="statement not covered" ></span>return(await this.requestInternal({body:s,customDataProxyFetch:i,interactiveTransaction:o,traceparent:r})).map(<span class="fstat-no" title="function not covered" >l=</span>&gt;(<span class="cstat-no" title="statement not covered" >l.extensions&amp;&amp;this.propagateResponseExtensions(l.extensions),"errors"in l?this.convertProtocolErrorsToClientError(l.errors):l)</span>)}<span class="fstat-no" title="function not covered" ></span>re</span>questInternal({body:t,traceparent:r,customDataProxyFetch:n,interactiveTransaction:i}){<span class="cstat-no" title="statement not covered" >return this.withRetry({actionGerund:"querying",callback:<span class="fstat-no" title="function not covered" >as</span>ync({logHttpCall:o})=&gt;{let s=<span class="cstat-no" title="statement not covered" >i?`${i.payload.endpoint}/graphql`:await this.url("graphql");<span class="cstat-no" title="statement not covered" ></span>o(s);l</span>et a=<span class="cstat-no" title="statement not covered" >await ut(s,{method:"POST",headers:this.headerBuilder.build({traceparent:r,interactiveTransaction:i}),body:JSON.stringify(t),clientVersion:this.clientVersion},n);<span class="cstat-no" title="statement not covered" ></span>a.ok||Nn("graphql response status",a.status),await this.handleError(await Or(a,this.clientVersion));l</span>et l=<span class="cstat-no" title="statement not covered" >await a.json();<span class="cstat-no" title="statement not covered" ></span>if(l.extensions&amp;&amp;this.propagateResponseExtensions(l.extensions),"errors"in l)<span class="cstat-no" title="statement not covered" >throw this.convertProtocolErrorsToClientError(l.errors);<span class="cstat-no" title="statement not covered" >r</span></span>eturn"batchResult"in l?l.batchResult:l}</span>})}<span class="fstat-no" title="function not covered" ></span>as</span>ync transaction(t,r,n){let i=<span class="cstat-no" title="statement not covered" >{start:"starting",commit:"committing",rollback:"rolling back"};<span class="cstat-no" title="statement not covered" ></span>return this.withRetry({actionGerund:`${i[t]} transaction`,callback:<span class="fstat-no" title="function not covered" >as</span>ync({logHttpCall:o})=&gt;{<span class="cstat-no" title="statement not covered" >if(t==="start"){let s=<span class="cstat-no" title="statement not covered" >JSON.stringify({max_wait:n.maxWait,timeout:n.timeout,isolation_level:n.isolationLevel}),</span>a=<span class="cstat-no" title="statement not covered" >await this.url("transaction/start");<span class="cstat-no" title="statement not covered" ></span>o(a);l</span>et l=<span class="cstat-no" title="statement not covered" >await ut(a,{method:"POST",headers:this.headerBuilder.build({traceparent:r.traceparent}),body:s,clientVersion:this.clientVersion});<span class="cstat-no" title="statement not covered" ></span>await this.handleError(await Or(l,this.clientVersion));l</span>et u=<span class="cstat-no" title="statement not covered" >await l.json(),</span>{extensions:c}=<span class="cstat-no" title="statement not covered" >u;<span class="cstat-no" title="statement not covered" ></span>c&amp;&amp;this.propagateResponseExtensions(c);l</span>et p=<span class="cstat-no" title="statement not covered" >u.id,</span>d=<span class="cstat-no" title="statement not covered" >u["data-proxy"].endpoint;<span class="cstat-no" title="statement not covered" ></span>return{id:p,payload:{endpoint:d}}}</span>else{let s=<span class="cstat-no" title="statement not covered" >`${n.payload.endpoint}/${t}`;<span class="cstat-no" title="statement not covered" ></span>o(s);l</span>et a=<span class="cstat-no" title="statement not covered" >await ut(s,{method:"POST",headers:this.headerBuilder.build({traceparent:r.traceparent}),clientVersion:this.clientVersion});<span class="cstat-no" title="statement not covered" ></span>await this.handleError(await Or(a,this.clientVersion));l</span>et l=<span class="cstat-no" title="statement not covered" >await a.json(),</span>{extensions:u}=<span class="cstat-no" title="statement not covered" >l;<span class="cstat-no" title="statement not covered" ></span>u&amp;&amp;this.propagateResponseExtensions(u);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>}</span>})}<span class="fstat-no" title="function not covered" ></span>ex</span>tractHostAndApiKey(){let t=<span class="cstat-no" title="statement not covered" >{clientVersion:this.clientVersion},</span>r=<span class="cstat-no" title="statement not covered" >Object.keys(this.inlineDatasources)[0],</span>n=<span class="cstat-no" title="statement not covered" >Lt({inlineDatasources:this.inlineDatasources,overrideDatasources:this.config.overrideDatasources,clientVersion:this.clientVersion,env:this.env}),</span>i;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >i=new URL(n)}</span>catch{<span class="cstat-no" title="statement not covered" >throw new st(`Error validating datasource \`${r}\`: the URL must start with the protocol \`prisma://\``,t)}</span>l</span>et{protocol:o,host:s,searchParams:a}=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ></span>if(o!=="prisma:"&amp;&amp;o!=="prisma+postgres:")<span class="cstat-no" title="statement not covered" >throw new st(`Error validating datasource \`${r}\`: the URL must start with the protocol \`prisma://\``,t);l</span></span>et l=<span class="cstat-no" title="statement not covered" >a.get("api_key");<span class="cstat-no" title="statement not covered" ></span>if(l===null||l.length&lt;1)<span class="cstat-no" title="statement not covered" >throw new st(`Error validating datasource \`${r}\`: the URL must contain a valid API key`,t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn[s,l]}<span class="fstat-no" title="function not covered" ></span>me</span>trics(){<span class="cstat-no" title="statement not covered" >throw new at("Metrics are not yet supported for Accelerate",{clientVersion:this.clientVersion})}<span class="fstat-no" title="function not covered" ></span>as</span>ync withRetry(t){<span class="cstat-no" title="statement not covered" >for(let r=<span class="cstat-no" title="statement not covered" >0;</span>;r++){let n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >i=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.logEmitter.emit("info",{message:`Calling ${i} (n=${r})`,timestamp:new Date,target:""})}</span>;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >return await t.callback({logHttpCall:n})}</span>catch(i){<span class="cstat-no" title="statement not covered" >if(!(i instanceof le)||!i.isRetryable)<span class="cstat-no" title="statement not covered" >throw i;<span class="cstat-no" title="statement not covered" >i</span></span>f(r&gt;=fl)<span class="cstat-no" title="statement not covered" >throw i instanceof Ft?i.cause:i;<span class="cstat-no" title="statement not covered" >t</span></span>his.logEmitter.emit("warn",{message:`Attempt ${r+1}/${fl} failed for ${t.actionGerund}: ${i.message??"(unknown)"}`,timestamp:new Date,target:""});l</span>et o=<span class="cstat-no" title="statement not covered" >await ll(r);<span class="cstat-no" title="statement not covered" ></span>this.logEmitter.emit("warn",{message:`Retrying after ${o}ms`,timestamp:new Date,target:""})}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>as</span>ync handleError(t){<span class="cstat-no" title="statement not covered" >if(t instanceof lt)<span class="cstat-no" title="statement not covered" >throw await this.uploadSchema(),new Ft({clientVersion:this.clientVersion,cause:t});<span class="cstat-no" title="statement not covered" >i</span></span>f(t)<span class="cstat-no" title="statement not covered" >throw t}<span class="fstat-no" title="function not covered" ></span></span>co</span>nvertProtocolErrorsToClientError(t){<span class="cstat-no" title="statement not covered" >return t.length===1?_t(t[0],this.config.clientVersion,this.config.activeProvider):new B(JSON.stringify(t),{clientVersion:this.config.clientVersion})}<span class="fstat-no" title="function not covered" ></span>ap</span>plyPendingMigrations(){<span class="cstat-no" title="statement not covered" >throw new Error("Method not implemented.")}</span>};function <span class="fstat-no" title="function not covered" >gl(</span>e){<span class="cstat-no" title="statement not covered" >if(e?.kind==="itx")<span class="cstat-no" title="statement not covered" >return e.options.id}</span></span>var uo=D(require("os")),hl=D(require("path"));var lo=Symbol("PrismaLibraryEngineCache");function fm(){let e=globalThis;return e[lo]===void 0&amp;&amp;(e[lo]={}),e[lo]}function gm(e){let t=fm();if(t[e]!==void 0)return t[e];let r=hl.default.toNamespacedPath(e),n={exports:{}},i=0;return process.platform!=="win32"&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >i=uo.default.constants.dlopen.RTLD_LAZY|uo.default.constants.dlopen.RTLD_DEEPBIND)</span>,process.dlopen(n,r,i),t[e]=n.exports,n.exports}var yl={async loadLibrary(e){let t=await ei(),r=await tl("library",e);try{return e.tracingHelper.runInChildSpan({name:"loadLibrary",internal:!0},()=&gt;gm(r))}catch(n){let i=<span class="cstat-no" title="statement not covered" >di({e:n,platformInfo:t,id:r});<span class="cstat-no" title="statement not covered" ></span>throw new T(i,e.clientVersion)}</span>}};var co,El={<span class="fstat-no" title="function not covered" >as</span>ync loadLibrary(e){let{clientVersion:t,adapter:r,engineWasm:n}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>if(r===void 0)<span class="cstat-no" title="statement not covered" >throw new T(`The \`adapter\` option for \`PrismaClient\` is required in this context (${In().prettyName})`,t);<span class="cstat-no" title="statement not covered" >i</span></span>f(n===void 0)<span class="cstat-no" title="statement not covered" >throw new T("WASM engine was unexpectedly `undefined`",t);<span class="cstat-no" title="statement not covered" >c</span></span>o===void 0&amp;&amp;(co=(<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{let o=<span class="cstat-no" title="statement not covered" >n.getRuntime(),</span>s=<span class="cstat-no" title="statement not covered" >await n.getQueryEngineWasmModule();<span class="cstat-no" title="statement not covered" ></span>if(s==null)<span class="cstat-no" title="statement not covered" >throw new T("The loaded wasm module was unexpectedly `undefined` or `null` once loaded",t);l</span></span>et a=<span class="cstat-no" title="statement not covered" >{"./query_engine_bg.js":o},</span>l=<span class="cstat-no" title="statement not covered" >new WebAssembly.Instance(s,a);<span class="cstat-no" title="statement not covered" ></span>return o.__wbg_set_wasm(l.exports),o.QueryEngine}</span>)());l</span>et i=<span class="cstat-no" title="statement not covered" >await co;<span class="cstat-no" title="statement not covered" ></span>return{<span class="fstat-no" title="function not covered" >de</span>bugPanic(){<span class="cstat-no" title="statement not covered" >return Promise.reject("{}")}</span>,<span class="fstat-no" title="function not covered" >dm</span>mf(){<span class="cstat-no" title="statement not covered" >return Promise.resolve("{}")}</span>,<span class="fstat-no" title="function not covered" >ve</span>rsion(){<span class="cstat-no" title="statement not covered" >return{commit:"unknown",version:"unknown"}}</span>,QueryEngine:i}}</span>};var hm="P2036",Ie=F("prisma:client:libraryEngine");function <span class="fstat-no" title="function not covered" >ym(</span>e){<span class="cstat-no" title="statement not covered" >return e.item_type==="query"&amp;&amp;"query"in e}</span>function <span class="fstat-no" title="function not covered" >Em(</span>e){<span class="cstat-no" title="statement not covered" >return"level"in e?e.level==="error"&amp;&amp;e.message==="PANIC":!1}</span>var bl=[...Wn,"native"],bm=0xffffffffffffffffn,po=1n;function wm(){let e=po++;return po&gt;bm&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >po=1n)</span>,e}var _r=class{constructor(t,r){this.name="LibraryEngine";this.libraryLoader=r??yl,t.engineWasm!==void 0&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >this.libraryLoader=r??El)</span>,this.config=t,this.libraryStarted=!1,this.logQueries=t.logQueries??!1,this.logLevel=t.logLevel??"error",this.logEmitter=t.logEmitter,this.datamodel=t.inlineSchema,this.tracingHelper=t.tracingHelper,t.enableDebugLogs&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >this.logLevel="debug")</span>;let n=Object.keys(t.overrideDatasources)[0],i=t.overrideDatasources[n]?.url;n!==void 0&amp;&amp;i!==void 0&amp;&amp;(this.datasourceOverrides={[n]:i}),this.libraryInstantiationPromise=this.instantiateLibrary()}wrapEngine(t){return{applyPendingMigrations:t.applyPendingMigrations?.bind(t),commitTransaction:this.withRequestId(t.commitTransaction.bind(t)),connect:this.withRequestId(t.connect.bind(t)),disconnect:this.withRequestId(t.disconnect.bind(t)),metrics:t.metrics?.bind(t),query:this.withRequestId(t.query.bind(t)),rollbackTransaction:this.withRequestId(t.rollbackTransaction.bind(t)),sdlSchema:t.sdlSchema?.bind(t),startTransaction:this.withRequestId(t.startTransaction.bind(t)),trace:t.trace.bind(t)}}withRequestId(t){return async(...r)=&gt;{let n=wm().toString();try{return await t(...r,n)}finally{<span class="missing-if-branch" title="if path not taken" >I</span>if(this.tracingHelper.isEnabled()){let i=<span class="cstat-no" title="statement not covered" >await this.engine?.trace(n);<span class="cstat-no" title="statement not covered" ></span>if(i){let o=<span class="cstat-no" title="statement not covered" >JSON.parse(i);<span class="cstat-no" title="statement not covered" ></span>this.tracingHelper.dispatchEngineSpans(o.spans)}</span>}</span>}}}<span class="fstat-no" title="function not covered" >as</span>ync applyPendingMigrations(){<span class="cstat-no" title="statement not covered" >throw new Error("Cannot call this method from this type of engine instance")}<span class="fstat-no" title="function not covered" ></span>as</span>ync transaction(t,r,n){<span class="cstat-no" title="statement not covered" >await this.start();l</span>et i=<span class="cstat-no" title="statement not covered" >JSON.stringify(r),</span>o;<span class="cstat-no" title="statement not covered" >if(t==="start"){let a=<span class="cstat-no" title="statement not covered" >JSON.stringify({max_wait:n.maxWait,timeout:n.timeout,isolation_level:n.isolationLevel});<span class="cstat-no" title="statement not covered" ></span>o=await this.engine?.startTransaction(a,i)}</span>else <span class="cstat-no" title="statement not covered" >t==="commit"?o=await this.engine?.commitTransaction(n.id,i):t==="rollback"&amp;&amp;(o=await this.engine?.rollbackTransaction(n.id,i));l</span></span>et s=<span class="cstat-no" title="statement not covered" >this.parseEngineResponse(o);<span class="cstat-no" title="statement not covered" ></span>if(xm(s)){let a=<span class="cstat-no" title="statement not covered" >this.getExternalAdapterError(s);<span class="cstat-no" title="statement not covered" ></span>throw a?a.error:new ee(s.message,{code:s.error_code,clientVersion:this.config.clientVersion,meta:s.meta})}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}</span>async instantiateLibrary(){<span class="missing-if-branch" title="if path not taken" >I</span>if(Ie("internalSetup"),this.libraryInstantiationPromise)<span class="cstat-no" title="statement not covered" >return this.libraryInstantiationPromise;H</span>n(),this.binaryTarget=await this.getCurrentBinaryTarget(),await this.tracingHelper.runInChildSpan("load_engine",()=&gt;this.loadEngine()),this.version()}async getCurrentBinaryTarget(){{<span class="missing-if-branch" title="if path not taken" >I</span>if(this.binaryTarget)<span class="cstat-no" title="statement not covered" >return this.binaryTarget;l</span>et t=await this.tracingHelper.runInChildSpan("detect_platform",()=&gt;nt());<span class="missing-if-branch" title="if path not taken" >I</span>if(!bl.includes(t))<span class="cstat-no" title="statement not covered" >throw new T(`Unknown ${de("PRISMA_QUERY_ENGINE_LIBRARY")} ${de(W(t))}. Possible binaryTargets: ${Ve(bl.join(", "))} or a path to the query engine library.</span>
You may have to run ${Ve("prisma generate")} for your changes to take effect.`,this.config.clientVersion);return t}}parseEngineResponse(t){<span class="missing-if-branch" title="if path not taken" >I</span>if(!t)<span class="cstat-no" title="statement not covered" >throw new B("Response from the Engine was empty",{clientVersion:this.config.clientVersion});t</span>ry{return JSON.parse(t)}catch{<span class="cstat-no" title="statement not covered" >throw new B("Unable to JSON.parse response from engine",{clientVersion:this.config.clientVersion})}</span>}async loadEngine(){<span class="missing-if-branch" title="else path not taken" >E</span>if(!this.engine){this.QueryEngineConstructor||(this.library=await this.libraryLoader.loadLibrary(this.config),this.QueryEngineConstructor=this.library.QueryEngine);try{let t=new WeakRef(this),{adapter:r}=this.config;r&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >Ie("Using driver adapter: %O",r),</span>this.engine=this.wrapEngine(new this.QueryEngineConstructor({datamodel:this.datamodel,env:process.env,logQueries:this.config.logQueries??!1,ignoreEnvVarErrors:!0,datasourceOverrides:this.datasourceOverrides??{},logLevel:this.logLevel,configDir:this.config.cwd,engineProtocol:"json",enableTracing:this.tracingHelper.isEnabled()},<span class="fstat-no" title="function not covered" >n=</span>&gt;{<span class="cstat-no" title="statement not covered" >t.deref()?.logger(n)}</span>,r))}catch(t){let r=<span class="cstat-no" title="statement not covered" >t,</span>n=<span class="cstat-no" title="statement not covered" >this.parseInitError(r.message);<span class="cstat-no" title="statement not covered" ></span>throw typeof n=="string"?r:new T(n.message,this.config.clientVersion,n.error_code)}</span>}}<span class="fstat-no" title="function not covered" >lo</span>gger(t){let r=<span class="cstat-no" title="statement not covered" >this.parseEngineResponse(t);<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;(r.level=r?.level.toLowerCase()??"unknown",ym(r)?this.logEmitter.emit("query",{timestamp:new Date,query:r.query,params:r.params,duration:Number(r.duration_ms),target:r.module_path}):Em(r)?this.loggerRustPanic=new ce(mo(this,`${r.message}: ${r.reason} in ${r.file}:${r.line}:${r.column}`),this.config.clientVersion):this.logEmitter.emit(r.level,{timestamp:new Date,message:r.message,target:r.module_path}))}<span class="fstat-no" title="function not covered" ></span>pa</span>rseInitError(t){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return JSON.parse(t)}</span>catch{}<span class="cstat-no" title="statement not covered" >r</span>eturn t}<span class="fstat-no" title="function not covered" ></span>pa</span>rseRequestError(t){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return JSON.parse(t)}</span>catch{}<span class="cstat-no" title="statement not covered" >r</span>eturn t}<span class="fstat-no" title="function not covered" ></span>on</span>BeforeExit(){<span class="cstat-no" title="statement not covered" >throw new Error('"beforeExit" hook is not applicable to the library engine since Prisma 5.0.0, it is only relevant and implemented for the binary engine. Please add your event listener to the `process` object directly instead.')}</span>async start(){<span class="missing-if-branch" title="if path not taken" >I</span>if(await this.libraryInstantiationPromise,await this.libraryStoppingPromise,this.libraryStartingPromise)<span class="cstat-no" title="statement not covered" >return Ie(`library already starting, this.libraryStarted: ${this.libraryStarted}`),this.libraryStartingPromise;<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(this.libraryStarted)<span class="cstat-no" title="statement not covered" >return;l</span>et t=async()=&gt;{Ie("library starting");try{let r={traceparent:this.tracingHelper.getTraceParent()};await this.engine?.connect(JSON.stringify(r)),this.libraryStarted=!0,Ie("library started")}catch(r){let n=<span class="cstat-no" title="statement not covered" >this.parseInitError(r.message);<span class="cstat-no" title="statement not covered" ></span>throw typeof n=="string"?r:new T(n.message,this.config.clientVersion,n.error_code)}</span>finally{this.libraryStartingPromise=void 0}};return this.libraryStartingPromise=this.tracingHelper.runInChildSpan("connect",t),this.libraryStartingPromise}async stop(){<span class="missing-if-branch" title="if path not taken" >I</span>if(await this.libraryStartingPromise,await this.executingQueryPromise,this.libraryStoppingPromise)<span class="cstat-no" title="statement not covered" >return Ie("library is already stopping"),this.libraryStoppingPromise;<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!this.libraryStarted)<span class="cstat-no" title="statement not covered" >return;l</span>et t=async()=&gt;{await new Promise(n=&gt;setTimeout(n,5)),Ie("library stopping");let r={traceparent:this.tracingHelper.getTraceParent()};await this.engine?.disconnect(JSON.stringify(r)),this.libraryStarted=!1,this.libraryStoppingPromise=void 0,Ie("library stopped")};return this.libraryStoppingPromise=this.tracingHelper.runInChildSpan("disconnect",t),this.libraryStoppingPromise}version(){return this.versionInfo=this.library?.version(),this.versionInfo?.version??<span class="branch-1 cbranch-no" title="branch not covered" >"unknown"}<span class="fstat-no" title="function not covered" ></span>de</span>bugPanic(t){<span class="cstat-no" title="statement not covered" >return this.library?.debugPanic(t)}</span>async request(t,{traceparent:r,interactiveTransaction:n}){Ie(`sending request, this.libraryStarted: ${this.libraryStarted}`);let i=JSON.stringify({traceparent:r}),o=JSON.stringify(t);try{await this.start(),this.executingQueryPromise=this.engine?.query(o,i,n?.id),this.lastQuery=o;let s=this.parseEngineResponse(await this.executingQueryPromise);<span class="missing-if-branch" title="if path not taken" >I</span>if(s.errors)<span class="cstat-no" title="statement not covered" >throw s.errors.length===1?this.buildQueryError(s.errors[0]):new B(JSON.stringify(s.errors),{clientVersion:this.config.clientVersion});<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(this.loggerRustPanic)<span class="cstat-no" title="statement not covered" >throw this.loggerRustPanic;r</span>eturn{data:s}}catch(s){<span class="cstat-no" title="statement not covered" >if(s instanceof T)<span class="cstat-no" title="statement not covered" >throw s;<span class="cstat-no" title="statement not covered" >i</span></span>f(s.code==="GenericFailure"&amp;&amp;s.message?.startsWith("PANIC:"))<span class="cstat-no" title="statement not covered" >throw new ce(mo(this,s.message),this.config.clientVersion);l</span></span>et a=<span class="cstat-no" title="statement not covered" >this.parseRequestError(s.message);<span class="cstat-no" title="statement not covered" ></span>throw typeof a=="string"?s:new B(`${a.message}</span>
${a.backtrace}`,{clientVersion:this.config.clientVersion})}}<span class="fstat-no" title="function not covered" >as</span>ync requestBatch(t,{transaction:r,traceparent:n}){<span class="cstat-no" title="statement not covered" >Ie("requestBatch");l</span>et i=<span class="cstat-no" title="statement not covered" >Dt(t,r);<span class="cstat-no" title="statement not covered" ></span>await this.start(),this.lastQuery=JSON.stringify(i),this.executingQueryPromise=this.engine.query(this.lastQuery,JSON.stringify({traceparent:n}),gl(r));l</span>et o=<span class="cstat-no" title="statement not covered" >await this.executingQueryPromise,</span>s=<span class="cstat-no" title="statement not covered" >this.parseEngineResponse(o);<span class="cstat-no" title="statement not covered" ></span>if(s.errors)<span class="cstat-no" title="statement not covered" >throw s.errors.length===1?this.buildQueryError(s.errors[0]):new B(JSON.stringify(s.errors),{clientVersion:this.config.clientVersion});l</span></span>et{batchResult:a,errors:l}=<span class="cstat-no" title="statement not covered" >s;<span class="cstat-no" title="statement not covered" ></span>if(Array.isArray(a))<span class="cstat-no" title="statement not covered" >return a.map(<span class="fstat-no" title="function not covered" >u=</span>&gt;<span class="cstat-no" title="statement not covered" >u.errors&amp;&amp;u.errors.length&gt;0?this.loggerRustPanic??this.buildQueryError(u.errors[0]):{data:u})</span>;<span class="cstat-no" title="statement not covered" >t</span></span>hrow l&amp;&amp;l.length===1?new Error(l[0].error):new Error(JSON.stringify(s))}<span class="fstat-no" title="function not covered" ></span>bu</span>ildQueryError(t){<span class="cstat-no" title="statement not covered" >if(t.user_facing_error.is_panic)<span class="cstat-no" title="statement not covered" >return new ce(mo(this,t.user_facing_error.message),this.config.clientVersion);l</span></span>et r=<span class="cstat-no" title="statement not covered" >this.getExternalAdapterError(t.user_facing_error);<span class="cstat-no" title="statement not covered" ></span>return r?r.error:_t(t,this.config.clientVersion,this.config.activeProvider)}<span class="fstat-no" title="function not covered" ></span>ge</span>tExternalAdapterError(t){<span class="cstat-no" title="statement not covered" >if(t.error_code===hm&amp;&amp;this.config.adapter){let r=<span class="cstat-no" title="statement not covered" >t.meta?.id;<span class="cstat-no" title="statement not covered" ></span>Yr(typeof r=="number","Malformed external JS error received from the engine");l</span>et n=<span class="cstat-no" title="statement not covered" >this.config.adapter.errorRegistry.consumeError(r);<span class="cstat-no" title="statement not covered" ></span>return Yr(n,"External error with reported id was not registered"),n}</span>}<span class="fstat-no" title="function not covered" ></span>as</span>ync metrics(t){<span class="cstat-no" title="statement not covered" >await this.start();l</span>et r=<span class="cstat-no" title="statement not covered" >await this.engine.metrics(JSON.stringify(t));<span class="cstat-no" title="statement not covered" ></span>return t.format==="prometheus"?r:this.parseEngineResponse(r)}</span>};function <span class="fstat-no" title="function not covered" >xm(</span>e){<span class="cstat-no" title="statement not covered" >return typeof e=="object"&amp;&amp;e!==null&amp;&amp;e.error_code!==void 0}</span>function <span class="fstat-no" title="function not covered" >mo(</span>e,t){<span class="cstat-no" title="statement not covered" >return al({binaryTarget:e.binaryTarget,title:t,version:e.config.clientVersion,engineVersion:e.versionInfo?.commit,database:e.config.activeProvider,query:e.lastQuery})}</span>function wl({copyEngine:e=<span class="branch-0 cbranch-no" title="branch not covered" >!0}</span>,t){let r;try{r=Lt({inlineDatasources:t.inlineDatasources,overrideDatasources:t.overrideDatasources,env:{...t.env,...process.env},clientVersion:t.clientVersion})}catch{}let n=!!(r?.startsWith("prisma://")||r?.startsWith("prisma+postgres://"));e&amp;&amp;n&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >tr("recommend--no-engine","In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)");</span>let i=Yt(t.generator),o=n||!e,s=!!t.adapter,a=i==="library",l=i==="binary";<span class="missing-if-branch" title="if path not taken" >I</span>if(o&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >s|</span>|s&amp;&amp;<span class="branch-3 cbranch-no" title="branch not covered" >!1)</span>{let u;<span class="cstat-no" title="statement not covered" >throw e?r?.startsWith("prisma://")?u=["Prisma Client was configured to use the `adapter` option but the URL was a `prisma://` URL.","Please either use the `prisma://` URL or remove the `adapter` from the Prisma Client constructor."]:u=["Prisma Client was configured to use both the `adapter` and Accelerate, please chose one."]:u=["Prisma Client was configured to use the `adapter` option but `prisma generate` was run with `--no-engine`.","Please run `prisma generate` without `--no-engine` to be able to use Prisma Client with the adapter."],new te(u.join(`</span>
`),{clientVersion:t.clientVersion})}<span class="missing-if-branch" title="if path not taken" >I</span>if(o)<span class="cstat-no" title="statement not covered" >return new Dr(t);<span class="missing-if-branch" title="else path not taken" >E</span>i</span>f(a)return new _r(t);<span class="cstat-no" title="statement not covered" >throw new te("Invalid client engine type, please use `library` or `binary`",{clientVersion:t.clientVersion})}</span>function Ln({generator:e}){return e?.previewFeatures??<span class="branch-1 cbranch-no" title="branch not covered" >[]}</span>var xl=<span class="fstat-no" title="function not covered" >e=</span>&gt;(<span class="cstat-no" title="statement not covered" >{command:e})</span>;var vl=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.strings.reduce(<span class="fstat-no" title="function not covered" >(t</span>,r,n)=&gt;<span class="cstat-no" title="statement not covered" >`${t}@P${n}${r}`)</span>;</span>function <span class="fstat-no" title="function not covered" >qt(</span>e){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return Pl(e,"fast")}</span>catch{<span class="cstat-no" title="statement not covered" >return Pl(e,"slow")}</span>}</span>function <span class="fstat-no" title="function not covered" >Pl(</span>e,t){<span class="cstat-no" title="statement not covered" >return JSON.stringify(e.map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >Rl(r,t))</span>)}</span>function <span class="fstat-no" title="function not covered" >Rl(</span>e,t){<span class="cstat-no" title="statement not covered" >if(Array.isArray(e))<span class="cstat-no" title="statement not covered" >return e.map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >Rl(r,t))</span>;<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof e=="bigint")<span class="cstat-no" title="statement not covered" >return{prisma__type:"bigint",prisma__value:e.toString()};<span class="cstat-no" title="statement not covered" >i</span></span>f(xt(e))<span class="cstat-no" title="statement not covered" >return{prisma__type:"date",prisma__value:e.toJSON()};<span class="cstat-no" title="statement not covered" >i</span></span>f(ve.isDecimal(e))<span class="cstat-no" title="statement not covered" >return{prisma__type:"decimal",prisma__value:e.toJSON()};<span class="cstat-no" title="statement not covered" >i</span></span>f(Buffer.isBuffer(e))<span class="cstat-no" title="statement not covered" >return{prisma__type:"bytes",prisma__value:e.toString("base64")};<span class="cstat-no" title="statement not covered" >i</span></span>f(vm(e))<span class="cstat-no" title="statement not covered" >return{prisma__type:"bytes",prisma__value:Buffer.from(e).toString("base64")};<span class="cstat-no" title="statement not covered" >i</span></span>f(ArrayBuffer.isView(e)){let{buffer:r,byteOffset:n,byteLength:i}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return{prisma__type:"bytes",prisma__value:Buffer.from(r,n,i).toString("base64")}}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn typeof e=="object"&amp;&amp;t==="slow"?Cl(e):e}</span>function <span class="fstat-no" title="function not covered" >vm(</span>e){<span class="cstat-no" title="statement not covered" >return e instanceof ArrayBuffer||e instanceof SharedArrayBuffer?!0:typeof e=="object"&amp;&amp;e!==null?e[Symbol.toStringTag]==="ArrayBuffer"||e[Symbol.toStringTag]==="SharedArrayBuffer":!1}</span>function <span class="fstat-no" title="function not covered" >Cl(</span>e){<span class="cstat-no" title="statement not covered" >if(typeof e!="object"||e===null)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof e.toJSON=="function")<span class="cstat-no" title="statement not covered" >return e.toJSON();<span class="cstat-no" title="statement not covered" >i</span></span>f(Array.isArray(e))<span class="cstat-no" title="statement not covered" >return e.map(Tl);l</span></span>et t=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let r of Object.keys(e))<span class="cstat-no" title="statement not covered" >t[r]=Tl(e[r]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>function <span class="fstat-no" title="function not covered" >Tl(</span>e){<span class="cstat-no" title="statement not covered" >return typeof e=="bigint"?e.toString():Cl(e)}</span>var Pm=["$connect","$disconnect","$on","$transaction","$use","$extends"],Sl=Pm;var Tm=/^(\s*alter\s)/i,Al=F("prisma:client");function <span class="fstat-no" title="function not covered" >fo(</span>e,t,r,n){<span class="cstat-no" title="statement not covered" >if(!(e!=="postgresql"&amp;&amp;e!=="cockroachdb")&amp;&amp;r.length&gt;0&amp;&amp;Tm.exec(t))<span class="cstat-no" title="statement not covered" >throw new Error(`Running ALTER using ${n} is not supported</span></span>
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.
&nbsp;
Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)
&nbsp;
More Information: https://pris.ly/d/execute-raw
`)}var go=<span class="fstat-no" title="function not covered" >({</span>clientMethod:e,activeProvider:t})=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >r=</span>&gt;{let n=<span class="cstat-no" title="statement not covered" >"",</span>i;<span class="cstat-no" title="statement not covered" >if(ya(r))<span class="cstat-no" title="statement not covered" >n=r.sql,i={values:qt(r.values),__prismaRawParameters__:!0};e</span>lse <span class="cstat-no" title="statement not covered" >if(Array.isArray(r)){let[o,...s]=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" ></span>n=o,i={values:qt(s||[]),__prismaRawParameters__:!0}}</span>else <span class="cstat-no" title="statement not covered" >switch(t){case"sqlite":case"mysql":{<span class="cstat-no" title="statement not covered" >n=r.sql,i={values:qt(r.values),__prismaRawParameters__:!0};<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"cockroachdb":case"postgresql":case"postgres":{<span class="cstat-no" title="statement not covered" >n=r.text,i={values:qt(r.values),__prismaRawParameters__:!0};<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"sqlserver":{<span class="cstat-no" title="statement not covered" >n=vl(r),i={values:qt(r.values),__prismaRawParameters__:!0};<span class="cstat-no" title="statement not covered" >b</span>reak}</span>default:<span class="cstat-no" title="statement not covered" >throw new Error(`The ${t} provider does not support ${e}`)}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>eturn i?.values?Al(`prisma.${e}(${n}, ${i.values})`):Al(`prisma.${e}(${n})`),{query:n,parameters:i}}</span>,</span>Il={<span class="fstat-no" title="function not covered" >re</span>questArgsToMiddlewareArgs(e){<span class="cstat-no" title="statement not covered" >return[e.strings,...e.values]}</span>,<span class="fstat-no" title="function not covered" >mi</span>ddlewareArgsToRequestArgs(e){let[t,...r]=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return new ae(t,r)}</span>},Ol={<span class="fstat-no" title="function not covered" >re</span>questArgsToMiddlewareArgs(e){<span class="cstat-no" title="statement not covered" >return[e]}</span>,<span class="fstat-no" title="function not covered" >mi</span>ddlewareArgsToRequestArgs(e){<span class="cstat-no" title="statement not covered" >return e[0]}</span>};function ho(e){return function(r){let n,i=(o=e)=&gt;{try{return o===void 0||<span class="branch-1 cbranch-no" title="branch not covered" >o?.kind==="itx"?</span>n??=kl(r(o)):<span class="branch-1 cbranch-no" title="branch not covered" >kl(r(o))}</span>catch(s){<span class="cstat-no" title="statement not covered" >return Promise.reject(s)}</span>};return{then(o,s){return i().then(o,s)},<span class="fstat-no" title="function not covered" >ca</span>tch(o){<span class="cstat-no" title="statement not covered" >return i().catch(o)}</span>,<span class="fstat-no" title="function not covered" >fi</span>nally(o){<span class="cstat-no" title="statement not covered" >return i().finally(o)}</span>,<span class="fstat-no" title="function not covered" >re</span>questTransaction(o){let s=<span class="cstat-no" title="statement not covered" >i(o);<span class="cstat-no" title="statement not covered" ></span>return s.requestTransaction?s.requestTransaction(o):s}</span>,[Symbol.toStringTag]:"PrismaPromise"}}}function kl(e){return typeof e.then=="function"?e:<span class="branch-1 cbranch-no" title="branch not covered" >Promise.resolve(e)}</span>var Rm={isEnabled(){return!1},getTraceParent(){return"00-10-10-00"},<span class="fstat-no" title="function not covered" >di</span>spatchEngineSpans(){},getActiveContext(){},runInChildSpan(e,t){return t()}},yo=class{isEnabled(){return this.getGlobalTracingHelper().isEnabled()}getTraceParent(t){return this.getGlobalTracingHelper().getTraceParent(t)}<span class="fstat-no" title="function not covered" >di</span>spatchEngineSpans(t){<span class="cstat-no" title="statement not covered" >return this.getGlobalTracingHelper().dispatchEngineSpans(t)}</span>getActiveContext(){return this.getGlobalTracingHelper().getActiveContext()}runInChildSpan(t,r){return this.getGlobalTracingHelper().runInChildSpan(t,r)}getGlobalTracingHelper(){return globalThis.PRISMA_INSTRUMENTATION?.helper??Rm}};function Dl(){return new yo}function <span class="fstat-no" title="function not covered" >_l(</span>e,t=<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >()</span>=&gt;{})</span>{let r,n=<span class="cstat-no" title="statement not covered" >new Promise(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >r=i)</span>;<span class="cstat-no" title="statement not covered" ></span>return{<span class="fstat-no" title="function not covered" >th</span>en(i){<span class="cstat-no" title="statement not covered" >return--e===0&amp;&amp;r(t()),i?.(n)}</span>}}</span>function <span class="fstat-no" title="function not covered" >Nl(</span>e){<span class="cstat-no" title="statement not covered" >return typeof e=="string"?e:e.reduce(<span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{let n=<span class="cstat-no" title="statement not covered" >typeof r=="string"?r:r.level;<span class="cstat-no" title="statement not covered" ></span>return n==="query"?t:t&amp;&amp;(r==="info"||t==="info")?"info":n}</span>,void 0)}</span>var Fn=class{constructor(){this._middlewares=[]}<span class="fstat-no" title="function not covered" >us</span>e(t){<span class="cstat-no" title="statement not covered" >this._middlewares.push(t)}</span>get(t){return this._middlewares[t]}<span class="fstat-no" title="function not covered" >ha</span>s(t){<span class="cstat-no" title="statement not covered" >return!!this._middlewares[t]}<span class="fstat-no" title="function not covered" ></span>le</span>ngth(){<span class="cstat-no" title="statement not covered" >return this._middlewares.length}</span>};var Fl=D(Pi());function <span class="fstat-no" title="function not covered" >Mn(</span>e){<span class="cstat-no" title="statement not covered" >return typeof e.batchRequestIdx=="number"}</span>function Ll(e){if(e.action!=="findUnique"&amp;&amp;e.action!=="findUniqueOrThrow")return;let t=[];return e.modelName&amp;&amp;t.push(e.modelName),e.query.arguments&amp;&amp;t.push(Eo(e.query.arguments)),t.push(Eo(e.query.selection)),t.join("")}function Eo(e){return`(${Object.keys(e).sort().map(r=&gt;{let n=e[r];return typeof n=="object"&amp;&amp;n!==null?`(${r} ${Eo(n)})`:r}).join(" ")})`}var Cm={aggregate:!1,aggregateRaw:!1,createMany:!0,createManyAndReturn:!0,createOne:!0,deleteMany:!0,deleteOne:!0,executeRaw:!0,findFirst:!1,findFirstOrThrow:!1,findMany:!1,findRaw:!1,findUnique:!1,findUniqueOrThrow:!1,groupBy:!1,queryRaw:!1,runCommandRaw:!0,updateMany:!0,updateManyAndReturn:!0,updateOne:!0,upsertOne:!0};function bo(e){return Cm[e]}var $n=class{constructor(t){this.options=t;this.tickActive=!1;this.batches={}}request(t){let r=this.options.batchBy(t);return r?(this.batches[r]||(this.batches[r]=[],this.tickActive||(this.tickActive=!0,process.nextTick(()=&gt;{this.dispatchBatches(),this.tickActive=!1}))),new Promise((n,i)=&gt;{this.batches[r].push({request:t,resolve:n,reject:i})})):this.options.singleLoader(t)}dispatchBatches(){for(let t in this.batches){let r=this.batches[t];delete this.batches[t],r.length===1?this.options.singleLoader(r[0].request).then(n=&gt;{n instanceof Error?<span class="branch-0 cbranch-no" title="branch not covered" >r[0].reject(n):</span>r[0].resolve(n)}).catch(<span class="fstat-no" title="function not covered" >n=</span>&gt;{<span class="cstat-no" title="statement not covered" >r[0].reject(n)}</span>):(<span class="branch-1 cbranch-no" title="branch not covered" >r.sort(<span class="fstat-no" title="function not covered" >(n</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >this.options.batchOrder(n.request,i.request))</span>,this.options.batchLoader(r.map(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >n.request)</span>).then(<span class="fstat-no" title="function not covered" >n=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(n instanceof Error)<span class="cstat-no" title="statement not covered" >for(let i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;r.length;i++)<span class="cstat-no" title="statement not covered" >r[i].reject(n);e</span></span>lse <span class="cstat-no" title="statement not covered" >for(let i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;r.length;i++){let o=<span class="cstat-no" title="statement not covered" >n[i];<span class="cstat-no" title="statement not covered" ></span>o instanceof Error?r[i].reject(o):r[i].resolve(o)}</span>}</span></span>).catch(<span class="fstat-no" title="function not covered" >n=</span>&gt;{<span class="cstat-no" title="statement not covered" >for(let i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;r.length;i++)<span class="cstat-no" title="statement not covered" >r[i].reject(n)}</span></span>))</span>}}<span class="fstat-no" title="function not covered" >ge</span>t[Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"DataLoader"}</span>};function <span class="fstat-no" title="function not covered" >ct(</span>e,t){<span class="cstat-no" title="statement not covered" >if(t===null)<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >s</span></span>witch(e){case"bigint":<span class="cstat-no" title="statement not covered" >return BigInt(t);c</span>ase"bytes":{let{buffer:r,byteOffset:n,byteLength:i}=<span class="cstat-no" title="statement not covered" >Buffer.from(t,"base64");<span class="cstat-no" title="statement not covered" ></span>return new Uint8Array(r,n,i)}</span>case"decimal":<span class="cstat-no" title="statement not covered" >return new ve(t);c</span>ase"datetime":case"date":<span class="cstat-no" title="statement not covered" >return new Date(t);c</span>ase"time":<span class="cstat-no" title="statement not covered" >return new Date(`1970-01-01T${t}Z`);c</span>ase"bigint-array":<span class="cstat-no" title="statement not covered" >return t.map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >ct("bigint",r))</span>;c</span>ase"bytes-array":<span class="cstat-no" title="statement not covered" >return t.map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >ct("bytes",r))</span>;c</span>ase"decimal-array":<span class="cstat-no" title="statement not covered" >return t.map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >ct("decimal",r))</span>;c</span>ase"datetime-array":<span class="cstat-no" title="statement not covered" >return t.map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >ct("datetime",r))</span>;c</span>ase"date-array":<span class="cstat-no" title="statement not covered" >return t.map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >ct("date",r))</span>;c</span>ase"time-array":<span class="cstat-no" title="statement not covered" >return t.map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >ct("time",r))</span>;d</span>efault:<span class="cstat-no" title="statement not covered" >return t}</span>}</span>function <span class="fstat-no" title="function not covered" >qn(</span>e){let t=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >Sm(e);<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;e.rows.length;n++){let i=<span class="cstat-no" title="statement not covered" >e.rows[n],</span>o=<span class="cstat-no" title="statement not covered" >{...r};<span class="cstat-no" title="statement not covered" ></span>for(let s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;i.length;s++)<span class="cstat-no" title="statement not covered" >o[e.columns[s]]=ct(e.types[s],i[s]);<span class="cstat-no" title="statement not covered" >t</span></span>.push(o)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >Sm(</span>e){let t=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;e.columns.length;r++)<span class="cstat-no" title="statement not covered" >t[e.columns[r]]=null;<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>var Am=F("prisma:client:request_handler"),Vn=class{constructor(t,r){this.logEmitter=r,this.client=t,this.dataloader=new $n({batchLoader:Ba(<span class="fstat-no" title="function not covered" >as</span>ync({requests:n,customDataProxyFetch:i})=&gt;{let{transaction:o,otelParentCtx:s}=<span class="cstat-no" title="statement not covered" >n[0],</span>a=<span class="cstat-no" title="statement not covered" >n.map(<span class="fstat-no" title="function not covered" >p=</span>&gt;<span class="cstat-no" title="statement not covered" >p.protocolQuery)</span>,</span>l=<span class="cstat-no" title="statement not covered" >this.client._tracingHelper.getTraceParent(s),</span>u=<span class="cstat-no" title="statement not covered" >n.some(<span class="fstat-no" title="function not covered" >p=</span>&gt;<span class="cstat-no" title="statement not covered" >bo(p.protocolQuery.action))</span>;<span class="cstat-no" title="statement not covered" ></span>return(await this.client._engine.requestBatch(a,{traceparent:l,transaction:Im(o),containsWrite:u,customDataProxyFetch:i})).map(<span class="fstat-no" title="function not covered" >(p</span>,d)=&gt;{<span class="cstat-no" title="statement not covered" >if(p instanceof Error)<span class="cstat-no" title="statement not covered" >return p;<span class="cstat-no" title="statement not covered" >t</span></span>ry{<span class="cstat-no" title="statement not covered" >return this.mapQueryEngineResult(n[d],p)}</span>catch(f){<span class="cstat-no" title="statement not covered" >return f}</span>}</span>)}</span>),singleLoader:async n=&gt;{let i=n.transaction?.kind==="itx"?<span class="branch-0 cbranch-no" title="branch not covered" >Ml(n.transaction):</span>void 0,o=await this.client._engine.request(n.protocolQuery,{traceparent:this.client._tracingHelper.getTraceParent(),interactiveTransaction:i,isWrite:bo(n.protocolQuery.action),customDataProxyFetch:n.customDataProxyFetch});return this.mapQueryEngineResult(n,o)},batchBy:n=&gt;n.transaction?.id?<span class="branch-0 cbranch-no" title="branch not covered" >`transaction-${n.transaction.id}`:</span>Ll(n.protocolQuery),<span class="fstat-no" title="function not covered" >ba</span>tchOrder(n,i){<span class="cstat-no" title="statement not covered" >return n.transaction?.kind==="batch"&amp;&amp;i.transaction?.kind==="batch"?n.transaction.index-i.transaction.index:0}</span>})}async request(t){try{return await this.dataloader.request(t)}catch(r){let{clientMethod:n,callsite:i,transaction:o,args:s,modelName:a}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>this.handleAndLogRequestError({error:r,clientMethod:n,callsite:i,transaction:o,args:s,modelName:a,globalOmit:t.globalOmit})}</span>}mapQueryEngineResult({dataPath:t,unpacker:r},n){let i=n?.data,o=this.unpack(i,t,r);return process.env.PRISMA_CLIENT_GET_TIME?<span class="branch-0 cbranch-no" title="branch not covered" >{data:o}:</span>o}<span class="fstat-no" title="function not covered" >ha</span>ndleAndLogRequestError(t){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >this.handleRequestError(t)}</span>catch(r){<span class="cstat-no" title="statement not covered" >throw this.logEmitter&amp;&amp;this.logEmitter.emit("error",{message:r.message,target:t.clientMethod,timestamp:new Date}),r}</span>}<span class="fstat-no" title="function not covered" ></span>ha</span>ndleRequestError({error:t,clientMethod:r,callsite:n,transaction:i,args:o,modelName:s,globalOmit:a}){<span class="cstat-no" title="statement not covered" >if(Am(t),Om(t,i))<span class="cstat-no" title="statement not covered" >throw t;<span class="cstat-no" title="statement not covered" >i</span></span>f(t instanceof ee&amp;&amp;km(t)){let u=<span class="cstat-no" title="statement not covered" >$l(t.meta);<span class="cstat-no" title="statement not covered" ></span>wn({args:o,errors:[u],callsite:n,errorFormat:this.client._errorFormat,originalMethod:r,clientVersion:this.client._clientVersion,globalOmit:a})}</span>l</span>et l=<span class="cstat-no" title="statement not covered" >t.message;<span class="cstat-no" title="statement not covered" ></span>if(n&amp;&amp;(l=cn({callsite:n,originalMethod:r,isPanic:t.isPanic,showColors:this.client._errorFormat==="pretty",message:l})),l=this.sanitizeMessage(l),t.code){let u=<span class="cstat-no" title="statement not covered" >s?{modelName:s,...t.meta}:t.meta;<span class="cstat-no" title="statement not covered" ></span>throw new ee(l,{code:t.code,clientVersion:this.client._clientVersion,meta:u,batchRequestIdx:t.batchRequestIdx})}</span>else{<span class="cstat-no" title="statement not covered" >if(t.isPanic)<span class="cstat-no" title="statement not covered" >throw new ce(l,this.client._clientVersion);<span class="cstat-no" title="statement not covered" >i</span></span>f(t instanceof B)<span class="cstat-no" title="statement not covered" >throw new B(l,{clientVersion:this.client._clientVersion,batchRequestIdx:t.batchRequestIdx});<span class="cstat-no" title="statement not covered" >i</span></span>f(t instanceof T)<span class="cstat-no" title="statement not covered" >throw new T(l,this.client._clientVersion);<span class="cstat-no" title="statement not covered" >i</span></span>f(t instanceof ce)<span class="cstat-no" title="statement not covered" >throw new ce(l,this.client._clientVersion)}<span class="cstat-no" title="statement not covered" ></span></span>t</span>hrow t.clientVersion=this.client._clientVersion,t}<span class="fstat-no" title="function not covered" ></span>sa</span>nitizeMessage(t){<span class="cstat-no" title="statement not covered" >return this.client._errorFormat&amp;&amp;this.client._errorFormat!=="pretty"?(0,Fl.default)(t):t}</span>unpack(t,r,n){<span class="missing-if-branch" title="if path not taken" >I</span>if(!t||(t.data&amp;&amp;(t=t.data),!t))<span class="cstat-no" title="statement not covered" >return t;l</span>et i=Object.keys(t)[0],o=Object.values(t)[0],s=r.filter(<span class="fstat-no" title="function not covered" >u=</span>&gt;<span class="cstat-no" title="statement not covered" >u!=="select"&amp;&amp;u!=="include")</span>,a=Ki(o,s),l=i==="queryRaw"?<span class="branch-0 cbranch-no" title="branch not covered" >qn(a):</span>bt(a);return n?<span class="branch-0 cbranch-no" title="branch not covered" >n(l):</span>l}<span class="fstat-no" title="function not covered" >ge</span>t[Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"RequestHandler"}</span>};function <span class="fstat-no" title="function not covered" >Im(</span>e){<span class="cstat-no" title="statement not covered" >if(e){<span class="cstat-no" title="statement not covered" >if(e.kind==="batch")<span class="cstat-no" title="statement not covered" >return{kind:"batch",options:{isolationLevel:e.isolationLevel}};<span class="cstat-no" title="statement not covered" >i</span></span>f(e.kind==="itx")<span class="cstat-no" title="statement not covered" >return{kind:"itx",options:Ml(e)};<span class="cstat-no" title="statement not covered" >F</span></span>e(e,"Unknown transaction kind")}</span>}</span>function <span class="fstat-no" title="function not covered" >Ml(</span>e){<span class="cstat-no" title="statement not covered" >return{id:e.id,payload:e.payload}}</span>function <span class="fstat-no" title="function not covered" >Om(</span>e,t){<span class="cstat-no" title="statement not covered" >return Mn(e)&amp;&amp;t?.kind==="batch"&amp;&amp;e.batchRequestIdx!==t.index}</span>function <span class="fstat-no" title="function not covered" >km(</span>e){<span class="cstat-no" title="statement not covered" >return e.code==="P2009"||e.code==="P2012"}</span>function <span class="fstat-no" title="function not covered" >$l(</span>e){<span class="cstat-no" title="statement not covered" >if(e.kind==="Union")<span class="cstat-no" title="statement not covered" >return{kind:"Union",errors:e.errors.map($l)};<span class="cstat-no" title="statement not covered" >i</span></span>f(Array.isArray(e.selectionPath)){let[,...t]=<span class="cstat-no" title="statement not covered" >e.selectionPath;<span class="cstat-no" title="statement not covered" ></span>return{...e,selectionPath:t}}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>var ql="6.2.1";var Vl=ql;var Gl=D(_i());var L=class extends Error{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t+`</span>
Read more at https://pris.ly/d/client-constructor`),this.name="PrismaClientConstructorValidationError"}<span class="fstat-no" title="function not covered" >ge</span>t[Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClientConstructorValidationError"}</span>};w(L,"PrismaClientConstructorValidationError");var jl=["datasources","datasourceUrl","errorFormat","adapter","log","transactionOptions","omit","__internal"],Bl=["pretty","colorless","minimal"],Ul=["info","query","warn","error"],_m={datasources:(e,{datasourceNames:t})=&gt;{<span class="missing-if-branch" title="else path not taken" >E</span>if(e){<span class="missing-if-branch" title="if path not taken" >I</span>if(typeof e!="object"||Array.isArray(e))<span class="cstat-no" title="statement not covered" >throw new L(`Invalid value ${JSON.stringify(e)} for "datasources" provided to PrismaClient constructor`);f</span>or(let[r,n]of Object.entries(e)){<span class="missing-if-branch" title="if path not taken" >I</span>if(!t.includes(r)){let i=<span class="cstat-no" title="statement not covered" >Vt(r,t)||` Available datasources: ${t.join(", ")}`;<span class="cstat-no" title="statement not covered" ></span>throw new L(`Unknown datasource ${r} provided to PrismaClient constructor.${i}`)}<span class="missing-if-branch" title="if path not taken" >I</span></span>if(typeof n!="object"||Array.isArray(n))<span class="cstat-no" title="statement not covered" >throw new L(`Invalid value ${JSON.stringify(e)} for datasource "${r}" provided to PrismaClient constructor.</span>
It should have this form: { url: "CONNECTION_STRING" }`);<span class="missing-if-branch" title="else path not taken" >E</span>if(n&amp;&amp;typeof n=="object")for(let[i,o]of Object.entries(n)){<span class="missing-if-branch" title="if path not taken" >I</span>if(i!=="url")<span class="cstat-no" title="statement not covered" >throw new L(`Invalid value ${JSON.stringify(e)} for datasource "${r}" provided to PrismaClient constructor.</span>
It should have this form: { url: "CONNECTION_STRING" }`);<span class="missing-if-branch" title="if path not taken" >I</span>if(typeof o!="string")<span class="cstat-no" title="statement not covered" >throw new L(`Invalid value ${JSON.stringify(o)} for datasource "${r}" provided to PrismaClient constructor.</span>
It should have this form: { url: "CONNECTION_STRING" }`)}}}},adapter:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >if(e===null)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(e===void 0)<span class="cstat-no" title="statement not covered" >throw new L('"adapter" property must not be undefined, use null to conditionally disable driver adapters.');<span class="cstat-no" title="statement not covered" >i</span></span>f(!Ln(t).includes("driverAdapters"))<span class="cstat-no" title="statement not covered" >throw new L('"adapter" property can only be provided to PrismaClient constructor when "driverAdapters" preview feature is enabled.');<span class="cstat-no" title="statement not covered" >i</span></span>f(Yt()==="binary")<span class="cstat-no" title="statement not covered" >throw new L('Cannot use a driver adapter with the "binary" Query Engine. Please use the "library" Query Engine.')}</span></span>,datasourceUrl:<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(typeof e&lt;"u"&amp;&amp;typeof e!="string")<span class="cstat-no" title="statement not covered" >throw new L(`Invalid value ${JSON.stringify(e)} for "datasourceUrl" provided to PrismaClient constructor.</span></span>
Expected string or undefined.`)},errorFormat:<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(e){<span class="cstat-no" title="statement not covered" >if(typeof e!="string")<span class="cstat-no" title="statement not covered" >throw new L(`Invalid value ${JSON.stringify(e)} for "errorFormat" provided to PrismaClient constructor.`);<span class="cstat-no" title="statement not covered" >i</span></span>f(!Bl.includes(e)){let t=<span class="cstat-no" title="statement not covered" >Vt(e,Bl);<span class="cstat-no" title="statement not covered" ></span>throw new L(`Invalid errorFormat ${e} provided to PrismaClient constructor.${t}`)}</span>}</span>}</span>,log:<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(!Array.isArray(e))<span class="cstat-no" title="statement not covered" >throw new L(`Invalid value ${JSON.stringify(e)} for "log" provided to PrismaClient constructor.`);f</span></span>unction <span class="fstat-no" title="function not covered" >t(</span>r){<span class="cstat-no" title="statement not covered" >if(typeof r=="string"&amp;&amp;!Ul.includes(r)){let n=<span class="cstat-no" title="statement not covered" >Vt(r,Ul);<span class="cstat-no" title="statement not covered" ></span>throw new L(`Invalid log level "${r}" provided to PrismaClient constructor.${n}`)}</span>}<span class="cstat-no" title="statement not covered" ></span>for(let r of e){<span class="cstat-no" title="statement not covered" >t(r);l</span>et n=<span class="cstat-no" title="statement not covered" >{level:t,emit:<span class="fstat-no" title="function not covered" >i=</span>&gt;{let o=<span class="cstat-no" title="statement not covered" >["stdout","event"];<span class="cstat-no" title="statement not covered" ></span>if(!o.includes(i)){let s=<span class="cstat-no" title="statement not covered" >Vt(i,o);<span class="cstat-no" title="statement not covered" ></span>throw new L(`Invalid value ${JSON.stringify(i)} for "emit" in logLevel provided to PrismaClient constructor.${s}`)}</span>}</span>};<span class="cstat-no" title="statement not covered" ></span>if(r&amp;&amp;typeof r=="object")<span class="cstat-no" title="statement not covered" >for(let[i,o]of Object.entries(r))<span class="cstat-no" title="statement not covered" >if(n[i])<span class="cstat-no" title="statement not covered" >n[i](o);e</span>lse <span class="cstat-no" title="statement not covered" >throw new L(`Invalid property ${i} for "log" provided to PrismaClient constructor`)}</span></span></span></span>}</span>,transactionOptions:<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return;l</span></span>et t=<span class="cstat-no" title="statement not covered" >e.maxWait;<span class="cstat-no" title="statement not covered" ></span>if(t!=null&amp;&amp;t&lt;=0)<span class="cstat-no" title="statement not covered" >throw new L(`Invalid value ${t} for maxWait in "transactionOptions" provided to PrismaClient constructor. maxWait needs to be greater than 0`);l</span></span>et r=<span class="cstat-no" title="statement not covered" >e.timeout;<span class="cstat-no" title="statement not covered" ></span>if(r!=null&amp;&amp;r&lt;=0)<span class="cstat-no" title="statement not covered" >throw new L(`Invalid value ${r} for timeout in "transactionOptions" provided to PrismaClient constructor. timeout needs to be greater than 0`)}</span></span>,omit:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >if(typeof e!="object")<span class="cstat-no" title="statement not covered" >throw new L('"omit" option is expected to be an object.');<span class="cstat-no" title="statement not covered" >i</span></span>f(e===null)<span class="cstat-no" title="statement not covered" >throw new L('"omit" option can not be `null`');l</span></span>et r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let[n,i]of Object.entries(e)){let o=<span class="cstat-no" title="statement not covered" >Lm(n,t.runtimeDataModel);<span class="cstat-no" title="statement not covered" ></span>if(!o){<span class="cstat-no" title="statement not covered" >r.push({kind:"UnknownModel",modelKey:n});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>f</span>or(let[s,a]of Object.entries(i)){let l=<span class="cstat-no" title="statement not covered" >o.fields.find(<span class="fstat-no" title="function not covered" >u=</span>&gt;<span class="cstat-no" title="statement not covered" >u.name===s)</span>;<span class="cstat-no" title="statement not covered" ></span>if(!l){<span class="cstat-no" title="statement not covered" >r.push({kind:"UnknownField",modelKey:n,fieldName:s});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(l.relationName){<span class="cstat-no" title="statement not covered" >r.push({kind:"RelationInOmit",modelKey:n,fieldName:s});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>t</span>ypeof a!="boolean"&amp;&amp;r.push({kind:"InvalidFieldValue",modelKey:n,fieldName:s})}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(r.length&gt;0)<span class="cstat-no" title="statement not covered" >throw new L(Fm(e,r))}</span></span>,__internal:<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return;l</span></span>et t=<span class="cstat-no" title="statement not covered" >["debug","engine","configOverride"];<span class="cstat-no" title="statement not covered" ></span>if(typeof e!="object")<span class="cstat-no" title="statement not covered" >throw new L(`Invalid value ${JSON.stringify(e)} for "__internal" to PrismaClient constructor`);<span class="cstat-no" title="statement not covered" >f</span></span>or(let[r]of Object.entries(e))<span class="cstat-no" title="statement not covered" >if(!t.includes(r)){let n=<span class="cstat-no" title="statement not covered" >Vt(r,t);<span class="cstat-no" title="statement not covered" ></span>throw new L(`Invalid property ${JSON.stringify(r)} for "__internal" provided to PrismaClient constructor.${n}`)}</span>}</span></span>};function Jl(e,t){for(let[r,n]of Object.entries(e)){<span class="missing-if-branch" title="if path not taken" >I</span>if(!jl.includes(r)){let i=<span class="cstat-no" title="statement not covered" >Vt(r,jl);<span class="cstat-no" title="statement not covered" ></span>throw new L(`Unknown property ${r} provided to PrismaClient constructor.${i}`)}</span>_m[r](n,t)}<span class="missing-if-branch" title="if path not taken" >I</span>if(e.datasourceUrl&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >e.datasources)<span class="cstat-no" title="statement not covered" ></span>throw new L('Can not use "datasourceUrl" and "datasources" options at the same time. Pick one of them')}</span>function <span class="fstat-no" title="function not covered" >Vt(</span>e,t){<span class="cstat-no" title="statement not covered" >if(t.length===0||typeof e!="string")<span class="cstat-no" title="statement not covered" >return"";l</span></span>et r=<span class="cstat-no" title="statement not covered" >Nm(e,t);<span class="cstat-no" title="statement not covered" ></span>return r?` Did you mean "${r}"?`:""}</span>function <span class="fstat-no" title="function not covered" >Nm(</span>e,t){<span class="cstat-no" title="statement not covered" >if(t.length===0)<span class="cstat-no" title="statement not covered" >return null;l</span></span>et r=<span class="cstat-no" title="statement not covered" >t.map(<span class="fstat-no" title="function not covered" >i=</span>&gt;(<span class="cstat-no" title="statement not covered" >{value:i,distance:(0,Gl.default)(e,i)})</span>);<span class="cstat-no" title="statement not covered" ></span>r.sort(<span class="fstat-no" title="function not covered" >(i</span>,o)=&gt;<span class="cstat-no" title="statement not covered" >i.distance&lt;o.distance?-1:1)</span>;l</span>et n=<span class="cstat-no" title="statement not covered" >r[0];<span class="cstat-no" title="statement not covered" ></span>return n.distance&lt;3?n.value:null}</span>function <span class="fstat-no" title="function not covered" >Lm(</span>e,t){<span class="cstat-no" title="statement not covered" >return Ql(t.models,e)??Ql(t.types,e)}</span>function <span class="fstat-no" title="function not covered" >Ql(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >Object.keys(e).find(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >wt(n)===t)</span>;<span class="cstat-no" title="statement not covered" ></span>if(r)<span class="cstat-no" title="statement not covered" >return e[r]}</span></span>function <span class="fstat-no" title="function not covered" >Fm(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >At(e);<span class="cstat-no" title="statement not covered" ></span>for(let o of t)<span class="cstat-no" title="statement not covered" >switch(o.kind){case"UnknownModel":<span class="cstat-no" title="statement not covered" >r.arguments.getField(o.modelKey)?.markAsError(),r.addErrorMessage(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >`Unknown model name: ${o.modelKey}.`)</span>;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"UnknownField":<span class="cstat-no" title="statement not covered" >r.arguments.getDeepField([o.modelKey,o.fieldName])?.markAsError(),r.addErrorMessage(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >`Model "${o.modelKey}" does not have a field named "${o.fieldName}".`)</span>;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"RelationInOmit":<span class="cstat-no" title="statement not covered" >r.arguments.getDeepField([o.modelKey,o.fieldName])?.markAsError(),r.addErrorMessage(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >'Relations are already excluded by default and can not be specified in "omit".')</span>;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"InvalidFieldValue":<span class="cstat-no" title="statement not covered" >r.arguments.getDeepFieldValue([o.modelKey,o.fieldName])?.markAsError(),r.addErrorMessage(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >"Omit field option value must be a boolean.")</span>;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>l</span></span>et{message:n,args:i}=<span class="cstat-no" title="statement not covered" >bn(r,"colorless");<span class="cstat-no" title="statement not covered" ></span>return`Error validating "omit" option:</span>
&nbsp;
${i}
&nbsp;
${n}`}function <span class="fstat-no" title="function not covered" >Hl(</span>e){<span class="cstat-no" title="statement not covered" >return e.length===0?Promise.resolve([]):new Promise(<span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{let n=<span class="cstat-no" title="statement not covered" >new Array(e.length),</span>i=<span class="cstat-no" title="statement not covered" >null,</span>o=<span class="cstat-no" title="statement not covered" >!1,</span>s=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >o||(s++,s===e.length&amp;&amp;(o=!0,i?r(i):t(n)))}</span>,</span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >u=</span>&gt;{<span class="cstat-no" title="statement not covered" >o||(o=!0,r(u))}</span>;<span class="cstat-no" title="statement not covered" ></span>for(let u=<span class="cstat-no" title="statement not covered" >0;</span>u&lt;e.length;u++)<span class="cstat-no" title="statement not covered" >e[u].then(<span class="fstat-no" title="function not covered" >c=</span>&gt;{<span class="cstat-no" title="statement not covered" >n[u]=c,a()}</span>,<span class="fstat-no" title="function not covered" >c=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!Mn(c)){<span class="cstat-no" title="statement not covered" >l(c);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>c</span>.batchRequestIdx===u?l(c):(i||(i=c),a())}</span>)}</span></span>)}</span>var tt=F("prisma:client");typeof globalThis=="object"&amp;&amp;(globalThis.NODE_CLIENT=!0);var Mm={requestArgsToMiddlewareArgs:e=&gt;e,middlewareArgsToRequestArgs:e=&gt;e},$m=Symbol.for("prisma.client.transaction.id"),qm={id:0,<span class="fstat-no" title="function not covered" >ne</span>xtId(){<span class="cstat-no" title="statement not covered" >return++this.id}</span>};function Xl(e){class t{constructor(n){this._originalClient=this;this._middlewares=new Fn;this._createPrismaPromise=ho();this.$extends=Na;e=n?.__internal?.configOverride?.(e)??e,Ha(e),n&amp;&amp;Jl(n,e);let i=new zl.EventEmitter().on("error",<span class="fstat-no" title="function not covered" >()</span>=&gt;{});this._extensions=It.empty(),this._previewFeatures=Ln(e),this._clientVersion=e.clientVersion??<span class="branch-1 cbranch-no" title="branch not covered" >Vl,</span>this._activeProvider=e.activeProvider,this._globalOmit=n?.omit,this._tracingHelper=Dl();let o={rootEnvPath:e.relativeEnvPaths.rootEnvPath&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >Nr.default.resolve(e.dirname,e.relativeEnvPaths.rootEnvPath),</span>schemaEnvPath:e.relativeEnvPaths.schemaEnvPath&amp;&amp;Nr.default.resolve(e.dirname,e.relativeEnvPaths.schemaEnvPath)},s;<span class="missing-if-branch" title="if path not taken" >I</span>if(n?.adapter){<span class="cstat-no" title="statement not covered" >s=Qi(n.adapter);l</span>et l=<span class="cstat-no" title="statement not covered" >e.activeProvider==="postgresql"?"postgres":e.activeProvider;<span class="cstat-no" title="statement not covered" ></span>if(s.provider!==l)<span class="cstat-no" title="statement not covered" >throw new T(`The Driver Adapter \`${s.adapterName}\`, based on \`${s.provider}\`, is not compatible with the provider \`${l}\` specified in the Prisma schema.`,this._clientVersion);<span class="cstat-no" title="statement not covered" >i</span></span>f(n.datasources||n.datasourceUrl!==void 0)<span class="cstat-no" title="statement not covered" >throw new T("Custom datasource configuration is not compatible with Prisma Driver Adapters. Please define the database connection string directly in the Driver Adapter configuration.",this._clientVersion)}</span></span>let a=!s&amp;&amp;Kt(o,{conflictCheck:"none"})||<span class="branch-2 cbranch-no" title="branch not covered" >e.injectableEdgeEnv?.();</span>try{let l=n??{},u=l.__internal??{},c=u.debug===!0;c&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >F.enable("prisma:client");</span>let p=Nr.default.resolve(e.dirname,e.relativePath);Zl.default.existsSync(p)||(<span class="branch-1 cbranch-no" title="branch not covered" >p=e.dirname)</span>,tt("dirname",e.dirname),tt("relativePath",e.relativePath),tt("cwd",p);let d=u.engine||{};<span class="missing-if-branch" title="if path not taken" >I</span>if(l.errorFormat?<span class="branch-0 cbranch-no" title="branch not covered" >this._errorFormat=l.errorFormat:</span>process.env.NODE_ENV==="production"?<span class="branch-0 cbranch-no" title="branch not covered" >this._errorFormat="minimal":</span>process.env.NO_COLOR?<span class="branch-0 cbranch-no" title="branch not covered" >this._errorFormat="colorless":</span>this._errorFormat="colorless",this._runtimeDataModel=e.runtimeDataModel,this._engineConfig={cwd:p,dirname:e.dirname,enableDebugLogs:c,allowTriggerPanic:d.allowTriggerPanic,datamodelPath:Nr.default.join(e.dirname,e.filename??"schema.prisma"),prismaPath:d.binaryPath??void 0,engineEndpoint:d.endpoint,generator:e.generator,showColors:this._errorFormat==="pretty",logLevel:l.log&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >Nl(l.log),</span>logQueries:l.log&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >!!(typeof l.log=="string"?l.log==="query":l.log.find(<span class="fstat-no" title="function not covered" >f=</span>&gt;<span class="cstat-no" title="statement not covered" >typeof f=="string"?f==="query":f.level==="query")</span>),</span>env:a?.parsed??<span class="branch-1 cbranch-no" title="branch not covered" >{},</span>flags:[],engineWasm:e.engineWasm,clientVersion:e.clientVersion,engineVersion:e.engineVersion,previewFeatures:this._previewFeatures,activeProvider:e.activeProvider,inlineSchema:e.inlineSchema,overrideDatasources:Wa(l,e.datasourceNames),inlineDatasources:e.inlineDatasources,inlineSchemaHash:e.inlineSchemaHash,tracingHelper:this._tracingHelper,transactionOptions:{maxWait:l.transactionOptions?.maxWait??2e3,timeout:l.transactionOptions?.timeout??5e3,isolationLevel:l.transactionOptions?.isolationLevel},logEmitter:i,isBundled:e.isBundled,adapter:s},this._accelerateEngineConfig={...this._engineConfig,accelerateUtils:{resolveDatasourceUrl:Lt,getBatchRequestPayload:Dt,prismaGraphQLToJSError:_t,PrismaClientUnknownRequestError:B,PrismaClientInitializationError:T,PrismaClientKnownRequestError:ee,debug:F("prisma:client:accelerateEngine"),engineVersion:Kl.version,clientVersion:e.clientVersion}},tt("clientVersion",e.clientVersion),this._engine=wl(e,this._engineConfig),this._requestHandler=new Vn(this,i),l.log)<span class="cstat-no" title="statement not covered" >for(let f of l.log){let g=<span class="cstat-no" title="statement not covered" >typeof f=="string"?f:f.emit==="stdout"?f.level:null;<span class="cstat-no" title="statement not covered" ></span>g&amp;&amp;this.$on(g,<span class="fstat-no" title="function not covered" >h=</span>&gt;{<span class="cstat-no" title="statement not covered" >er.log(`${er.tags[g]??""}`,h.message||h.query)}</span>)}</span>t</span>his._metrics=new Ot(this._engine)}catch(l){<span class="cstat-no" title="statement not covered" >throw l.clientVersion=this._clientVersion,l}</span>return this._appliedParent=yr(this)}<span class="fstat-no" title="function not covered" >ge</span>t[Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClient"}<span class="fstat-no" title="function not covered" ></span>$u</span>se(n){<span class="cstat-no" title="statement not covered" >this._middlewares.use(n)}<span class="fstat-no" title="function not covered" ></span>$o</span>n(n,i){<span class="cstat-no" title="statement not covered" >n==="beforeExit"?this._engine.onBeforeExit(i):n&amp;&amp;this._engineConfig.logEmitter.on(n,i)}<span class="fstat-no" title="function not covered" ></span>$c</span>onnect(){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return this._engine.start()}</span>catch(n){<span class="cstat-no" title="statement not covered" >throw n.clientVersion=this._clientVersion,n}</span>}</span>async $disconnect(){try{await this._engine.stop()}catch(n){<span class="cstat-no" title="statement not covered" >throw n.clientVersion=this._clientVersion,n}</span>finally{Do()}}<span class="fstat-no" title="function not covered" >$e</span>xecuteRawInternal(n,i,o,s){let a=<span class="cstat-no" title="statement not covered" >this._activeProvider;<span class="cstat-no" title="statement not covered" ></span>return this._request({action:"executeRaw",args:o,transaction:n,clientMethod:i,argsMapper:go({clientMethod:i,activeProvider:a}),callsite:Ze(this._errorFormat),dataPath:[],middlewareArgsMapper:s})}<span class="fstat-no" title="function not covered" ></span>$e</span>xecuteRaw(n,...i){<span class="cstat-no" title="statement not covered" >return this._createPrismaPromise(<span class="fstat-no" title="function not covered" >o=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(n.raw!==void 0||n.sql!==void 0){let[s,a]=<span class="cstat-no" title="statement not covered" >Wl(n,i);<span class="cstat-no" title="statement not covered" ></span>return fo(this._activeProvider,s.text,s.values,Array.isArray(n)?"prisma.$executeRaw`&lt;SQL&gt;`":"prisma.$executeRaw(sql`&lt;SQL&gt;`)"),this.$executeRawInternal(o,"$executeRaw",s,a)}<span class="cstat-no" title="statement not covered" ></span>t</span>hrow new te("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n",{clientVersion:this._clientVersion})}</span>)}<span class="fstat-no" title="function not covered" ></span>$e</span>xecuteRawUnsafe(n,...i){<span class="cstat-no" title="statement not covered" >return this._createPrismaPromise(<span class="fstat-no" title="function not covered" >o=</span>&gt;(<span class="cstat-no" title="statement not covered" >fo(this._activeProvider,n,i,"prisma.$executeRawUnsafe(&lt;SQL&gt;, [...values])"),this.$executeRawInternal(o,"$executeRawUnsafe",[n,...i]))</span>)}<span class="fstat-no" title="function not covered" ></span>$r</span>unCommandRaw(n){<span class="cstat-no" title="statement not covered" >if(e.activeProvider!=="mongodb")<span class="cstat-no" title="statement not covered" >throw new te(`The ${e.activeProvider} provider does not support $runCommandRaw. Use the mongodb provider.`,{clientVersion:this._clientVersion});<span class="cstat-no" title="statement not covered" >r</span></span>eturn this._createPrismaPromise(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >this._request({args:n,clientMethod:"$runCommandRaw",dataPath:[],action:"runCommandRaw",argsMapper:xl,callsite:Ze(this._errorFormat),transaction:i}))</span>}<span class="fstat-no" title="function not covered" ></span>as</span>ync $queryRawInternal(n,i,o,s){let a=<span class="cstat-no" title="statement not covered" >this._activeProvider;<span class="cstat-no" title="statement not covered" ></span>return this._request({action:"queryRaw",args:o,transaction:n,clientMethod:i,argsMapper:go({clientMethod:i,activeProvider:a}),callsite:Ze(this._errorFormat),dataPath:[],middlewareArgsMapper:s})}<span class="fstat-no" title="function not covered" ></span>$q</span>ueryRaw(n,...i){<span class="cstat-no" title="statement not covered" >return this._createPrismaPromise(<span class="fstat-no" title="function not covered" >o=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(n.raw!==void 0||n.sql!==void 0)<span class="cstat-no" title="statement not covered" >return this.$queryRawInternal(o,"$queryRaw",...Wl(n,i));<span class="cstat-no" title="statement not covered" >t</span></span>hrow new te("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n",{clientVersion:this._clientVersion})}</span>)}<span class="fstat-no" title="function not covered" ></span>$q</span>ueryRawTyped(n){<span class="cstat-no" title="statement not covered" >return this._createPrismaPromise(<span class="fstat-no" title="function not covered" >i=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!this._hasPreviewFlag("typedSql"))<span class="cstat-no" title="statement not covered" >throw new te("`typedSql` preview feature must be enabled in order to access $queryRawTyped API",{clientVersion:this._clientVersion});<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.$queryRawInternal(i,"$queryRawTyped",n)}</span>)}<span class="fstat-no" title="function not covered" ></span>$q</span>ueryRawUnsafe(n,...i){<span class="cstat-no" title="statement not covered" >return this._createPrismaPromise(<span class="fstat-no" title="function not covered" >o=</span>&gt;<span class="cstat-no" title="statement not covered" >this.$queryRawInternal(o,"$queryRawUnsafe",[n,...i]))</span>}<span class="fstat-no" title="function not covered" ></span>_t</span>ransactionWithArray({promises:n,options:i}){let o=<span class="cstat-no" title="statement not covered" >qm.nextId(),</span>s=<span class="cstat-no" title="statement not covered" >_l(n.length),</span>a=<span class="cstat-no" title="statement not covered" >n.map(<span class="fstat-no" title="function not covered" >(l</span>,u)=&gt;{<span class="cstat-no" title="statement not covered" >if(l?.[Symbol.toStringTag]!=="PrismaPromise")<span class="cstat-no" title="statement not covered" >throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");l</span></span>et c=<span class="cstat-no" title="statement not covered" >i?.isolationLevel??this._engineConfig.transactionOptions.isolationLevel,</span>p=<span class="cstat-no" title="statement not covered" >{kind:"batch",id:o,index:u,isolationLevel:c,lock:s};<span class="cstat-no" title="statement not covered" ></span>return l.requestTransaction?.(p)??l}</span>);<span class="cstat-no" title="statement not covered" ></span>return Hl(a)}<span class="fstat-no" title="function not covered" ></span>as</span>ync _transactionWithCallback({callback:n,options:i}){let o=<span class="cstat-no" title="statement not covered" >{traceparent:this._tracingHelper.getTraceParent()},</span>s=<span class="cstat-no" title="statement not covered" >{maxWait:i?.maxWait??this._engineConfig.transactionOptions.maxWait,timeout:i?.timeout??this._engineConfig.transactionOptions.timeout,isolationLevel:i?.isolationLevel??this._engineConfig.transactionOptions.isolationLevel},</span>a=<span class="cstat-no" title="statement not covered" >await this._engine.transaction("start",o,s),</span>l;<span class="cstat-no" title="statement not covered" >try{let u=<span class="cstat-no" title="statement not covered" >{kind:"itx",...a};<span class="cstat-no" title="statement not covered" ></span>l=await n(this._createItxClient(u)),await this._engine.transaction("commit",o,a)}</span>catch(u){<span class="cstat-no" title="statement not covered" >throw await this._engine.transaction("rollback",o,a).catch(<span class="fstat-no" title="function not covered" >()</span>=&gt;{}),u}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn l}<span class="fstat-no" title="function not covered" ></span>_c</span>reateItxClient(n){<span class="cstat-no" title="statement not covered" >return yr(Ae(_a(this),[ie("_appliedParent",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this._appliedParent._createItxClient(n))</span>,ie("_createPrismaPromise",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >ho(n))</span>,ie($m,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >n.id)</span>,kt(Sl)]))}<span class="fstat-no" title="function not covered" ></span>$t</span>ransaction(n,i){let o;<span class="cstat-no" title="statement not covered" >typeof n=="function"?this._engineConfig.adapter?.adapterName==="@prisma/adapter-d1"?o=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >throw new Error("Cloudflare D1 does not support interactive transactions. We recommend you to refactor your queries with that limitation in mind, and use batch transactions with `prisma.$transactions([])` where applicable.")}</span>:o=<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this._transactionWithCallback({callback:n,options:i}):</span>o=<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this._transactionWithArray({promises:n,options:i});</span>l</span>et s=<span class="cstat-no" title="statement not covered" >{name:"transaction",attributes:{method:"$transaction"}};<span class="cstat-no" title="statement not covered" ></span>return this._tracingHelper.runInChildSpan(s,o)}</span>_request(n){n.otelParentCtx=this._tracingHelper.getActiveContext();let i=n.middlewareArgsMapper??Mm,o={args:i.requestArgsToMiddlewareArgs(n.args),dataPath:n.dataPath,runInTransaction:!!n.transaction,action:n.action,model:n.model},s={middleware:{name:"middleware",middleware:!0,attributes:{method:"$use"},active:!1},operation:{name:"operation",attributes:{method:o.action,model:o.model,name:o.model?`${o.model}.${o.action}`:<span class="branch-1 cbranch-no" title="branch not covered" >o.action}</span>}},a=-1,l=async u=&gt;{let c=this._middlewares.get(++a);<span class="missing-if-branch" title="if path not taken" >I</span>if(c)<span class="cstat-no" title="statement not covered" >return this._tracingHelper.runInChildSpan(s.middleware,<span class="fstat-no" title="function not covered" >O=</span>&gt;<span class="cstat-no" title="statement not covered" >c(u,<span class="fstat-no" title="function not covered" >P=</span>&gt;(<span class="cstat-no" title="statement not covered" >O?.end(),l(P))</span>))</span>;l</span>et{runInTransaction:p,args:d,...f}=u,g={...n,...f};d&amp;&amp;(g.args=i.middlewareArgsToRequestArgs(d)),n.transaction!==void 0&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >p===!1&amp;</span>&amp;<span class="branch-2 cbranch-no" title="branch not covered" >delete g.transaction;</span>let h=await ja(this,g);return g.model?Ma({result:h,modelName:g.model,args:g.args,extensions:this._extensions,runtimeDataModel:this._runtimeDataModel,globalOmit:this._globalOmit}):<span class="branch-1 cbranch-no" title="branch not covered" >h}</span>;return this._tracingHelper.runInChildSpan(s.operation,()=&gt;new Yl.AsyncResource("prisma-client-request").runInAsyncScope(()=&gt;l(o)))}async _executeRequest({args:n,clientMethod:i,dataPath:o,callsite:s,action:a,model:l,argsMapper:u,transaction:c,unpacker:p,otelParentCtx:d,customDataProxyFetch:f}){try{n=u?<span class="branch-0 cbranch-no" title="branch not covered" >u(n):</span>n;let g={name:"serialize"},h=this._tracingHelper.runInChildSpan(g,()=&gt;Pn({modelName:l,runtimeDataModel:this._runtimeDataModel,action:a,args:n,clientMethod:i,callsite:s,extensions:this._extensions,errorFormat:this._errorFormat,clientVersion:this._clientVersion,previewFeatures:this._previewFeatures,globalOmit:this._globalOmit}));return F.enabled("prisma:client")&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >tt("Prisma Client call:"),tt(`prisma.${i}(${va(n)})`),tt("Generated request:"),tt(JSON.stringify(h,null,2)+`</span>
`)),c?.kind==="batch"&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >await c.lock,</span>this._requestHandler.request({protocolQuery:h,modelName:l,action:a,clientMethod:i,dataPath:o,callsite:s,args:n,extensions:this._extensions,transaction:c,unpacker:p,otelParentCtx:d,otelChildCtx:this._tracingHelper.getActiveContext(),globalOmit:this._globalOmit,customDataProxyFetch:f})}catch(g){<span class="cstat-no" title="statement not covered" >throw g.clientVersion=this._clientVersion,g}</span>}<span class="fstat-no" title="function not covered" >ge</span>t $metrics(){<span class="cstat-no" title="statement not covered" >if(!this._hasPreviewFlag("metrics"))<span class="cstat-no" title="statement not covered" >throw new te("`metrics` preview feature must be enabled in order to access metrics API",{clientVersion:this._clientVersion});<span class="cstat-no" title="statement not covered" >r</span></span>eturn this._metrics}<span class="fstat-no" title="function not covered" ></span>_h</span>asPreviewFlag(n){<span class="cstat-no" title="statement not covered" >return!!this._engineConfig.previewFeatures?.includes(n)}<span class="fstat-no" title="function not covered" ></span>$a</span>pplyPendingMigrations(){<span class="cstat-no" title="statement not covered" >return this._engine.applyPendingMigrations()}</span>}return t}function <span class="fstat-no" title="function not covered" >Wl(</span>e,t){<span class="cstat-no" title="statement not covered" >return Vm(e)?[new ae(e,t),Il]:[e,Ol]}</span>function <span class="fstat-no" title="function not covered" >Vm(</span>e){<span class="cstat-no" title="statement not covered" >return Array.isArray(e)&amp;&amp;Array.isArray(e.raw)}</span>var jm=new Set(["toJSON","$$typeof","asymmetricMatch",Symbol.iterator,Symbol.toStringTag,Symbol.isConcatSpreadable,Symbol.toPrimitive]);function eu(e){return new Proxy(e,{<span class="fstat-no" title="function not covered" >ge</span>t(t,r){<span class="cstat-no" title="statement not covered" >if(r in t)<span class="cstat-no" title="statement not covered" >return t[r];<span class="cstat-no" title="statement not covered" >i</span></span>f(!jm.has(r))<span class="cstat-no" title="statement not covered" >throw new TypeError(`Invalid enum value: ${String(r)}`)}</span></span>})}function tu(e){Kt(e,{conflictCheck:"warn"})}0&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >module.exports={Debug,Decimal,Extensions,MetricsClient,PrismaClientInitializationError,PrismaClientKnownRequestError,PrismaClientRustPanicError,PrismaClientUnknownRequestError,PrismaClientValidationError,Public,Sql,defineDmmfProperty,deserializeJsonResponse,deserializeRawResult,dmmfToRuntimeDataModel,empty,getPrismaClient,getRuntime,join,makeStrictEnum,makeTypedQueryFactory,objectEnumValues,raw,serializeJsonQuery,skip,sqltag,warnEnvConflicts,warnOnce})</span>;
/*! Bundled license information:
&nbsp;
decimal.js/decimal.mjs:
  (*!
   *  decimal.js v10.4.3
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2022 Michael Mclaughlin &lt;M8ch88l@gmail.com&gt;
   *  MIT Licence
   *)
*/
//# sourceMappingURL=library.js.map
&nbsp;</pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2025-01-17T00:46:31.049Z
            </div>
        <script src="../../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../../sorter.js"></script>
        <script src="../../../block-navigation.js"></script>
    </body>
</html>
    